<link rel="stylesheet" href="../style/style.css">

#  02. DATA

## 01과 1을 숫자를 표현하는 방법
-컴퓨터는 0과 1로 모든 정보를 표현하고, 0과 1로 표현된 정보만을 이해할 수 있음. 
-컴퓨터가 이해하는 가장 작은 정보단위를 비트(bit)라고 한다.

### 정보 단위
- n비트는 0과 1을 2^n가지로 표현을 할 수 있다.
- 웹브라우저는, 워드 프로세서와 같은 모든 프로그램은 수십만, 수백만 개 이상의 0과 1로 이루어져 있음.
- 표현의 편의를 위해 비트보다 큰 단위를 사용하기로 함.
- 바이트, 킬로바이트, 메가바이트, 기가바이트, 테라바이트 등이 있음.

아래는 컴퓨터의 데이터 단위
|바이트|1byte|8bit|
|킬로바이트|1KiloByte|1000byte|
|메가바이트|1MegaByte|1000KB|
|기가바이트|1GigaByte|1000MB|
|테라바이트|1TeraByte|1000GB|

**예시** 바이트를 제외한 KB, MB, GB, 그 이상의 단위들은 모두 이전 단위를 1000개로 묶어 표현함. 1024개로 묶을 경우는 KiB, MiB와 같은 단위임.

### 워드(Word)
- 중요한 정보 단위 중 워드라는 단위도 있음.
- 워드(word)란 CPU가 한번에 처리할 수 있는 데이터의 크기를 의미한다.
- CPU가 한 번에 16bit를 처리할 수 있다면 1워드는 16bit가 되는 것이다.
- 이렇게 정의된 워드의 절반 크기를 **하프 워드(harf word)**, 1배의 크기를 **폴 워드(full word)**, 2배의 크기를 **더블 워드(double word)**라고 부름.

**예시**: 가령 인텔의 x86 CPU는 32비트 워드 CPU이며, x64 CPU는 64비트 워드 CPU가 된다.


## 이진법
- 수학에서 0과 1만으로 모든 숫자를 표현하는 방법을 **이진법**이라고 한다.
- 숫자가 1을 넘어가는 시점에 자리 올림을 하면 됨.
  - 이는 우리가 9로 넘어가는 시점에 자리 올림을 하는 **십진법**의 방식을 생각하면 됨.

|십진수|이진수|
|1|1|
|2|'1'0|
|3|11|
|4|'1'00|
|5|101|
|6|1'1'0|
|7|111|

이진법으로 표현한 수를 **이진수**, 십진법으로 표현한 수를 **십진수**라고 표현함. 0과 1밖에 모르는 컴퓨터에 어떤 숫자를 알려 주려면 십진수가 아닌 이진수로 알려주어야 함.

**주의** 
- 숫자만 볼때, 우리는 이것이 십진수인지 이진수인지 알 수 없음.
- 그러므로, 우리는 이런 혼동을 예방하기 위해 이진수 끝에 아래 첨자인 (2)를 붙이거나 이진수 앞에 0b를 붙인다.

### 이진수의 음수 표현
- 이진수의 음수 표현은 십진수의 음수 표현 방식처럼 앞에 마이너스 부호를 붙일 경우 컴퓨터가 이를 인식하지 못한다.
- 0과 1만으로 음수를 표현하는 방법 중 가장 널리 사용되는 방법은 **2의 보수**를 구해 이 값을 음수를 간주하는 방법임.

  **2의 보수란?**
  - 2의 보수는 **어떤 수를 그보다 큰 2^n에서 뺀 값**을 의미한다.
  - 쉽게 이해를 하자면 **모즌 0과 1을 뒤집고, 거기에 1을 더한 값**으로 이해하면 됨
      - 예를 들어, 11(2)을 뒤집을 경우 00(2)가 되고, 거기에 1을 더한 값은 01(2)라고 보면 됨. 즉, 11(2)의 2의 보수(음수표현)는 01(2)이 되는 것이다.
   

  -1011(2)을 표현하기 위한 2의 보수의 경우 모든 수를 뒤집은 0100(2)에 1을 더하면 0101(2)가 되는데, 이 0101(2)이 -1011(2)의 의미가 된다.
  그런데, 이런 의문이 생긴다. -1011(2)를 표현하기 위한 음수로서의 0101(2)과 십진수 5를 표현하기 위한 양수로서의 0101(2)은 똑같이 생겼는데, 이진수만 보고 양수인지 음수인지를 컴퓨터가 구분할 수 있는가?
  -> 실제로 이진수만 봐서는 음수인지, 양수인지의 구분이 힘들. 그래서 컴퓨터 내부에서 어떤 수를 다룰 때에는 이 수가 양수인지 음수인지를 구분하기 위해 **플래그(flag)**를 사용한다. 쉽게 말해 부가 정보이다.

  **간단 지식**
  이진수의 음수를 표현하기 위해 2의 보수를 취하는 방식은 아직까지도 가장 널리 사용이 되는 방식이지만, 완벽한 방식은 아님.
  2의 보수 방식엔 한계가 있다. 예를 들어, 8을 이진수로 표현하면 1000(2)이다. -1000(2)를 표현하기 위해선 모든 수를 뒤집고, 0111(2)이고, 1을 더하면 1000(2)가 된다. 즉, 8을 음수로 표현한 값이 자기 자신이 되어버리기 때문에 본질적으로 문제를 해결하기 어렵다. 즉, n비트로는 -2^n과 2^n이라는 수를 동시에 표현할 수 없다.


## 십육진법
- 이진법을 이용해 모든 숫자를 표현할 수 있지만 이진법은 0과 1만으로 모든 숫자를 표현하다 보니 숫자의 길이가 너무 길어진다는 단점이 있었음.
- 그래서 데이터를 표현할 때 이진법 이외에 십육진법도 자주 사용함.
- 십육진법은 **수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식**임.
- 그리고 십진수 10, 11, 12, 13, 14, 15를 십육진법 체계에서는 각각 A, B, C, D, E, F로 표기함.

|십진수|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|...|
|십육진수|0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|10|11|...|

십육진수는 이진수와 마찬가지로 숫자 뒤에 아래점자인 (16)을 붙이거나 숫자 앞에 0X를 붙여 구분함. 전자는 수학적 표기 방식이고, 후자는 코드상 표기 방식이었다. 
십육진법을 사용하는 주된 이유 중 하나는 이진수를 십육진수로, 십육진수를 이진수로 변환하기 쉬움.


### 십육진수를 이진수로 변환

- 십육진수는 한 글자당 열여섯 종류 (0~9), (A~F)의 숫자를 표현할 수 있다. 그러므로 비트가 필요할 경우 4비트가 필요함. 2^4 = 16이기 때문.
- 십육진수를 이진수로 변환하는 간편한 방법 중 하나는 십육진수 한글자를 4비트의 이진수로 간주하는 것.
  - 1A2B(16)를 이진수로 표현할 경우 1(16), A(16), 2(16), B(16)를 이진수로 표현하면 0001(2), 1010(2), 0010(2), 1011(2)이고, 해당 숫자들을 하나로 이어붙인 값인001101000101011(2)이 1A2B(16)를 이진수로 표현한 값임.
  - 반대로 이진수를 십육진수로 변환할 때에는 이진수 숫자를 네 개씩 끊고, 끊어 준 네개의 숫자를 하나의 십육진수로 변환한 뒤 그대로 이어붙이면 된다.
  - 이진수를 십진수로 변환할 때는 이렇게 간단하지 않으므로 이진수를 십육진수로 묶어 표현함.
 
**코드에서 십육진수를 직접 넣는 사례**

'''
offset = __mem_to_opcode_arm(*(u32 *)loc);
offset = (offset & 0x00ffffff) << 2;
if (offset & 0x02000000)
offset -= 0x04000000;
offset += sym->st_value - loc;
'''

## 문자 집합과 인코딩

0과 1로 문자를 표현하는 방법인 **문자 집합, 인토딩, 디코딩**에 대해 설명함.

#### 문자 집합
- 컴퓨터가 인식하고 표현할 수 있는 문자의 모음을 **문자 집합**이라고 한다.
- 컴퓨터는 문자 집합에 속해있는 문자를 이해할 수 있고, 문자 집합에 속해 있지 않은 문자는 이해할 수 없음.
    - 예를 들어, {a, b, c, d, e}인 경우 컴퓨터는 이 다섯개의 문자는 이해할 수 있고, f나 g같은 문자는 이해하지 못함.
 
### 문자 인코딩&문자 디코딩
- 문자를 0과 1로 변환해야 비로소 컴퓨터가 이해를 할 수 있음.
- 이 변환 과정을 **문자 인코딩**이라고 하고 다양한 인코딩 방법이 있을 수 있음.
- 인코딩의 반대 과정, 즉 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정은 **문자 디코딩**이라고 한다.

# 아스키 코드



![image](https://github.com/Choi-Suhyeon/IoT_Project/assets/120535813/61ce84a1-7c3e-4b6d-baba-eaa73b0e4531)

