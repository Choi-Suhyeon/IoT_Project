<link rel="stylesheet" href="../style/style.css">

#  02. DATA


## 0과 1을 숫자를 표현하는 방법
- 컴퓨터는 0과 1로 모든 정보를 표현하고, 0과 1로 표현된 정보만을 이해할 수 있음. 
- 컴퓨터가 이해하는 가장 작은 정보단위를 비트(bit)라고 한다.


### 정보 단위
- n비트는 0과 1을 2^n가지로 표현을 할 수 있다.
- 웹브라우저는, 워드 프로세서와 같은 모든 프로그램은 수십만, 수백만 개 이상의 0과 1로 이루어져 있음.
- 표현의 편의를 위해 비트보다 큰 단위를 사용하기로 함.
- 바이트, 킬로바이트, 메가바이트, 기가바이트, 테라바이트 등이 있음.

아래는 컴퓨터의 데이터 단위

|바이트|1byte|8bit|
|:---:|:---:|:---:|
|킬로바이트|1KiloByte|1000byte|
|메가바이트|1MegaByte|1000KB|
|기가바이트|1GigaByte|1000MB|
|테라바이트|1TeraByte|1000GB|

**예시** 바이트를 제외한 KB, MB, GB, 그 이상의 단위들은 모두 이전 단위를 1000개로 묶어 표현함. 1024개로 묶을 경우는 KiB, MiB와 같은 단위임.

### 워드(Word)
- 중요한 정보 단위 중 워드라는 단위도 있음.
- 워드(word)란 CPU가 한번에 처리할 수 있는 데이터의 크기를 의미한다.
- CPU가 한 번에 16bit를 처리할 수 있다면 1워드는 16bit가 되는 것이다.
- 이렇게 정의된 워드의 절반 크기를 **하프 워드(harf word)**, 1배의 크기를 **폴 워드(full word)**, 2배의 크기를 **더블 워드(double word)**라고 부름.

**예시**: 가령 인텔의 x86 CPU는 32비트 워드 CPU이며, x64 CPU는 64비트 워드 CPU가 된다.


## 이진법
- 수학에서 0과 1만으로 모든 숫자를 표현하는 방법을 **이진법**이라고 한다.
- 숫자가 1을 넘어가는 시점에 자리 올림을 하면 됨.
  - 이는 우리가 9로 넘어가는 시점에 자리 올림을 하는 **십진법**의 방식을 생각하면 됨.

|십진수|이진수|
|:---:|:---:|
|1|1|
|2|'1'0|
|3|11|
|4|'1'00|
|5|101|
|6|1'1'0|
|7|111|

이진법으로 표현한 수를 **이진수**, 십진법으로 표현한 수를 **십진수**라고 표현함. 0과 1밖에 모르는 컴퓨터에 어떤 숫자를 알려 주려면 십진수가 아닌 이진수로 알려주어야 함.

**주의** 
- 숫자만 볼때, 우리는 이것이 십진수인지 이진수인지 알 수 없음.
- 그러므로, 우리는 이런 혼동을 예방하기 위해 이진수 끝에 아래 첨자인 (2)를 붙이거나 이진수 앞에 0b를 붙인다.

### 이진수의 음수 표현
- 이진수의 음수 표현은 십진수의 음수 표현 방식처럼 앞에 마이너스 부호를 붙일 경우 컴퓨터가 이를 인식하지 못한다.
- 0과 1만으로 음수를 표현하는 방법 중 가장 널리 사용되는 방법은 **2의 보수**를 구해 이 값을 음수를 간주하는 방법임.

  **2의 보수란?**
  - 2의 보수는 **어떤 수를 그보다 큰 2^n에서 뺀 값**을 의미한다.
  - 쉽게 이해를 하자면 **모즌 0과 1을 뒤집고, 거기에 1을 더한 값**으로 이해하면 됨
      - 예를 들어, 11(2)을 뒤집을 경우 00(2)가 되고, 거기에 1을 더한 값은 01(2)라고 보면 됨. 즉, 11(2)의 2의 보수(음수표현)는 01(2)이 되는 것이다.
   

  -1011(2)을 표현하기 위한 2의 보수의 경우 모든 수를 뒤집은 0100(2)에 1을 더하면 0101(2)가 되는데, 이 0101(2)이 -1011(2)의 의미가 된다.
  그런데, 이런 의문이 생긴다. -1011(2)를 표현하기 위한 음수로서의 0101(2)과 십진수 5를 표현하기 위한 양수로서의 0101(2)은 똑같이 생겼는데, 이진수만 보고 양수인지 음수인지를 컴퓨터가 구분할 수 있는가?
  -> 실제로 이진수만 봐서는 음수인지, 양수인지의 구분이 힘들. 그래서 컴퓨터 내부에서 어떤 수를 다룰 때에는 이 수가 양수인지 음수인지를 구분하기 위해 **플래그(flag)**를 사용한다. 쉽게 말해 부가 정보이다.

  **간단 지식**
  이진수의 음수를 표현하기 위해 2의 보수를 취하는 방식은 아직까지도 가장 널리 사용이 되는 방식이지만, 완벽한 방식은 아님.
  2의 보수 방식엔 한계가 있다. 예를 들어, 8을 이진수로 표현하면 1000(2)이다. -1000(2)를 표현하기 위해선 모든 수를 뒤집고, 0111(2)이고, 1을 더하면 1000(2)가 된다. 즉, 8을 음수로 표현한 값이 자기 자신이 되어버리기 때문에 본질적으로 문제를 해결하기 어렵다. 즉, n비트로는 -2^n과 2^n이라는 수를 동시에 표현할 수 없다.


## 십육진법
- 이진법을 이용해 모든 숫자를 표현할 수 있지만 이진법은 0과 1만으로 모든 숫자를 표현하다 보니 숫자의 길이가 너무 길어진다는 단점이 있었음.
- 그래서 데이터를 표현할 때 이진법 이외에 십육진법도 자주 사용함.
- 십육진법은 **수가 15를 넘어가는 시점에 자리 올림을 하는 숫자 표현 방식**임.
- 그리고 십진수 10, 11, 12, 13, 14, 15를 십육진법 체계에서는 각각 A, B, C, D, E, F로 표기함.

|십진수|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|...|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|십육진수|0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F|10|11|...|

십육진수는 이진수와 마찬가지로 숫자 뒤에 아래점자인 (16)을 붙이거나 숫자 앞에 0X를 붙여 구분함. 전자는 수학적 표기 방식이고, 후자는 코드상 표기 방식이었다. 
십육진법을 사용하는 주된 이유 중 하나는 이진수를 십육진수로, 십육진수를 이진수로 변환하기 쉬움.


### 십육진수를 이진수로 변환

- 십육진수는 한 글자당 열여섯 종류 (0~9), (A~F)의 숫자를 표현할 수 있다. 그러므로 비트가 필요할 경우 4비트가 필요함. 2^4 = 16이기 때문.
- 십육진수를 이진수로 변환하는 간편한 방법 중 하나는 십육진수 한글자를 4비트의 이진수로 간주하는 것.
  - 1A2B(16)를 이진수로 표현할 경우 1(16), A(16), 2(16), B(16)를 이진수로 표현하면 0001(2), 1010(2), 0010(2), 1011(2)이고, 해당 숫자들을 하나로 이어붙인 값인001101000101011(2)이 1A2B(16)를 이진수로 표현한 값임.
  - 반대로 이진수를 십육진수로 변환할 때에는 이진수 숫자를 네 개씩 끊고, 끊어 준 네개의 숫자를 하나의 십육진수로 변환한 뒤 그대로 이어붙이면 된다.
  - 이진수를 십진수로 변환할 때는 이렇게 간단하지 않으므로 이진수를 십육진수로 묶어 표현함.
 
**코드에서 십육진수를 직접 넣는 사례**

```C
offset = __mem_to_opcode_arm(*(u32 *)loc);
offset = (offset & 0x00ffffff) << 2;
if (offset & 0x02000000)
offset -= 0x04000000;
offset += sym->st_value - loc;
```

## 문자 집합과 인코딩

0과 1로 문자를 표현하는 방법인 **문자 집합, 인토딩, 디코딩**에 대해 설명함.

#### 문자 집합
- 컴퓨터가 인식하고 표현할 수 있는 문자의 모음을 **문자 집합**이라고 한다.
- 컴퓨터는 문자 집합에 속해있는 문자를 이해할 수 있고, 문자 집합에 속해 있지 않은 문자는 이해할 수 없음.
    - 예를 들어, {a, b, c, d, e}인 경우 컴퓨터는 이 다섯개의 문자는 이해할 수 있고, f나 g같은 문자는 이해하지 못함.
 
### 문자 인코딩 & 문자 디코딩
- 문자를 0과 1로 변환해야 비로소 컴퓨터가 이해를 할 수 있음.
- 이 변환 과정을 **문자 인코딩**이라고 하고 다양한 인코딩 방법이 있을 수 있음.
- 인코딩의 반대 과정, 즉 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정은 **문자 디코딩**이라고 한다.

# 아스키 코드
- 아스키는 초장기 문자 집합 중 하나로, 영어 알파벳과 아라비아 숫자, 일부 특수 문자들을 표현.
- 아스키 문자 집합에 속한 문자들은 각각 7비트로 표현되는데, 총 128(2^7)개의 문자를 표현할 수 있습니다.

밑에는 아스키 코드표입니다.

![image](https://github.com/Choi-Suhyeon/IoT_Project/assets/120535813/61ce84a1-7c3e-4b6d-baba-eaa73b0e4531)

-> 이렇듯, 아스키 문자들은 하나의 고요한 수에 문자들을 일대일로 대응함. 아스키 문자에 대응된 도유한 수를 **아스키 코드**라고 한다. 우리는 아크시 코드를 이진수로 표현함으로써 아스키 문자를 0과 1로 표현할 수 있음. 반대로, 글자에 부여된 고유한 값을 코드 포인트라고 한다.

## EUC-KR
- 아스키 코드는 매우 간단하게 인코딩이 되지만, 한글, 아스키 문자 집합 외에 문자, 특수문자 등을 표현할 수 없음.
- 그래서 한국을 포함한 영어원 외의 나라들은 자신들의 언어를 0과 1로 표현할 수 있는 고유한 문자 집합과 인코딩 방식이 필요하다 생각.
- 이런 이유로 등장한 것이 바로 EUC-KR임.

- 한글 인코딩의 이해를 위해선 한글의 특수성을 알아야 함.
- 한글은 각 음절 하나하나가 초성, 중성, 종성의 조합으로 이루어져 있음.
- 한글 인코딩에는 **완성형** 인코딩과 **조합형** 인코딩이 존재함.
- 초성, 중성, 종성이 모두 결합된 한글 단어에 2바이트 크기의 코드를 부여.

**완성형 인코딩**:
- 초성, 중성, 종성의 조합으로 이루어진 완성된 하나의 글자에 고유한 코드를 부여하는 인코딩 방식.
  - 예를 들어 '가'는 1, '나'는 2, '다'는 3과 같은 이진수를 부여.
 
**조합형 인코딩**:
- 초성을 위한 비트열, 중성을 위한 비트열, 종성을 위한 비트열을 할당하여 그것들의 조합으로 하나의 글자 코드를 완성하는 인코딩 방식.
  - 예를 들어 'ㄱ'에 1을, 'ㅏ'에 2를, 받침 'ㅇ'에는 3과 같은 수를 부여.


한글 자 하나에 2바이트의 코드가 부여가 되므로 총 16비트가 필요함. 
또한 16비트는 네 자리 십육진수로 표현할 수 있음. 
즉, EUC-KR로 인코딩된 한글은 네 자리 십육진수로 표현할 수 있음. 

### EUC-KR의 단점
- EUC-KR 인코딩 방식으로 2,350개 정도의 한글 단어를 표현할 수 있음.
- 아스키 코드보다는 많이 표현할 수 있으나, 이는 모든 한글 조합을 표현할 수 있을 정도는 아님.
    - 이러한 문제를 해결하기 위해 CP949가 나왔지만, 이마저도 한글 전체를 표현하지 못함.
 

## 유니코드와 UTF-8
- 언어별로 인코딩을 나라마다 해야 한다면 다국어를 지원하는 프로그램을 만들 때 인코딩을 모두 알아야 한다는 번거로움이 있음.
- 그래서 모든 나라의 언어의 문자 집합과 인코딩 방식을 통일하고자 탄생한 것이 **유니코드**임.
- 유니코드는 EUC-KR보다 훨씬 다양한 한글을 포함하며 대부분 나라의 문자, 특수문자 등을 코드로 표현할 수 있음.

- 아스키 코드나 EUC-KR은 글자에 부여된 값을 그대로 인코딩하지만, 유니코드는 **글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고 이 값을 다양한 방법으로 인코딩**한다.
- 이런 인코딩 방법에는 크게 UTF-8, UTF-16, UTF-32 등이 있음.

### UTF-8
- UTF-8은 통상 1바이트부터 4바이트까지 인코딩 결과를 만들어 냄. 다시 말해 UTF-8로 인코딩한 값의 결과는 1바이트가 될 수도, 4바이트가 될 수도 있다.
- UTF-8로 인코딩한 결과가 몇 바이트가 될지는 유니코드 문자에 부여된 값의 범위에 따라 결정.

UTF-8로 변환된 유니코드 문자 그룹과 개수

![image](https://github.com/Choi-Suhyeon/IoT_Project/assets/120535813/b0507e59-050e-4499-a185-bcc23faf8c26)

규칙이 실제로 적용된 값의 표.
![image](https://github.com/Choi-Suhyeon/IoT_Project/assets/120535813/786a19ca-7ff6-477c-9ecf-ea7d0358dfcc)


UTF-8의 예시
![image](https://github.com/Choi-Suhyeon/IoT_Project/assets/120535813/eb26f460-da04-4ef3-9f29-6bd79305cf03)

- 예시 1: 문자 A는 아스키 문자이며 유니코드 값은 65로, 이는 16진수 0x41(0100 0001)인데, 7비트 이내로 표현 가능하므로 UTF-8로도 0x41로 표현된다.
- 예시 2: 문자 π는 유니코드 값이 7비트를 벗어난다. 그러나 11비트 이내에 표현이 가능한 비교적 앞쪽에 위치한 문자며, 따라서 그림과 같이 2바이트에 표현이 가능 하다.
- 예시 3: 문자 한은 한글 문자로 16비트를 모두 사용한다. 마지막 16비트가 1이며 따라서 이를 표현하기 위해서는 그림과 같이 3바이트를 사용해야 한다. 참고로 유니코드에는 완성형 한글 11,172자뿐만 아니라 조합형 자모가 모두 포함되어 있으며, 이처럼 한글의 UTF-8 인코딩 값은 모두 각 문자당 3바이트를 차지한다.
