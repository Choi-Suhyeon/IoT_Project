<link rel="stylesheet" type="text/css" href="/style/style.css">

# 02.01. Data [Additional]

## 다룰 함수와 연산자
|Symbol|Type|Meaning|
|:---|:---|:---|
|$B2T_w$|Function|Binary to 2's complement|
|$B2U_w$|Function|Binary to unsigned|
|$U2B_w$|Function|Unsigned to binary|
|$U2T_w$|Function|Unsigned to 2's complement|
|$T2B_w$|Function|2's complement to binary|
|$T2U_w$|Function|2's complement to unsigned|
|$+^t_w$|Operation|2's complement addition|
|$+^u_w$|Operation|Unsigned addition|
|$\times^t_w$|Operation|2's complement multiplication|
|$\times^u_w$|Operation|Unsigned multiplication|
|$-^t_w$|Operation|2's complement negation|
|$-^u_w$|Operation|Unsigned negation|

## 정수
이 문서를 정리한 사람이 크기와 해석(몇 바이트를 읽어서 뭐로 해석할지)으로 모든 것을 설명하려는 것 같긴 한데(~~미쳐있는 것 같긴 한데~~),,, 솔직히 여기선 중요함. 이걸 모르면 아래 내용을 논할 수가 없음.

**비트 벡터($\vec{x}$)** : $w$ bit 크기의 비트열은 다음과 같음. $[x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$. $x_i$는 $0$ 또는 $1$을 가짐. $1$을 가지면 $2^i$값이 수 계산에 포함되어야 함을 의미. 

### 비부호형 인코딩
벡터 $\vec{x} = [x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$에 대해,

$B2U_w(\vec{x}) \doteq \sum_{i=0}^{w-1}2^ix_i$

**의미** : 모든 비트를 자릿수 맞춰서 더함.

$UMax_w \doteq \sum_{i=0}^{w-1}2^i = 2^w - 1 = [111\cdots 1] =$ `0xFF...F` (크기 : $w\over8$ byte)<br>
&emsp; $UMax_w \doteq \sum_{i=0}^{w-1}2^i$ <br>
&emsp;&emsp; $= 2^0 + 2^1 + 2^2 + \cdots + 2^{w-1}$ (등비수열 : $a_n = 1 \cdot 2^{n-1}$)<br>
&emsp;&emsp; $= {1(2^w - 1) \over 2 - 1}$ (등비수열의 합 : ${a(r^n - 1) \over r - 1}$)<br>
&emsp;&emsp; $= 2^w - 1$

$UMin_w \doteq 0 = [000\cdots 0] =$ `0x00...0` (크기 : $w\over8$ byte)

**성질** :  $B2U_w$는 $B2U_w: \{0, 1\}^w \rightarrow \{0, 1, 2, \cdots, UMax_w\}$와 같은 맵핑으로 정의될 수 있으며, 일대일 대응을 이룸. 그렇기 때문에 역함수를 구할 수 있으며, 그 역함수를 $U2B_w$로 표시.

### 2의 보수 인코딩
벡터 $\vec{x} = [x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$에 대해,

$B2T_w(\vec{x}) \doteq -2^{w-1}x_{w-1} + \sum_{i=0}^{w-2}2^ix_i$

**의미** : MSB(부호 비트)를 제외한 모든 비트를 자릿수 맞춰 더하고 부호 비트 계산한 것을 빼줌.
- MSB가 부호 비트인 이유 : MSB가 0이면 $-2^{w-1}x_{w-1} = 0$이기 때문에 수식의 결과가 비부호형 인코딩과 다를 것이 없음. 하지만 MSB가 1이면 $-2^{w-1}x_{w-1} $이 $0$ 이 아닌 값으로 연산이 되기 때문에 음수가 나올 수 밖에 없음(왜냐하면, 자릿수가 가장 큰 비트는 그것보다 작은 모든 비트를 더한 것보다 1 큼).

$TMax_w \doteq \sum_{i=0}^{w-2}2^i = 2^{w-1}-1 = [011\cdots 1] =$ `0x7FF...F` (부호비트를 0으로 설정하고, 나머지를 1로 설정)
<br>&emsp; $TMax_w \doteq \sum_{i=0}^{w-2}2^i$ ($UMax_w$ 구할 때와 같음)
<br>&emsp;&emsp; $= 2^0 + 2^1 + 2^2 + \cdots + 2^{w-2}$
<br>&emsp;&emsp; $= {1(2^{w-1} - 1) \over 2 - 1}$
<br>&emsp;&emsp; $= 2^{w-1}-1$

$TMin_w \doteq -2^{w-1} = [100 \cdots 0] =$ `0x800...0` (부호비트를 1로 설정하고 나머지를 0으로 설정)

**성질** :  
- $B2T_w$는 $B2T_w: \{0, 1\}^w \rightarrow \{TMin_w, TMin_w + 1, TMin_w + 2, \cdots, TMax_w\}$와 같은 맵핑으로 정의될 수 있으며, 일대일 대응을 이룸. 그렇기 때문에 역함수를 구할 수 있으며, 그 역함수를 $U2B_w$로 표시.
- $\left\vert TMin\right\vert = TMax + 1$ : $TMin$에 대응되는 양수 값이 없음.
- $UMax = 2TMax + 1$
    <br>&emsp;&emsp; $2TMax_w+1$
    <br>&emsp;&emsp;&emsp;&emsp; $= 2(2^{w-1}-1) + 1$
    <br>&emsp;&emsp;&emsp;&emsp; $= 2^w-1$
    <br>&emsp;&emsp;&emsp;&emsp; $=UMax_w$
- 참고로 -1은 $w$크기의 비트벡터가 있을 때 모든 원소가 1인 비트 벡터. 부호 비트가 1인 상황에서 더할 수 있는 가장 큰 수를 더해줘야 0과 가까워짐. -2는 -1에서보다 하나 덜 더해주면 됨.
    - `-1 == 0xFFFF` (2byte)
    - `-2 == 0xFFFE` (2byte)

**특정 비트 벡터에 대한 2의 보수인 비트 벡터 구하기** : 특정 비트 벡터 또한 2의 보수로 해석함. 크기가 $w$인 비트 벡터가 있다고 가정.

보수 : 보충해주는 수. 어떤 수 $C$가 되기 위해 $A$라는 수가 필요로 하는 수. $A + B = C$에서 $C$에 대한 $A$의 보수는 $B$.

1. 의미 그대로 구함 : $2^w - \vec{x}$
1. 비트 반전 + 1 : `~x + 1`<br>
&emsp; `~x`<br>
&emsp;&emsp; $= [111\cdots 1] - \vec x$ (2진수의 자릿수는 $w$)<br>
&emsp;&emsp; $= UMax_w - \vec x$<br>
&emsp;&emsp; $= 2^w - 1 - \vec x$<br>
&emsp; `~x + 1`<br>
&emsp;&emsp; $= 2^w - 1 - \vec x + 1$<br>
&emsp;&emsp; $= 2^w - \vec x$

### 비부호형과 부호형 간의 형변환
비부호형과 부호형을 결정하는 것은 해석. <u>비트가 달라지는 것이 아님</u>. 따라서 가장 쉬운 방법은 십진수랑 비트 벡터 크기가 주어지면 비트열로 써놓고 해석을 바꾸면 됨. 아래도 그거 정리한 것.

**2의 보수에서 비부호형으로 변환** : 2's complement 🠖 $T2B$ 🠖 $B2U$ 🠖 Unsigned

$`T2U_w(x) = \begin{cases}x + 2^w,& x < 0 \\ x,& x \ge 0 \end{cases}`$

2의 보수의 인코딩 방식을 보면 나머지는 더하고 최상위 비트를 빼줌. 하지만, 비부호형은 최상위 비트 또한 더해줌. 그럼 2의 보수로 계산이 완료된 상태에서 비트에 대한 해석을 똑같이 맞춰주려면 최상위 비트 계산 결과(양수 : 0, 음수 : $2^{w-1}$)를 두 번 더해야 함. 즉, 최상위 비트 계산 결과에 2배를 더해줘야 하는데 음수의 경우 그 값이 $2^1\cdot 2^{w-1} = 2^{1 + w - 1} = 2^w$. 그래서 $2^w$을 더함. 

**외우면 편한 애들** : 2의 보수 🠖 비부호형. 역도 당연히 성립함.
- $0$ 🠖 $0$
- $TMax$ 🠖 $TMax$
- $-1$ 🠖 $UMax$
- $-2$ 🠖 $UMax - 1$
- $TMin$ 🠖 $TMax + 1$

**비부호형에서 2의 보수로 변환** : Unsigned 🠖 $U2B$ 🠖 $B2T$ 🠖 2's complement

$`U2T_w(u) = \begin{cases} u,& u \le TMax_w \\ u - 2^w,& u > TMax_w \end{cases}`$

위와 논리는 같음. $TMax_w$보다 크지 않다는 것은 MSB가 0이라는 뜻 ($TMax_w$가 MSB가 0인 수 중에 가장 큰 수). 그럼 $w-2$ 이하는 해석이 달라지지 않음. MSB가 1이면 해석이 달라지는데, 비부호 인코딩에서는 MSB 계산 결과를 더했음. 하지만 2의 보수에서는 빼줘야 함. 이미 비트 벡터를 비부호로 해석한 상태에서 2의 보수로 해석을 변경하려면 빼줘야될 애를 더했으니 2번 빼줘야 함. 그래서 $2^w$이 됨. 

### 비트 벡터 확장
확장에서 중요한 것은 비트를 확장한 이후에도 값이 달라지지 않는 것.

**비부호형 비트 벡터 확장** : MSB가 있는 쪽을 0으로 확장.
- 어차피 비부호형은 모든 비트들을 더하기 때문에 값이 달라지지 않으려면 간단하게 확장된 더 높은 자릿수들을 0으로 채우면 됨.

**2의 보수 비트 벡터 확장** : MSB(부호 비트)가 있는 쪽을 부호 비트로 확장.
- 중요한 것은 부호가 달라지면 안 된다는 것이므로, 확장되더라도 부호 비트는 같아야 됨. 그러면, 나머지는 더하고 부호 비트를 빼는 식으로 인코딩을 하는데 비트가 부호 비트 쪽으로 확장됐다는 얘기는 음수면 마지막에 빼주는 부호 비트의 계산 값이 커졌다는 얘기. 부호 비트의 계산 값이 커졌을 때도 값이 달라지지 않으려면 부호 비트를 제외한 추가된 비트들에도 1을 넣어서 전부 더해, 최종 결과 값이 달라지지 않게 만들면 됨. 그 방법이 부호비트가 1이면 확장된 곳도 1로 채우고, 부호비트가 0이면 확장된 곳도 0으로 채우는 것.

### 비트 벡터 절삭
비트를 잘라내는 것으로 일종의 overflow. 당연히 2의 보수로 해석할 경우 잘려진 비트를 다시 해석해줘야 하며 부호도 변경될 수 있음.

비트 벡터 $\vec x = [x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$를 $k$비트 수로 절삭할 때 상위 $w-k$비트를 제거해서 $\vec x' = [x_{k-1}, x_{k-2}, x_{k-3}, \cdots, x_0]$ 얻을 수 있음. 그 결과는 아래와 같음.

**비부호형 비트 벡터 확장** : $x' = x \bmod 2^k$

**2의 보수 비트 벡터 확장** : $x' = U2T_k(x \bmod 2^k)$ (추가적으로, 비트 벡터를 재해석만 해주는 것 뿐)

약간의 직관이 필요한 데, 쉽게 생각해서 168에서 일의 자리만 남기고 싶으면 8인 것은 당연하지만 168을 10($10^1$)으로 나눈 나머지로 구해도 됨. 마찬가지로 비트 벡터의 크기가 6이었는데 3으로 줄이고 싶다면 (즉, 세 번째 자리까지만 남기고 싶다면), $2^3$으로 나눈 나머지.

## 정수 연산

**주의** : 비트 수준 관점에서 봤을 때, 2의 보수 덧셈과 비부호형 덧셈은 완벽히 같은 결과를 가짐. 머신 코드로도 둘을 구별하여 연산하지 않음. 이는 2의 보수 곱셈과 비부호형 곱셈에서도 마찬가지. 즉, <u>연산은 같고</u>, 연산 결과에 대한 <u>해석만 달라짐</u>.

### 비부호형 덧셈
음 아닌 정수 $x, y\ (0 \le x, y < 2^w)$ 를 고려했을 때, 이들 합의 가능한 범위는 $0 \le x + y \le 2^{w+1} - 2$ . 즉, 필요한 비트는 $w + 1$ 비트로, $w$ 비트로 표현할 수 있는 범위를 벗어남. 
- $x, y$ 모두 최대 $2^w - 1$이 될 수 있기 때문에 $x + y$의 최대값은 $2(2^w - 1) = 2^{w + 1} - 2$ 가 됨.

Lisp이나 Python처럼 임의 크기의 산술 연산을 지원하는 언어도 있지만, 그렇지 않은 언어도 많음.

**비부호형 덧셈** :

$x, y\ (0 \le x, y < 2^w)$ 에 대해,

$`x +^u_w y = \begin{cases}x + y,& x + y < 2^w\\ x+y-2^w,& 2^w \le x + y < 2^{w+1}\end{cases}`$

연산 후 연산 결과가 $w$ 비트가 되도록 절삭함. 이는 위에서도 설명했듯, $2^w$ 나눈 나머지와 결과가 같음. 모듈러 연산으로 나머지를 구할 때 `a % b`, `a`에서 `b`를 연속적으로 빼거나 더해서 `0`과 `b`사이의 숫자가 되도록 만들기도 하는데, 더한 결과가 $2^{w+1}$ 보다 작기 때문에 한 번만 빼주면 됨.

아니면, 연산 후 $w + 1$ 번째 비트가 절삭되는데 결과가 범위를 벗어난다는 것은 $w + 1$ 번째 비트가 1로 세팅되었다는 것과 같아 $w + 1$ 번째 비트의 값 $2^w$을 빼준다고 봐도 무방함.

위 공식에서 두 번째 경우의 상황을 overflow라고 표현.

**비부호형 덧셈에서 overflow 검출** :

$x, y\ (0 \le x, y \le UMax_w)$ 에 대해, $s \doteq x +^u_w y$ 라 하자.

$s < x$ 또는 $s < y$ 면, $s$는 overflow됐으며 역 또한 성립.

만약 overflow가 됐다면, $s = x + y - 2^w$. 여기서 $y < 2^w,\ y - 2^w < 0$<br>따라서, $s = x + (y - 2^w) < x$<br>위와 같은 방법으로 $s < y$

**비부호형 역원** :

모듈러 덧셈은 가환군(또는 아벨군)을 형성. 
 - 군(Group) : 집합 내에서 특정 연산에 대해
    1. 결합 법칙이 성립해야 함.
    1. 항등원이 존재해야 함.
    1. 역원이 존재해야 함.
- 가환군(Commutative Group) : 위 조건에 교환 법칙까지 성립해야 함.

즉, 교환 법칙과 결합 법칙이 성립하고, 항등원 0을 가지며, 덧셈의 역을 가짐.

모든 $x$에 대해, $-^u_wx +^u_w x = 0$을 만족하는 $-^u_wx$이 존재.

$`-^u_wx = \begin{cases}x,& x = 0\\ 2^w - x,& x > 0\end{cases}`$

$x > 0$ 상황에서, $2^w - x$는 $0 < 2^w - x < 2^w$. 그리고, $(x + 2^w - x) \bmod 2^w = 2^w \bmod 2^w = 0$ 이므로, $-^u_wx$ 는 연산 $+^u_w$ 에 대한, $x$의 역.

### 2의 보수 덧셈
정수 $x, y\ (-2^{w-1} \le x, y \le 2^{w-1}-1)$ 를 고려했을 때, 이들 합의 가능한 범위는 $-2^w \le x + y \le 2^w - 2$ . 즉, 필요한 비트는 $w + 1$ 비트로, $w$ 비트로 표현할 수 있는 범위를 벗어남. 따라서 $w$ bit에 맞게 남은 상위 비트는 절삭해야 함.

**2의 보수 덧셈** :

$x, y\ (-2^{w-1} \le x, y \le 2^{w-1}-1)$ 에 대해,

$`x +^t_w y = \begin{cases}x + y - 2^w,& 2^{w-1} \le x + y\\ x+y,& -2^{w-1} \le x + y < 2^{w-1}\\ x+y+2^w,& x+y<-2^{w-1}\end{cases}`$

위 법칙에서 첫 번째 경우를 양의 오버플로우(positive overflow), 세 번째 경우를 음의 오버플로우(negative overflow)라고 함.
- 양의 오버플로우 : $x+y$ 의 결과가 $TMax_w$ 보다 클 때 발생.
- 음의 오버플로우 : $x+y$ 의 결과가 $TMin_w$ 보다 작을 때 발생.

비트 수준에서는 비부호형 덧셈과 2의 보수 덧셈이 차이가 없다는 점을 이용해 아래와 같이 표현 가능.

$x+^t_wy$
<br>&emsp;&emsp; $= U2T_w(T2U_w(x) +^u_w T2U_w(y))$
<br>&emsp;&emsp; $= U2T_w((x + 2^wx_{w-1}+y+2^wy_{w-1})  \bmod 2^w)$
<br>&emsp;&emsp; $= U2T_w((x + y) \bmod 2^w)\ (\because 2^wx_{w-1}\equiv0\pmod{2^w}, 2^wy_{w-1}\equiv0\pmod{2^w})$

- $T2U_w(x)$ 를 부호비트를 살려 표현하면 $x + 2^wx_{w-1}$ 과 같음. 음수라 부호비트가 1이면 $2^w$ 을 더할거고, 그렇지 않으면 0을 더하는거라 위에서 본 공식과 같음.

2의 보수 덧셈에서 덧셈 결과는 크게 4가지 범주로 나눌 수 있음.
1. 음수이면서, $TMin_w$보다 작은 경우.
1. 음수이면서, $TMin_w$보다 작지 않은 경우.
1. 양수이면서, $TMax_w$보다 크지 않은 경우.
1. 양수이면서, $TMax_w$보다 큰 경우.

각 4가지 범주를 바로 위 공식에 넣어 2의 보수의 덧셈이 3가지 경우에 대해 왜 저런 식을 갖는지 차례로 알아볼 예정.
1. 음수이면서, $TMin_w$보다 작은 경우.
    <br>&emsp;&emsp; $-2^w\le x+y<-2^{w-1}$
    <br>&emsp;&emsp; $0\le x+y+2^w < 2^{w-1}$
    <br>&emsp;&emsp; $\therefore x+^t_wy = x + y + 2^w,\ -2^w\le x + y < -2^{w-1}$
1. 음수이면서, $TMin_w$보다 작지 않은 경우.
    <br>&emsp;&emsp; $-2^{w-1}\le x+y<0$
    <br>&emsp;&emsp; $2^{w-1}\le x+y+2^w < 2^w$
    <br>&emsp;&emsp; $\therefore x+^t_wy = x+y+2^w-2^w\ (\because TMax_w = 2^{w-1}-1 < x+y+2^w)$
    <br>&emsp;&emsp; $\therefore x+^t_wy = x + y,\ -2^{w-1}\le x + y < 0$
1. 양수이면서, $TMax_w$보다 크지 않은 경우.
    <br>&emsp;&emsp; $0\le x+y<2^{w-1}$
    <br>&emsp;&emsp; $\therefore x+^t_wy = x+y,\ 0\le x+y < 2^{w-1}$
1. 양수이면서, $TMax_w$보다 큰 경우.
    <br>&emsp;&emsp; $2^{w-1}\le x+y<2^w$
    <br>&emsp;&emsp; $\therefore x+^t_wy = x+y-2^w,\ 2^{w-1}\le x+y < 2^w\ (\because TMax_w = 2^{w-1}-1 < x+y)$

**2의 보수 덧셈에서 overflow 검출** : 비부호형 덧셈에서 overflow를 검출하는 것보다 쉬움. 양수와 양수를 더했는데 음수가 나오거나 음수와 음수를 더했는데 양수가 나오면 overflow가 발생했다고 판단. 역 또한 성립.

**2의 보수 역원** : 
$`-^t_wx = \begin{cases}TMin_w,& x = TMin_w\\ -x,& x > TMin_w\end{cases}`$

$TMin_w + TMin_w = -2^{w-1}+-2^{w-1} = -2^{w}$ 연산 결과가 $-2^{w-1}$보다 작으므로, 음의 overflow.
$TMin_w+^t_wTMin_w = -2^w+2^w = 0$. 따라서, $TMin_w$의 항등원은 $TMin_w$.

### 비부호형 곱셈
비부호형 곱셈은 비부호형 덧셈과 마찬가지로 연산결과를 $2^w$으로 모듈로 연산을 하면 됨.

$x\times^u_wy = (xy) \bmod 2^w$

### 2의 보수 곱셈
$x\times^t_wy = U2T_w((xy) \bmod 2^w)$

곱셈 또한 마찬가지로 비트 수준에서는 비부호형과 2의 보수가 차이가 없음. 이를 식으로 표현하면 아래와 같음.

아래에서 $x\times^t_wy = U2T_w((xy) \bmod 2^w)$ 을 이용해 $T2B_w(x\times^t_wy) = U2B_w(x'\times^u_wy')$ 을 유도할 계획이기 때문에 $(xy) \bmod 2^w$ 와 $(x'y') \bmod 2^w$ 의 관계식이 필요함. 이를 '비부호형 곱셈과 2의 보수 곱셈은 비트 수준에서는 결과의 차이가 없음'으로 만들 생각.

$T2B_w(x\times^t_wy) = U2B_w(x'\times^u_wy')$ 
<br>&emsp;&emsp; $x' = T2U_w(x) = x + 2^wx_{w-1},\ y' = T2U_w(y) = y + 2^wy_{w-1}$
<br>&emsp;&emsp; $(x'y') \bmod 2^w$
<br>&emsp;&emsp;&emsp;&emsp; $= \{(x+2^wx_{w-1})\cdot(y+2^wy_{w-1})\}\bmod2^w$
<br>&emsp;&emsp;&emsp;&emsp; $= \{xy+2^w(x_{w-1}y + xy_{w-1})+2^{2w}x_{w-1}y_{w-1}\} \bmod 2^w$
<br>&emsp;&emsp;&emsp;&emsp; $= (xy) \bmod 2^w$
<br>&emsp;&emsp; $x\times^t_wy = U2T_w((xy) \bmod 2^w)$
<br>&emsp;&emsp; $T2U_w(x\times^t_wy) = T2U_w(U2T_w((xy) \bmod 2^w)) = (xy) \bmod 2^w$
<br>&emsp;&emsp; $T2U_w(x\times^t_wy) = (x'y') \bmod 2^w = x'\times^u_wy'\ (\because (x'y') \bmod 2^w = (xy) \bmod 2^w)$
<br>&emsp;&emsp; $U2B_w(T2U_w(x\times^t_wy)) = T2B(x\times^t_wy) = U2B(x'\times^u_wy')$

### 상수를 사용한 곱셈
덧셈, 뺄셈, 비트 연산 등은 1사이클만 필요로 하는 반면에, 정수 곱셈은 intel i7 CPU에서도 3사이클이 필요함. 따라서, 상수를 곱하는 경우, 덧셈, 뺄셈, 비트 연산을 활용해 최적화를 시도할 수 있음.

**2의 거듭제곱인 상수와의 곱셈** : 

벡터 $\vec x = [x_{w-1},x_{w-2},x_{w-3},\cdots,x_0]$ 와 임의의 $k\ (k \ge 0)$ 에 대해,

$2^kx$ 의 비트 수준 표현은 $[x_{w-1},x_{w-2},x_{w-3},\cdots,x_0,0,\cdots,0]$ 이며, LSB 측에 $k$ 개의 0을 추가한 것.

$B2U_{w+k}([x_{w-1},x_{w-2},x_{w-3},\cdots,x_0,0,\cdots,0])$
<br>&emsp;&emsp; $= \sum_{i=0}^{w-1}2^{i+k}x_i$
<br>&emsp;&emsp; $= \sum_{i=0}^{w-1}(2^k\cdot2^ix_i)$
<br>&emsp;&emsp; $= 2^k\sum_{i=0}^{w-1}2^ix_i$
<br>&emsp;&emsp; $= 2^kx$

고정길이 워드에 대해서는 상위 $k$ bit는 삭제됨.

$[x_{w-k-1},x_{w-k-2},x_{w-k-3},\cdots,x_0,0,\cdots,0]$

이것은 고정길이 위드에 대한 곱셈에서도 성립. 즉, 특정 값을 왼쪽으로 시프트하는 것은 2의 거듭제곱을 곱하는 것과 같음.

비부호형 값을 갖는 C언어 변수 `x`, `k`에 대해, `k` $< w$ 일 때,

`x << k` $= x\times^u_w2^k$

곱셈은 상술했듯, 비트 수준에서는 비부호형인지 2의 보수인지에 따라 연산 결과가 달라지지 않음. 따라서 위 공식은 `x`가 2의 보수 값일 때도 성립.

**임의 상수와의 곱셈** :

이를 보다 일반화 해, 임의의 상수 $K$의 비트 벡터에서 MSB와 가장 가까운 1의 비트 위치를 `n`, LSB와 가장 가까운 1의 비트 위치를 `m`이라 하면, 아래 2가지 형태로 `K * x`를 표현할 수 있음 ( $0\le m < n$ ).

- `(x << n) + (x << (n - 1)) + ... + (x << m)`
- `(x << (n + 1)) - (x << m)`

여기서 주의할 점은 `n`과 `m` 사이에 0이 있는 경우 0에 대응되는 항은 빼줘야 함. 아래는 예시.

$x \times 55$를 2가지 경우로 풀이: <br>
$55 = [110111],\ n = 5,\ m = 0$
- `(x << 5) + (x << 4) + (x << 3) + (x << 2) + (x << 1) + (x << 0) - (x << 3)` : 즉, 비트가 1인 항만 더함.
- `(x << 6) - (x << 0) - (x << 3)`

### 상수를 사용한 나눗셈
곱셈은 그래도 3사이클이었지만, 나눗셈은 일반적으로 30사이클 가량이 필요함. 따라서, 최적화를 위한 명분은 충분. 왼쪽 시프트는 하나지만, 오른쪽 시프트는 논리 시프트와 산술 시프트가 결과가 다름. 각각을 비부호형 나눗셈과 2의 보수 나눗셈에 사용.

**최대 정수 함수와 최소 정수 함수** : 
- 최대 정수 함수(바닥 함수) : $\lfloor x\rfloor = \max\ \{n\in\mathbb{Z}\ |\ n \le x\}$ (x 이하의 정수 중 가장 큰 정수)
- 최소 정수 함수(천장 함수) : $\lceil x\rceil = \min\ \{n\in\mathbb{Z}\ |\ n \ge x\}$ (x 이상의 정수 중 가장 작은 정수)

정수 나눗셈은 연산 후 소수점을 버리기 때문에, `x / y`에서 
- $x \ge 0,\ y > 0$ 인 경우 : $\lfloor{x\over y}\rfloor$ (x가 음아닌 정수면 내림)
- $x < 0, y > 0$ 인 경우 : $\lceil{x\over y}\rceil$ (x가 음수면 올림)

**2의 거듭제곱인 상수로 비부호형 나눗셈** : 

비부호형 값 $x, k$ 를 갖는 C언어 변수 `x`, `k`에 대해, $k < w$ 일 때,

`x >> k` $= \lfloor{x\over2^k}\rfloor$

정수의 나눗셈이고 $x$ 가 음 아닌 정수이기 때문에 나눗셈 정리의 꼴로 만들어주면 됨.

$x$ 가 비트 벡터 $[x_{w-1},x_{w-2},x_{w-3},\cdots,x_0]$ 으로 표현된다고 하자. 또한, $x'$은 $w-k$ 길이의 비트 표현 $[x_{w-1},x_{w-2},x_{w-3},\cdots,x_k]$ 을 갖는 비부호형 숫자이고, $x''$은 $k$ 길이의 비트 표현 $[x_{k-1},x_{k-2},x_{k-3},\cdots,x_0]$ 을 갖는 비부호형 숫자라 하자.

$x = 2^kx' + x''$ 꼴로 만들어 줄 수 있으며, $x' = \lfloor{x\over2^k}\rfloor$ . 또한, $[x_{w-1},x_{w-2},x_{w-3},\cdots,x_k]$은 $[x_{w-1},x_{w-2},x_{w-3},\cdots,x_0]$을 오른쪽 논리 시프트한 결과와 같음.

**2의 거듭제곱인 상수로 2의 보수 나눗셈** : 

2의 보수의 경우, 음아닌 정수면 MSB가 0이므로, 양수와 방법이 동일함 (`x >> k`). 하지만, 음수일 때는 시프트 연산이 나눈 값에 최대 정수 함수를 씌운 결과를 돌려주기 때문에 우리가 원하던 결과와 다르고(원하던 결과는 나눈 값에 최소 정수 함수를 씌운 것), 따라서 추가적인 처리가 필요함.

2의 보수 값 $x, k$를 갖는 C언어 변수 `x`, `k`에 대해, $0 \le k < w$ 일 때,

`(x + (1 << k) - 1) >> k` $= \lceil{x\over y}\rceil$

위 C언어 코드는 성질 $\lceil{x\over y}\rceil = \lfloor{x+y-1\over y}\rfloor$ 을 이용한 코드.

$x = yq + r\ (0\le r < y)$ 로 표현 가능.
<br> $x + y - 1 = yq + r + y - 1$
<br> ${x + y - 1\over y} = {yq + r + y - 1\over y}$
<br> $\lfloor{x + y - 1\over y}\rfloor = \lfloor q + {r + y - 1\over y}\rfloor$
<br> $\lfloor{x + y - 1\over y}\rfloor = q+\lfloor{r + y - 1\over y}\rfloor$
<br> $r = 0$ 이면, $\lfloor{r + y - 1\over y}\rfloor = 0$
<br> $r > 0$ 이면, $\lfloor{r + y - 1\over y}\rfloor = 1$ ($r < y,\ r + y - 1 < 2y$ 이기 때문에, $1$ 보다 커질 수는 없음)

따라서, 나눠 떨어지면 $q$이고, 그렇지 않으면 $q + 1$이 되기 때문에, $\lceil{x\over y}\rceil$와 효과가 같음.

위는 책에서의 설명인데 저렇게 이해해도 무방하지만, 아래처럼 이해해도 됨.

가장 쉽게 생각할 수 있는 것은 계산한 결과에 $1$ 을 더하는 것. 즉, $\lfloor{x\over y}\rfloor + 1 = \lfloor{x+y\over y}\rfloor$ . 나눠 떨어지지 않으면 저 결과가 맞지만, 나눠 떨어지면 원래 나와야 되는 결과에 $1$ 을 더한 결과가 됨 ($x\in\mathbb{Z} \Rightarrow \lfloor x\rfloor = \lceil x\rceil$). 나눠 떨어지도록 만들면 안 되기 때문에 $y$ 에서 $1$을 뺀 값을 더해줌. $y>0$이기 때문에 상관 없음.

C언어 버전 :
```c
long long c = (sizeof(long long) << 3) - 1;
long long r = (x + ((x < 0) << c >> c & (1 << k) - 1)) >> k
```

Rust 버전 :
```rust
let c = i128::BITS - 1;
let r = (x + (((x < 0) as i128).rotate_right(1) >> c & (1 << k) - 1)) >> k
```

**상수를 활용한 곱셈과 나눗셈의 실효성 문제** :

Rust를 활용해 두 경우 곱셈과 나눗셈에 대해 곱셈 또는 나눗셈 연산자를 사용하는 방법과 책에서 소개한 방법을 사용하는 방법 2가지로 실험을 진행했다.

실험 결과:
- `i128` : 나눗셈의 경우 효과가 있었고(3배 정도 빨랐음) 곱셈도 1이 연속적으로 있거나 얼마 없으면(공식을 쓰기 편하면) 효과가 있었음.
- `i64` : 벌써 여기서부터 똑같거나 아니면 그냥 계산하기는 것이 속도가 더 빨랐음.

정말 큰 수를 계산하는데 계산 속도를 1ns라도 줄여야 하거나 무조건 빠를 수 밖에 없는 경우(예: 비트열에 1이 하나 뿐인 상수(2의 거듭제곱)를 곱할 때는 시프트 한 번만 하면 되므로 무조건 빠름)를 제외하고는 쓰는 것이 손해라 생각. 

정말 간단한 시프트 연산이 아니고서야 정확히 어떤 계산을 하는지 알아보기도 힘들고 코드도 길어져 코드 가독성을 상당히 떨어뜨리는데 속도가 무조건 빠르지도 않다면 굳이 쓸 필요가 없기 때문.

## 부동소수점
컴퓨터에서 부동소수점을 표현하는 방법은 여러가지가 있었지만, IEEE 표준 754가 만들어지면서 최근에는 거의 모든 컴퓨터에서 이 표준을 채택해 사용함. 그 전에 비율 이진수와 이의 문제점부터 살펴보자.

### 부동소수점에 대한 2진수 표기
**10진수 표기** :

십진수는 아래와 같은 표기를 사용함.

$d_md_{m-1}d_{m-2}\cdots d_1d_0.d_{-1}d_{-2}d_{-3}\cdots d_n$

위 표기가 나타내는 값은 아래와 같음.

$d = \sum^m_{i=-n}10^id_i$

성질은 아래와 같음.

1. 각 숫자들의 자리값은 소수점의 위치에 따라 상대적. 좌측은 10의 양(0 포함)의 거듭제곱을 자리값으로, 우측은 10의 음의 거듭제곱을 자리값으로 가짐.
1. 어떤 분수는 부동소수점으로는 소수점 이하 자리수를 늘려서 근사화할 수는 있어도 정확히 표현할 수는 없음. 즉, $x\over 2^i5^j$ 꼴로 나타낼 수 있는 수만 정확히 표현할 수 있음.

**2진수 표기** : 이것 또한 비슷한 표기와 성질을 가짐. 다만, 아래와 같은 부분은 주의해야 함.

- 2진수 표기도 $x \over 2^i$ 꼴로 나타낼 수 있는 수만 정확히 표현할 수 있음. 이로 인해, 10진수 표기로 정확히 나타낼 수 있는 수와 2진수 표기로 정확히 나타낼 수 있는 수는 차이가 있음.
- $0.111\cdots1_2$는 $1$ 바로 아래 수를 나타냄. 2진수는 1에 1을 더하면 2가 돼 자리가 하나 올라가기 때문에 비슷한 10진수 표현으로 하면 $0.999\cdots9$가 됨.

**분수 값에서 2진수 표기로의 변환** : 대분수가 주어져 있고 분모가 2의 거듭제곱이라면 ($a{b\over 2^k}$), 
1. $b$를 이진수 표기로 변경.
1. $k$만큼 소수점을 왼쪽으로 옮김.
1. $a$를 이진수 표기로 변경 해 소수점 왼쪽에 위치시킴.

정리는 했지만 당연한 얘기임. 10진수에서 $4{37\over100}$ 을 소수로 표기를 변경한다고 하면 $100=10^2$이므로 $37$에서 소수점을 왼쪽으로 2칸 옮기고 그 앞에 $4$를 붙여 $4.37$을 만듬. 똑같이 하면 됨.

예시: $1{7\over16}$을 2진수 표기로 변환

$7 = 111_2$ <br>
${7\over16} = 0.0111_2\ (\because 16 = 2^4)$ <br>
$1{7\over16} = 1.0111_2$

**컴퓨터에서 사용할 때, 2진수 표기의 문제점** : 

예를 들어, $5\cdot2^{100}$ 과 같은 수를 표현하려면, $101$ 뒤에 100개의 $0$ 이 와야 함. 이러한 방식은 사용할 수 있는 비트가 제한된 상황에서 비효율적.

물론, 머신러닝과 같이 상당한 양의 연산을 빠르게 하는 것이 보다 정확하게 계산하는 것보다 더 중요한 상황에서는 위와 같은 방식이 효율적이기 때문에 대안 중 하나로 고려되고 있음. 하지만, 특정 길이를 갖는 비트열 내에서 하나의 고정된 소수점을 가져야 하기 때문에, 범용 컴퓨터에서 사용하기에는 제약이 많음.

### IEEE 부동소수점
**IEEE 부동소수점의 특징**:
- 정렬, 반올림, overflow, underflow에 대해 비교적 잘 설계되어 있음.
- 절대값이 0에 가까워질수록 숫자들이 모여있음.
- 표준 정의 당시 하드웨어 디자이너들보다 수치해석자들이 우위인 상황에서 정의돼 하드웨어로 빠르게 만드는 것이 어려움.

IEEE 부동소수점 표준은 부동소수점 수를 아래와 같이 나타냄. 물리 등에서 주로 사용하는 과학적 표기법(scientific notation)과 비슷.

**부동소수점 표현** :

$V = (-1)^s\cdot M\cdot2^E$
- $s$ : 부호(sign bit). 숫자가 음수($s = 1$)인지 양수($s = 0$)인지를 결정.
- $M$ : 가수(mantissa). $M\in [0, 1)\cup[1, 2)$ .
- $E$ : 지수(exponent). 음수가 돼도 됨.

**부동소수점 인코딩** :

단정도(single precision)와 배정도(double precision) : 부동소수점 수의 비트 표시는 인코딩을 위해 총 3개의 필드로 구분됨. 아래에서 MSB와 LSB는 각 필드가 MSB 쪽에 가깝게 위치하는지 LSB 쪽에 가깝게 위치하는지를 표시하기 위함임.
- 단정도(32bit) : MSB s(1bit), exp(8bit), frac(23bit) LSB
- 배정도(64bit) : MSB s(1bit), exp(11bit), frac(52bit) LSB

s, exp, frac의 의미는 아래와 같음.
- s : 부호 필드(MSB). 부호 $s$로 직접적으로 인코딩.
- exp : 지수 필드. 지수 $E$로 인코딩.
- frac : 가수 필드. 가수 $M$으로 인코딩.

인코딩 방법 :

|Case|Condition|$E$|$M$|
|:---|:---|:---|:---|
|**Normalized**|$\mathsf{exp} \ne [000\cdots 0],\ \mathsf{exp} \ne [111\cdots 1]$|$\mathsf{exp} - \mathsf{Bias}$|$1.\mathsf{frac}$|
|**Denormalized**|$\mathsf{exp} = [000\cdots 0]$|$1-\mathsf{Bias}$|$0.\mathsf{frac}$|
|**Special**|$\mathsf{exp} = [111\cdots 1]$||$`\begin{cases}\infty,& \mathsf{frac} = [000\cdots0]\\\mathsf{NaN},& \mathsf{frac} \ne [000\cdots0]\end{cases}`$|
- $\mathsf{Bias}$ : $2^{k-1}-1$ ($k$ : exp의 비트 폭)
    - 단정도 : $\mathsf{Bias} = 127$
    - 배정도 : $\mathsf{Bias} = 1023$
- 부호 비트의 존재로 인해, $+0, -0, +\infty, -\infty$ 가 존재하며, $+0$과 $-0$은 다른 값.
- normalized와 denormalized에서 $\mathsf{frac}$은 비트열 그대로를 의미 (unsigned로 인코딩된 값이 아님).
- $\infty$ : overflow를 나타내기 위함.
- $\mathsf{NaN}$ : Not A Number.

![visualization_for_floating_point](/image/visualization_floating_point.svg)

이러한 방식의 좋은 점은 정렬에 있음. $a$와 $b$의 부호비트가 같을 때, $a$가 더 크다고 하면, 각각의 비트열만 봐도 $a$가 더 크다는 사실을 직관적으로 알 수 있음. 왜냐하면, 양수를 봤을 때, denorm은 exp가 0이라 exp가 0이 아닌 norm보다 절대 커질 수 없음. 무한대도 exp는 1, frac은 0인 값인데, norm은 exp가 1이 될 수 없기 때문에 무한대가 모든 norm보다 큼.

인코딩 성질 :
- Floating Point에서의 $+0$은 정수에서의 $0$과 비트벡터가 같음.
- 대부분의 상황에서 비부호형을 이용해 쉽게 비교 가능하도록 설계.
    - 부호 비트부터 비교.
    - $-0 == 0$ 를 반드시 고려해야 함.
    - `NaN`은 따로 처리해야 함.
    - 다른 모든 경우는 단순 비교 가능.

### 부동소수점 연산
TODO : 51분 31초부터 보면 됨.