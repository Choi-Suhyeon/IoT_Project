<link rel="stylesheet" href="../style/style.css">

# 02.01. Data [Additional]

## 다룰 함수와 연산자
|Symbol|Type|Meaning|
|:---|:---|:---|
|$B2T_w$|Function|Binary to 2's complement|
|$B2U_w$|Function|Binary to unsigned|
|$U2B_w$|Function|Unsigned to binary|
|$U2T_w$|Function|Unsigned to 2's complement|
|$T2B_w$|Function|2's complement to binary|
|$T2U_w$|Function|2's complement to unsigned|
|$+^t_w$|Operation|2's complement addition|
|$+^u_w$|Operation|Unsigned addition|
|$\times^t_w$|Operation|2's complement multiplication|
|$\times^u_w$|Operation|Unsigned multiplication|
|$-^t_w$|Operation|2's complement negation|
|$-^u_w$|Operation|Unsigned negation|

## 정수 표시
이 문서를 정리한 사람이 크기와 해석(몇 바이트를 읽어서 뭐로 해석할지)으로 모든 것을 설명하려는 것 같긴 한데(~~미쳐있는 것 같긴 한데~~),,, 솔직히 여기선 중요함. 이걸 모르면 아래 내용을 논할 수가 없음. 특히 2의 보수할 때.

**비트 벡터($\vec{x}$)** : $w$ bit 크기의 비트열은 다음과 같음. $[x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$. $x_i$는 $0$ 또는 $1$을 갖음. $1$을 갖으면 $2^i$값이 수 계산에 포함되어야 함을 의미. 

### 비부호형 인코딩
벡터 $\vec{x} = [x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$에 대해,

$B2U_w(\vec{x}) \doteq \sum_{i=0}^{w-1}2^ix_i$

**의미** : 모든 비트를 자릿수 맞춰서 더함.

$UMax_w \doteq \sum_{i=0}^{w-1}2^i = 2^w - 1 = [111\cdots 1] =$ `0xFF...F` (크기 : w / 8 byte)<br>
&emsp; $UMax_w \doteq \sum_{i=0}^{w-1}2^i$ <br>
&emsp;&emsp; $= 2^0 + 2^1 + 2^2 + \cdots + 2^{w-1}$ (등비수열 : $a_n = 1 \cdot 2^{n-1}$)<br>
&emsp;&emsp; $= {1(2^w - 1) \over 2 - 1}$ (등비수열의 합 : ${a(r^n - 1) \over r - 1}$)<br>
&emsp;&emsp; $= 2^w - 1$

$UMin_w \doteq 0 = [000\cdots 0] =$ `0x00...0` (크기 : w / 8 byte)

**성질** :  $B2U_w$는 $B2U_w: \{0, 1\}^w \rightarrow \{0, 1, 2, \cdots, UMax_w\}$와 같은 맵핑으로 정의될 수 있으며, 일대일 함수를 이룸. 그렇기 때문에 역함수를 구할 수 있으며, 그 역함수를 $U2B_w$로 표시.

### 2의 보수 인코딩
벡터 $\vec{x} = [x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$에 대해,

$B2T_w(\vec{x}) \doteq -2^{w-1}x_{w-1} + \sum_{i=0}^{w-2}2^ix_i$

**의미** : MSB(부호 비트)를 제외한 모든 비트를 자릿수 맞춰 더하고 부호 비트 계산한 것을 빼줌.
- MSB가 부호 비트인 이유 : MSB가 0이면 $-2^{w-1}x_{w-1} = 0$이기 때문에 수식의 결과가 비부호형 인코딩과 다를 것이 없음. 하지만 MSB가 1이면 $-2^{w-1}x_{w-1} $이 0이 아닌 값으로 연산이 되기 때문에 음수가 나올 수 밖에 없음(왜냐하면, 자릿수가 가장 큰 비트는 그것보다 작은 모든 비트를 더한 것보다 1 큼).

$TMax_w \doteq \sum_{i=0}^{w-2}2^i = [011\cdots 1] =$ `0x7FF...F` (부호비트를 0으로 설정하고, 나머지를 1로 설정)

$TMin_w \doteq -2^{w-1} = [100 \cdots 0] =$ `0x800...0` (부호비트를 1로 설정하고 나머지를 0으로 설정)

**성질** :  
- $B2T_w$는 $B2T_w: \{0, 1\}^w \rightarrow \{TMin_w, TMin_w + 1, TMin_w + 2, \cdots, TMax_w\}$와 같은 맵핑으로 정의될 수 있으며, 일대일 함수를 이룸. 그렇기 때문에 역함수를 구할 수 있으며, 그 역함수를 $U2B_w$로 표시.
- $\left\vert TMin\right\vert = TMax + 1$ : $TMin$에 대응되는 양수 값이 없음.
- $UMax = 2TMax + 1$
- 참고로 -1은 $w$크기의 비트벡터가 있을 때 모든 원소가 1인 비트 벡터. 부호 비트가 1인 상황에서 더할 수 있는 가장 큰 수를 더해줘야 0과 가까워짐. -2는 -1에서보다 하나 덜 더해주면 됨.
    - `-1 == 0xFFFF` (2byte)
    - `-2 == 0xFFFE` (2byte)

**특정 비트 벡터에 대한 2의 보수인 비트 벡터 구하기** : 특정 비트 벡터 또한 2의 보수로 해석함. 크기가 $w$인 비트 벡터가 있다고 가정.
1. 의미 그대로 구함 : $2^w - \vec{x}$
1. 비트 반전 + 1 : `~x + 1`<br>
&emsp; `~x`<br>
&emsp;&emsp; $= [111\cdots 1] - \vec x$ (2진수의 자릿수는 $w$)<br>
&emsp;&emsp; $= UMax_w - \vec x$<br>
&emsp;&emsp; $= 2^w - 1 - \vec x$<br>
&emsp; `~x + 1`<br>
&emsp;&emsp; $= 2^w - 1 - \vec x + 1$<br>
&emsp;&emsp; $= 2^w - \vec x$

### 비부호형과 부호형 간의 형변환
비부호형과 부호형을 결정하는 것은 해석. <u>비트가 달라지는 것이 아님</u>. 따라서 가장 쉬운 방법은 십진수랑 비트 벡터 크기가 주어지면 비트열로 써놓고 해석을 바꾸면 됨. 아래도 그거 정리한 것.

**2의 보수에서 비부호형으로 변환** : 2's complement 🠖 $T2B$ 🠖 $B2U$ 🠖 Unsigned

$`T2U_w(x) = \begin{cases}x + 2^w,& x < 0 \\ x,& x \ge 0 \end{cases}`$

2의 보수의 인코딩 방식을 보면 나머지는 더하고 최상위 비트를 빼줌. 하지만, 비부호형은 최상위 비트 또한 더해줌. 그럼 2의 보수로 계산이 완료된 상태에서 비트에 대한 해석을 똑같이 맞춰주려면 최상위 비트 계산 결과(양수 : 0, 음수 : $2^{w-1}$)를 두 번 더해야 함. 즉, 최상위 비트 계산 결과에 2배를 더해줘야 하는데 음수의 경우 그 값이 $2^1\cdot 2^{w-1} = 2^{1 + w - 1} = 2^w$. 그래서 $2^w$을 더함. 

**외우면 편한 애들** : 2의 보수 🠖 비부호형. 역도 당연히 성립함.
- $0$ 🠖 $0$
- $TMax$ 🠖 $TMax$
- $-1$ 🠖 $UMax$
- $-2$ 🠖 $UMax - 1$
- $TMin$ 🠖 $TMax + 1$

**비부호형에서 2의 보수로 변환** : Unsigned 🠖 $U2B$ 🠖 $B2T$ 🠖 2's complement

$U2T_w(u) =
\begin{cases}
u,& u \le TMax_w \\
u - 2^w,& u > TMax_w
\end{cases}$

위와 논리는 같음. $TMax_w$보다 크지 않다는 것은 MSB가 0이라는 뜻 ($TMax_w$가 MSB가 0인 수 중에 가장 큰 수). 그럼 $w-2$ 이하는 해석이 달라지지 않음. MSB가 1이면 해석이 달라지는데, 비부호 인코딩에서는 MSB 계산 결과를 더했음. 하지만 2의 보수에서는 빼줘야 함. 이미 비트 벡터를 비부호로 해석한 상태에서 2의 보수로 해석을 변경하려면 빼줘야될 애를 더했으니 2번 빼줘야 함. 그래서 $2^w$이 됨. 

### 비트 벡터 확장
확장에서 중요한 것은 비트를 확장 이후에도 값이 달라지지 않는 것.

**비부호형 비트 벡터 확장** : MSB가 있는 쪽을 0으로 확장.
- 어차피 비부호형은 모든 비트들을 더하기 때문에 값이 달라지지 않으려면 간단하게 확장된 더 높은 자릿수들을 0으로 채우면 됨.

**2의 보수 비트 벡터 확장** : MSB(부호 비트)가 있는 쪽을 부호 비트로 확장.
- 중요한 것은 부호가 달라지면 안 됨. 그러면 확장되더라도 부호 비트는 같아야 됨. 그러면, 나머지는 더하고 부호 비트를 빼는 식으로 인코딩을 하는데 비트가 부호 비트 쪽으로 확장됐다는 얘기는 음수면 마지막에 빼주는 부호 비트의 계산 값이 커졌다는 얘기. 부호 비트의 계산 값이 커졌을 때도 값이 달라지지 않으려면 부호 비트를 제외한 추가된 비트들에도 1을 넣어서 전부 더해, 최종 결과 값이 달라지지 않게 만들면 됨. 그 방법이 부호비트가 1이면 확장된 곳도 1로 채우고, 부호비트가 0이면 확장된 곳도 0으로 채움.

### 비트 벡터 절삭
비트를 잘라내는 것으로 일종의 overflow. 당연히 2의 보수로 해석할 경우 잘려진 비트를 다시 해석해줘야 하며 부호도 변경될 수 있음.

비트 벡터 $\vec x = [x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$를 $k$비트 수로 절삭할 때 상위 $w-k$비트를 제거해서 $\vec x' = [x_{k-1}, x_{k-2}, x_{k-3}, \cdots, x_0]$ 얻을 수 있음. 그 결과는 아래와 같음.

**비부호형 비트 벡터 확장** : $x' = x\,\bmod\,2^k$

**2의 보수 비트 벡터 확장** : $x' = U2T_k(x\,\bmod\,2^k)$ (추가적으로, 비트 벡터를 재해석만 해주는 것 뿐)

약간의 직관이 필요한 데, 쉽게 생각해서 168에서 일의 자리만 남기고 싶으면 8은 당연하지만 168을 10($10^1$)으로 나눈 나머지로 구해도 됨. 마찬가지로 비트 벡터의 크기가 6이었는데 3으로 줄이고 싶다면 (즉, 3의 자리까지만 남기고 싶다면), $2^3$으로 나눈 나머지.

## 정수 연산
### 비부호형 덧셈
음 아닌 정수 $x, y\ (0 \le x, y < 2^w)$ 를 고려했을 때, 이들 합의 가능한 범위는 $0 \le x + y \le 2^{w+1} - 2$ . 즉, 필요한 비트는 $w + 1$ 비트로, $w$ 비트로 표현할 수 있는 범위를 벗어남. 
- $x, y$ 모두 최대 $2^w - 1$이 될 수 있기 때문에 $x + y$의 최대값은 $2(2^w - 1) = 2^{w + 1} - 2$ 가 됨.

Lisp이나 Python처럼 임의 크기의 산술 연산을 지원하는 언어도 있지만, 그렇지 않은 언어도 많음.

**비부호형 덧셈** :

$x, y\ (0 \le x, y < 2^w)$ 에 대해,

$x +^u_w y = \begin{cases}x + y,& x + y < 2^w\\ x+y-2^w,& 2^w \le x + y < 2^{w+1}\end{cases}$

연산 후 연산 결과가 $w$ 비트가 되도록 절삭함. 이는 위에서도 설명했듯, $2^w$ 나눈 나머지와 결과가 같음. 모듈러 연산으로 나머지를 구할 때 `a % b`, `a`에서 `b`를 연속적으로 빼거나 더해서 `0`과 `b`사이의 숫자가 되도록 만들기도 하는데, 더한 결과가 $2^{w+1}$ 보다 작기 때문에 한 번만 빼주면 됨.

아니면, 연산 후 $w + 1$ 번째 비트가 절삭되는데 결과가 범위를 벗어난다는 것은 $w + 1$ 번째 비트가 1로 세팅되었다는 것과 같아 $w + 1$ 번째 비트의 값 $2^w$을 빼준다고 봐도 무방함.

위 공식에서 두 번째 경우의 상황을 overflow라고 표현.

**비부호형 덧셈에서 overflow 검출** :

$x, y\ (0 \le x, y \le UMax_w)$ 에 대해, $s \doteq x +^u_w y$ 라 하자.

$s < x$ 또는 $s < y$ 면, $s$는 overflow됐으며 역 또한 성립.

만약 overflow가 됐다면, $s = x + y - 2^w$. 여기서 $y < 2^w,\ y - 2^w < 0$<br>따라서, $s = x + (y - 2^w) < x$<br>위와 같은 방법으로 $s < y$

**비부호형 역원** :

모듈러 덧셈은 가환군(또는 아벨군)을 형성. 
 - 군(Group) : 집합 내에서 특정 연산에 대해
    1. 결합 법칙이 성립해야 함.
    1. 항등원이 존재해야 함.
    1. 역원이 존재해야 함.
- 가환군(Commutative Group) : 위 조건에 교환 법칙까지 성립해야 함.

즉, 교환 법칙과 결합 법칙이 성립하고, 항등원 0을 갖으며, 덧셈의 역을 갖음.

모든 $x$에 대해, $-^u_wx +^u_w x = 0$을 만족하는 $-^u_wx$이 존재.

$-^u_wx = \begin{cases}x,& x = 0\\ 2^w - x,& x > 0\end{cases}$

$x > 0$ 상황에서, $2^w - x$는 $0 < 2^w - x < 2^w$. 그리고, $(x + 2^w - x)\,\bmod\,2^w = 2^w\,\bmod\,2^w = 0$ 이므로, $-^u_wx$ 는 연산 $+^u_w$ 에 대한, $x$의 역.

### 2의 보수 덧셈
정수 $x, y\ (-2^{w-1} \le x, y \le 2^{w-1}-1)$ 를 고려했을 때, 이들 합의 가능한 범위는 $-2^w \le x + y \le 2^w - 2$ . 즉, 필요한 비트는 $w + 1$ 비트로, $w$ 비트로 표현할 수 있는 범위를 벗어남. 따라서 $w$ bit에 맞게 남은 상위 비트는 절삭해야 함.

**주의** : 비트 수준 관점에서 봤을 때, 2의 보수 덧셈과 비부호형 덧셈은 완벽히 같은 결과를 갖음. 머신 코드로도 둘을 구별하여 연산하지 않음.

**2의 보수 덧셈** :

$x, y\ (-2^{w-1} \le x, y \le 2^{w-1}-1)$ 에 대해,

$x +^t_w y = \begin{cases}x + y - 2^w,& 2^{w-1} \le x + y\\ x+y,& -2^{w-1} \le x + y < 2^{w-1}\\ x+y+2^w,& x+y<-2^{w-1}\end{cases}$

위 법칙에서 첫 번째 경우를 양의 오버플로우(positive overflow), 세 번째 경우를 음의 오버플로우(negative overflow)라고 함.
- 양의 오버플로우 : $x+y$ 의 결과가 $TMax_w$ 보다 클 때 발생.
- 음의 오버플로우 : $x+y$ 의 결과가 $TMin_w$ 보다 작을 때 발생.

비트 수준에서는 비부호형 덧셈과 2의 보수 덧셈이 차이가 없다는 점을 이용해 아래와 같이 표현 가능.

$x+^t_wy$
<br>&emsp;&emsp;$= U2T_w(T2U_w(x) +^u_w T2U_w(y))$
<br>&emsp;&emsp;$= U2T_w((x + 2^wx_{w-1}+y+2^wy_{w-1}) \,\bmod\,2^w)$
<br>&emsp;&emsp;$= U2T_w((x + y)\,\bmod\,2^w)\ (\because 2^wx_{w-1}\equiv0\pmod{2^w}, 2^wy_{w-1}\equiv0\pmod{2^w})$

2의 보수 덧셈에서 덧셈 결과는 크게 4가지 범주로 나눌 수 있음.
1. 음수이면서, $TMin_w$보다 작은 경우.
1. 음수이면서, $TMin_w$보다 작지 않은 경우.
1. 양수이면서, $TMax_w$보다 크지 않은 경우.
1. 양수이면서, $TMax_w$보다 큰 경우.

각 4가지 범주를 바로 위 공식에 넣어 2의 보수의 덧셈이 3가지 경우에 대해 왜 저런 식을 갖는지 차례로 알아볼 예정.
1. 음수이면서, $TMin_w$보다 작은 경우.
    <br>$-2^w\le x+y<-2^{w-1}$
    <br>$0\le x+y+2^w < 2^{w-1}$
    <br>$\therefore x+^t_wy = x + y + 2^w,\ x + y < -2^{w-1}$
1. 음수이면서, $TMin_w$보다 작지 않은 경우.
    <br>$-2^{w-1}\le x+y<0$
    <br>$2^{w-1}\le x+y+2^w < 2^w$
    <br>$\therefore x+^t_wy = x+y+2^w-2^w\ (\because TMax_w = 2^{w-1}-1 < x+y+2^w)$
    <br>$\therefore x+^t_wy = x + y,\ -2^{w-1}\le x + y < 0$
1. 양수이면서, $TMax_w$보다 크지 않은 경우.
    <br>$0\le x+y<2^{w-1}$
    <br>$\therefore x+^t_wy = x+y,\ 0\le x+y < 2^{w-1}$
1. 양수이면서, $TMax_w$보다 큰 경우.
    <br>$2^{w-1}\le x+y<2^w$
    <br>$-2^{w-1}\le x+y-2^w<0$
    <br>$\therefore x+^t_wy = x+y-2^w,\ 2^{w-1}\le x+y < 2^w$

**2의 보수 덧셈에서 overflow 검출** : 비부호형 덧셈에서 overflow를 검출하는 것보다 쉬움. 양수와 양수를 더했는데 음수가 나오거나 음수와 음수를 더했는데 양수가 나오면 overflow가 발생했다고 판단. 역 또한 성립.

**2의 보수 역원** : 
$-^t_wx = \begin{cases}TMin_w,& x = TMin_w\\ -x,& x > TMin_w\end{cases}$

$TMin_w + TMin_w = -2^{w-1}+-2^{w-1} = -2^{w}$ 연산 결과가 $-2^{w-1}$보다 작으므로, 음의 overflow.
$TMin_w+^t_wTMin_w = -2^w+2^w = 0$. 따라서, $TMin_w$의 항등원은 $TMin_w$.

**비부호형 곱셈** : 비부호형 곱셈은 비부호형 덧셈과 마찬가지로 연산결과를 $2^w$으로 모듈로 연산을 하면 됨.

$x\times^u_wy = (xy)\,\bmod\,2^w$

**2의 보수 곱셈** : 

$x\times^t_wy = U2T_w((xy)\,\bmod\,2^w)$

곱셈 또한 마찬가지로 비트 수준에서는 비부호형과 2의 보수가 차이가 없음. 이를 식으로 표현하면 아래와 같음.

$T2B_w(x\times^t_wy) = U2B_w(x'\times^u_wy')$
<br>&emsp;&emsp;$x' = T2U_w(x) = x + 2^wx_{w-1},\ y' = T2U_w(y) = y + 2^wy_{w-1}$
<br>&emsp;&emsp;$(x'y')\,\bmod\,2^w$
<br>&emsp;&emsp;&emsp;&emsp;$= \{(x+2^wx_{w-1})\cdot(y+2^wy_{w-1})\}\,\bmod\,2^w$
<br>&emsp;&emsp;&emsp;&emsp;$= \{xy+2^w(x_{w-1}y + xy_{w-1})+2^{2w}x_{w-1}y_{w-1}\}\,\bmod\,2^w$
<br>&emsp;&emsp;&emsp;&emsp;$= (xy)\,\bmod\,2^w$
<br>&emsp;&emsp;$x\times^t_wy = U2T_w((xy)\,\bmod\,2^w)$
<br>&emsp;&emsp;$T2U_w(x\times^t_wy) = T2U_w(U2T_w((xy)\,\bmod\,2^w)) = (xy)\,\bmod\,2^w$
<br>&emsp;&emsp;$T2U_w(x\times^t_wy) = (x'y')\,\bmod\,2^w = x'\times^u_wy'\ (\because (x'y')\,\bmod\,2^w = (xy)\,\bmod\,2^w)$
<br>&emsp;&emsp;$U2B_w(T2U_w(x\times^t_wy)) = T2B(x\times^t_wy) = U2B(x'\times^u_wy')$

**상수를 사용한 곱셈과 나눗셈** : 덧셈, 뺄셈, 비트 연산 등은 1사이클만 필요로 하는 반면에, 정수 곱셈은 intel i7 CPU에서도 3사이클이 필요함. 따라서, 상수를 곱하는 경우, 덧셈, 뺄셈, 비트 연산을 활용해 최적화를 시도할 수 있음.