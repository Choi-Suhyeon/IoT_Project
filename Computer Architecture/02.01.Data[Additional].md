<link rel="stylesheet" href="../style/style.css">

# 02.01. Data [Additional]

## 다룰 함수와 연산자
|Symbol|Type|Meaning|
|:---|:---|:---|
|$B2T_w$|Function|Binary to 2's complement|
|$B2U_w$|Function|Binary to unsigned|
|$U2B_w$|Function|Unsigned to binary|
|$U2T_w$|Function|Unsigned to 2's complement|
|$T2B_w$|Function|2's complement to binary|
|$T2U_w$|Function|2's complement to unsigned|
|$+^t_w$|Operation|2's complement addition|
|$+^u_w$|Operation|Unsigned addition|
|$\times^t_w$|Operation|2's complement multiplication|
|$\times^u_w$|Operation|Unsigned multiplication|
|$-^t_w$|Operation|2's complement negation|
|$-^u_w$|Operation|Unsigned negation|

## 정수 표시
이 문서를 정리한 사람이 크기와 해석(몇 바이트를 읽어서 뭐로 해석할지)로 모든 것을 설명하려는 것 같긴 한데(~~미쳐있는 것 같긴 한데~~),,, 솔직히 여기선 중요함. 이걸 모르면 아래 내용을 논할 수가 없음. 특히 2의 보수할 때.

**비트 벡터($\vec{x}$)** : $w$ bit 크기의 비트열은 다음과 같음. $[x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$. $x_i$는 $0$ 또는 $1$을 갖음. $1$을 갖으면 $2^i$값이 숫자 계산에 포함되어야 함을 의미. 

### 비부호형 인코딩
벡터 $\vec{x} = [x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$에 대해,

$B2U_w(\vec{x}) \doteq \sum_{i=0}^{w-1}2^ix_i$

**의미** : 모든 비트를 자릿수 맞춰서 더함.

$UMax_w \doteq \sum_{i=0}^{w-1}2^i = 2^w - 1 = [111\cdots 1] =$ `0xFF...F` (크기 : w / 8 byte)<br>
&emsp; $UMax_w \doteq \sum_{i=0}^{w-1}2^i$ <br>
&emsp;&emsp; $= 2^0 + 2^1 + 2^2 + \cdots + 2^{w-1}$ (등비수열 : $a_n = 1 \cdot 2^{n-1}$)<br>
&emsp;&emsp; $= {1(2^w - 1) \over 2 - 1}$ (등비수열의 합 : ${a(r^n - 1) \over r - 1}$)<br>
&emsp;&emsp; $= 2^w - 1$

$UMin_w \doteq 0 = [000\cdots 0] =$ `0x00...0` (크기 : w / 8 byte)

**성질** :  $B2U_w$는 $B2U_w: \{0, 1\}^w \rightarrow \{0, 1, 2, \cdots, UMax_w\}$와 같은 맵핑으로 정의될 수 있으며, 일대일 함수를 이룸. 그렇기 때문에 역함수를 구할 수 있으며, 그 역함수를 $U2B_w$로 표시.

### 2의 보수 인코딩
벡터 $\vec{x} = [x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$에 대해,

$B2T_w(\vec{x}) \doteq -2^{w-1}x_{w-1} + \sum_{i=0}^{w-2}2^ix_i$

**의미** : MSB(부호 비트)를 제외한 모든 비트를 자릿수 맞춰 더하고 부호 비트 계산한 것을 빼줌.
- MSB가 부호 비트인 이유 : MSB가 0이면 $-2^{w-1}x_{w-1} = 0$이기 때문에 수식의 결과가 비부호형 인코딩과 다를 것이 없음. 하지만 MSB가 1이면 $-2^{w-1}x_{w-1} = 0$가 0이 아닌 값으로 연산이 되기 때문에 음수가 나올 수 밖에 없음(왜냐하면, 자릿수가 가장 큰 비트는 그것보다 작은 모든 비트를 더한 것보다 1 큼).

$TMax_w \doteq \sum_{i=0}^{w-2}2^i = [011\cdots 1] =$ `0x7FF...F` (부호비트를 0으로 설정하고, 나머지를 1로 설정)

$TMin_w \doteq -2^{w-1} = [100 \cdots 0] =$ `0x800...0` (부호비트를 1로 설정하고 나머지를 0으로 설정)

**성질** :  
- $B2T_w$는 $B2T_w: \{0, 1\}^w \rightarrow \{TMin_w, TMin_w + 1, TMin_w + 2, \cdots, TMax_w\}$와 같은 맵핑으로 정의될 수 있으며, 일대일 함수를 이룸. 그렇기 때문에 역함수를 구할 수 있으며, 그 역함수를 $U2B_w$로 표시.
- $\left\vert TMin\right\vert = TMax + 1$ : $TMin$에 대응되는 양수 값이 없음.
- $UMax = 2TMax + 1$
- 참고로 -1은 $w$크기의 비트벡터가 있을 때 모든 원소가 1인 비트 벡터. 부호 비트가 1인 상황에서 더할 수 있는 가장 큰 수를 더해줘야 0과 가까워짐. -2는 -1에서보다 하나 덜 더해주면 됨.
    - `-1 == 0xFFFF` (2byte)
    - `-2 == 0xFFFE` (2byte)

**특정 비트 벡터에 대한 2의 보수인 비트 벡터 구하기** : 특정 비트 벡터 또한 2의 보수로 해석함. 크기가 $w$인 비트 벡터가 있다고 가정.
1. 의미 그대로 구함 : $2^w - \vec{x}$
1. 비트 반전 + 1 : `~x + 1`<br>
&emsp; `~x`<br>
&emsp;&emsp; $= [111\cdots 1] - \vec x$ (2진수의 자릿수는 $w$)<br>
&emsp;&emsp; $= UMax_w - \vec x$<br>
&emsp;&emsp; $= 2^w - 1 - \vec x$<br>
&emsp; `~x + 1`<br>
&emsp;&emsp; $= 2^w - 1 - \vec x + 1$<br>
&emsp;&emsp; $= 2^w - \vec x$

### 비부호형과 부호형 간의 형변환
비부호형과 부호형을 결정하는 것은 해석. <u>비트가 달라지는 것이 아님</u>. 따라서 가장 쉬운 방법은 십진수랑 비트 벡터 크기가 주어지면 비트열로 써놓고 해석을 바꾸면 됨. 아래도 그거 정리한 것.

**2의 보수에서 비부호형으로 변환** : 2's complement 🠖 $T2B$ 🠖 $B2U$ 🠖 Unsigned

$T2U_w(x) =
\begin{cases}
x + 2^w,& x < 0 \\
x,& x \ge 0
\end{cases}$

2의 보수의 인코딩 방식을 보면 나머지는 더하고 최상위 비트를 빼줌. 하지만, 비부호형은 최상위 비트 또한 더해줌. 그럼 2의 보수로 계산이 완료된 상태에서 비트에 대한 해석을 똑같이 맞춰주려면 최상위 비트 계산 결과(양수 : 0, 음수 : $2^{w-1}$)를 두 번 더해야 함. 즉, 최상위 비트 계산 결과에 2배를 더해줘야 하는데 음수의 경우 그 값이 $2^1\cdot 2^{w-1} = 2^{1 + w - 1} = 2^w$. 그래서 $2^w$을 더함. 

**외우면 편한 애들** : 2의 보수 🠖 비부호형. 역도 당연히 성립함.
- $0$ 🠖 $0$
- $TMax$ 🠖 $TMax$
- $-1$ 🠖 $UMax$
- $-2$ 🠖 $UMax - 1$
- $TMin$ 🠖 $TMax + 1$

**비부호형에서 2의 보수로 변환** : Unsigned 🠖 $U2B$ 🠖 $B2T$ 🠖 2's complement

$U2T_w(u) =
\begin{cases}
u,& u \le TMax_w \\
u - 2^w,& u > TMax_w
\end{cases}$

위와 논리는 같음. $TMax_w$보다 크지 않다는 것은 MSB가 0이라는 뜻 ($TMax_w$가 MSB가 0인 수 중에 가장 큰 수). 그럼 $w-2$ 이하는 해석이 달라지지 않음. MSB가 1이면 해석이 달라지는데, 비부호 인코딩에서는 MSB 계산 결과를 더했음. 하지만 2의 보수에서는 빼줘야 함. 이미 비트 벡터를 비부호로 해석한 상태에서 2의 보수로 해석을 변경하려면 빼줘야될 애를 더했으니 2번 빼줘야 함. 그래서 $2^w$이 됨. 

### 비트 벡터 확장
확장에서 중요한 것은 비트를 확장 이후에도 값이 달라지지 않는 것.

**비부호형 비트 벡터 확장** : MSB가 있는 쪽을 0으로 확장.
- 어차피 비부호형은 모든 비트들을 더하기 때문에 값이 달라지지 않으려면 간단하게 확장된 더 높은 자릿수들을 0으로 채우면 됨.

**2의 보수 비트 벡터 확장** : MSB(부호 비트)가 있는 쪽을 부호 비트로 확장.
- 중요한 것은 부호가 달라지면 안 됨. 그러면 확장되더라도 부호 비트는 같아야 됨. 그러면, 나머지는 더하고 부호 비트를 빼는 식으로 인코딩을 하는데 비트가 부호 비트 쪽으로 확장됐다는 얘기는 음수면 마지막에 빼주는 부호 비트의 계산 값이 커졌다는 얘기. 부호 비트의 계산 값이 커졌을 때도 값이 달라지지 않으려면 부호 비트를 제외한 추가된 비트들에도 1을 넣어서 전부 더해, 최종 결과 값이 달라지지 않게 만들면 됨. 그 방법이 부호비트가 1이면 확장된 곳도 1로 채우고, 부호비트가 0이면 확장된 곳도 0으로 채움.

### 비트 벡터 절삭
비트를 잘라내는 것으로 일종의 overflow. 당연히 2의 보수로 해석할 경우 잘려진 비트를 다시 해석해줘야 하며 부호도 변경될 수 있음.

비트 벡터 $\vec x = [x_{w-1}, x_{w-2}, x_{w-3}, \cdots, x_0]$를 $k$비트 수로 절삭할 때 상위 $w-k$비트를 제거해서 $\vec x' = [x_{k-1}, x_{k-2}, x_{k-3}, \cdots, x_0]$ 얻을 수 있음. 그 결과는 아래와 같음.

**비부호형 비트 벡터 확장** : $x' = x\ \mathrm{mod}\ 2^k$

**2의 보수 비트 벡터 확장** : $x' = U2T_k(x\ \mathrm{mod}\ 2^k)$ (추가적으로, 비트 벡터를 재해석만 해주는 것 뿐)

약간의 직관이 필요한 데, 쉽게 생각해서 168에서 일의 자리만 남기고 싶으면 8은 당연하지만 168을 10($10^1$)으로 나눈 나머지로 구해도 됨. 마찬가지로 비트 벡터의 크기가 6이었는데 3으로 줄이고 싶다면 (즉, 3의 자리까지만 남기고 싶다면), $2^3$으로 나눈 나머지. 