<link rel="stylesheet" href="../style/style.css">

# 01. Ownership And Moves

## 개요
이동과 복사의 차이는 책임에 있음. 드롭 시에 자원에 특별한 처리가 필요하다면, 해당 자원의 책임 소재를 명확히 할 필요가 충분함. 만약 이러한 처리가 필요함에도 단순히 비트 단위 복사를 하게 되면, 책임을 알기 어려워 예를 들어, 두 번 이상의 해제나 해제를 안 할 소지가 있음. 여기서 특별한 처리란 String의 할당 받은 힙 공간 드롭, File의 파일 핸들 닫기, MutexGuard의 뮤텍스 잠금 해제 등임.

## 0. 소유
### 0.0. 보편적 특징
일반적으로, Rust에서 모든 값은 자신의 수명을 결정하는 ***유일한 소유자***를 갖음.

소유자가 드롭(C에서의 해제)될 때 그가 소유한 모든 값은 함께 드롭됨.

아무리 복잡한 관계여도 소유자와 이들이 소유한 값은 트리 구조를 이룸. 또한, 각 트리의 최종 루트는 변수. 이러한 구조를 변경할 가능성이 있는 구조 변경은 Rust의 단일 소유자 규칙에 의해 모두 금지.

### 0.1. 드롭 방식
C/C++에서와는 다르게 Rust는 명시적으로 드롭을 수행하지 않음. 스코프를 벗어나거나 요소가 삭제되는 등 소유 관계 트리에서 벗어나게 되면 Rust가 알아서 적절히 드롭함.

### 0.2. 예외와 확장
위의 규칙은 너무 엄격하기 때문에 몇 가지 예외와 확장이 존재.
- 복사 : stack에만 값을 저장할 경우(이런 표현도 헷갈리는 표현임. 벡터 안에 있는 숫자는 힙에 저장되도 복사인데;; 그냥 댕글링 포인터를 만들 소지가 없는 경우) 소유 규칙의 적용 대상에서 제외.
    - 이렇게 기억하는 것이 편함. 배열이 `i32`값을 저장하면 복사가 되는데 `Box<i32>`값을 저장하면 이동이 됨. '정수는 복사, 벡터는 이동' 이렇게 기억하면 헷갈림.
- 이동 : 값의 소유자를 한 소유자에서 다른 소유자에게로 옮길 수 있음. 기존 소유자는 더이상 값에 접근 할 수 없음.
- 빌림 : 값의 레퍼런스를 빌려올 수 있음. 레퍼런스는 소유권이 없는 한정된 수명을 갖는 포인터.

## 1. 이동
변수에 값을 배정하거나 함수에 전달하거나 함수에서 반환할 때 대부분 복사가 아닌 이동이 발생.

TODO : 대입이란 표현이 맞는 표현인지 모르겠음.
### 1.0. 여러 언어의 대입 방법
**Python** : 객체마다 레퍼런스 카운트를 갖고 있어 이를 통해 자신을 참조하고 있는 변수의 수를 추적. 복사시 일반적으로는 같은 곳을 가리키는 포인터를 만들고 레퍼런스 카운트를 하나 증가시킴.
- 장점 : 할당에 필요한 비용은 거의 들지 않음.
- 단점 : 해제 시점을 알기 위해 각 객체마다 레퍼런스 카운트를 유지해야 함. 가비지 컬렉터 필요.

**C++** : 레퍼런스 카운트 X. 복사할 때는 복사 생성자를 호출해 할당 시마다 깊은 복사를 수행.
- 장점 : 소유권이 명확.
- 단점 : 메모리와 시간을 한도 끝도 없이 소비.

### 1.1. Rust의 대입 방법
원소유자는 값의 소유권을 새로운 소유자에게 양도하고 미초기화 상태가 됨. 이후 값의 수명은 새로운 소유자가 통제. 이 상황에서 원소유자를 사용하려 하면 초기화되지 않은 값이기 때문에 컴파일 에러가 발생.
- 장점 : 할당에 필요한 비용이 거의 들지 않음, 소유권이 명확.
- 단점 : C++이나 Python의 방법보다 생소하고 쓰기 불편.

### 1.2. C++처럼 복사
`.clone()` : 대상과 이의 요소들에 대한 깊은 복사를 수행하는 메서드.

### 1.3. Python처럼 복사
`Rc`, `Arc`를 활용. 뒤에서 설명.

### 1.4. 이동으로 처리되는 기타 연산
**새로운 값 할당** :
```rust
let mut s = "Choi".to_string();
s = "Kim".to_string(); // 여기서 값 "Choi"가 드롭됨.
```
```rust
fn main() {
    let s = "Choi".to_string();
    let s = "Kim".to_string();
} // 여기서 둘 다 드롭됨. 처음 만들었던 s는 두 번째 만든 s에게 덮이고 둘은 스코프가 같으니 같이 드롭됨.
```
```rust
fn main() {
    let mut s = "Choi".to_string();
    let t = s; // 소유권이 이동. s는 미초기화 상태.
    s = "Kim".to_string(); // s 다시 초기화. 이 시점에서 드랍되는 값은 없음.

    println!("{s}, {t}");
}
```

**새로운 값 생성** :
```rust
let a = "Tomas".to_string(); // a는 to_string의 반환값으로 초기화되며, 이의 소유권은 a가 갖음.
```

**함수에서 값을 반환** :
```rust
fn temp_fn() -> Vec<i32> {
    let mut result = Vec::new();
    result.push(1);
    result.push(2);
    result.push(3);
    result // 소유권이 이동.
}

fn main() {
    let a = temp_fn(); // 이동된 소유권을 변수 a가 받음.
    println!("{:?}", a);
}
```

**함수로 값을 전달** :
```rust
fn print_vec(param: Vec<i32>) {
    println!("{:?}", param);
} // param으로 넘어왔던 값이 드롭.

fn main() {
    let a = vec![1, 2, 3, 4, 5];

    print_vec(a); // 함수 내부로 소유권이 이동. a는 미초기화 상태.
    println!("{:?}", a); // error: borrow of moved value: `a`
}
```

### 1.5. 이동과 제어 흐름
미초기화 상태가 아닌 임의의 변수에 대해서 이의 값이 이동될 가능성이 있고, 이동된 이후에 확실하게 새 값이 주어지지 않았다면, 해당 변수는 미초기화로 간주.
```rust
use std::io;

fn temp_print(vec: Vec<i32>) {
    println!("{:?}", vec);
}

fn main() {
    let a = vec![1, 2, 3, 4, 5];
    let mut b = String::new();

    io::stdin().read_line(&mut b).expect("failed to read line");

    if b.parse::<i32>().expect("expected int") > 10 {
        temp_print(a); // 만약 참이라면 여기서 소유권이 이동.
    }
    else {
        println!("no way~");
    }

    println!("{:?}", a); // error: borrow of moved value: `a`
}
```

### 1.6. 인덱스를 사용하여 접근하는 콘텐츠의 이동
일반적인 경우에 이동이 발생하면 소유권이 새로운 소유주에게로 이동하고 원소유주는 미초기화 상태가 된다. 하지만, 원소유주가 미초기화 상태가 되면 안 될 때 이동은 허락되지 않음.
```rust
fn main() {
    let mut v = Vec::new();
    for i in 101..106 {
        v.push(i.to_string());
    }
    
    let third = v[2].clone();
    let fifth = v[4].clone();
    // 아래처럼 하면 에러가 발생.
    // let third = v[2];
    // let fifth = v[4];
}
```
문자열은 이동하기 때문에 원소유주를 미초기화 상태로 둬야 하는데 벡터가 요소들의 미초기화 상태 여부를 함께 들고 다닐 수도 없고 시스템 프로그래밍 언어가 그러면 안 됨. 위처럼 클론을 만들던 아니면 함수나 메서드를 사용해 <u>최종적으로 벡터가 항상 가득찬 상태가 유지되어야 함</u>. 

만약, 정말로 위 주석처럼 옮겨야만 하는 상황이라면 그렇게 옮겨야 되는 값을 `Option<>`으로 묶고 값을 꺼낸 다음에 `None`을 넣어주면 된다.
```rust
fn main() {
    let mut v = Vec::new();

    for i in 101..106 {
        v.push(Some(i.to_string()));
    }

    let third = std::mem::replace(&mut v[2], None).unwrap();
    let fifth = v[4].take().unwrap();

    println!("{third} {fifth}");
}
```
`None`을 넣어주는 방법은 대표적으로 2가지가 있는데, `std::mem::replace()`를 써도 되고, 아니면 간단하게 `.take()`를 써도 됨.

```rust
fn main() {
    let mut v = Vec::new();
    for i in 101..106 {
        v.push(i);
    }

    let third = v[2];
    let fifth = v[4];
    
    println!("{third} {fifth}");
}
```
요건 가능. `i32`는 댕글링 포인터를 만들 소지가 없으므로 복사됨.

### 1.5. 주의할 점
이동의 적용 대상은 값 자체일 뿐, heap에 할당받은 공간이 아님. 포인터가 다른 곳으로 이동하면 원래 포인터를 갖고 있던 곳을 미초기화 상태로 만들 뿐, 포인터가 가리키는 대상이 변경되는 것이 아님.

Rust 컴파일러는 이러한 움직임을 모두 파악하고 그에 알맞는 코드를 생성. 중간 이동 없이 최종 위치에 바로 저장되기도 함.

## 2. 복사
### 2.0. 사용자 정의 타입과 복사
사용자 정의 타입은 기본적으로 이동을 함. 만약 모든 필드가 복사라면 정의 위에 `#[derive(Copy, Clone)]`을 뒤서 사용자 정의 타입을 복사로 만들 수 있음 (필드 중 하나라도 이동이면 컴파일 에러).
```rust
#[derive(Copy, Clone)]
struct Label { number: u32 }

fn main() {
    let a = Label { number: 32 };
    let b = a;

    println!("{} {}", a.number, b.number);
}
```
참고로 `.clone()`을 사용하려면 `#[derive(Clone)]`을 해줘야 함.

## 3. Rc & Arc
TODO : 나중에 정리할 예정