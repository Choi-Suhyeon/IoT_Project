# Enum & Pattern

## Enum
Rust에서의 enum은 Haskell이나 Ocaml에서 대수적 데이터 타입 또는 합 타입 등으로 불리는 애들과 같은 것. C++에 존재하는 enum에 비하면, 데이터를 가질 수 있고, 해당 데이터의 타입이 같을 필요도 없는 등 보다 다양한 것을 표현하고 처리할 수 있음. 오히려 C의 공용체와 더 비슷하지만, Rust의 enum은 타입 안전성을 갖는다는 차이가 있음.

### 정의
```rust
enum EnumName {
    variant1,
    variant2(String, i32),
    variant3 {
        aa: i32,
        bb: i32,
    }
}
```

enum에서 각각의 후보값을 베리언트(variant)라고 함.

### Variant의 종류
위에 보이는 것처럼 enum에는 총 3가지 종류의 베리언트가 존재함.
- 유닛형 베리언트 : 데이터를 갖지 않는 형태.
- 튜플형 베리언트 : 소괄호 내에 이름 없이 데이터를 갖는 형태.
- 구조체형 베리언트 : 중괄호 내에 이름과 함께 데이터를 갖는 형태.

이는 구조체의 3가지 형태(기명필드로 된 구조체, 튜플형 구조체, 유닛형 구조체)와 유사함. 튜플형 베리언트의 경우 그 자체는 함수로 쓰일 수 있다는 것도 같음. 하지만, 표현식에서 `{ .. EXPR }`는 사용할 수 없음.

### 메서드
구조체에서와 마찬가지로 `impl EnumName { ... }`의 형식으로 구현하면 됨.

### Tag
Enum의 값은 정수 형태의 tag로 구분됨. 이들은 enum 정의에서 각 variant 뒤에 `= value`의 형식으로 tag 값을 명시적으로 특정지을 수 있음. 이때 enum의 tag 크기는 이를 모두 수용할 수 있는 가장 작은 정수 타입을 사용함.
```rust
enum HttpStatus {
    Ok = 200,
    NotModified = 304,
    NotFound = 404,
}
```

이때 enum 값을 정수 값으로 형변환 할 수는 있어도 정수 값은 enum값으로 실패할 우려가 있기 때문에 `as`를 이용해 형변환 할 수 없음. 따로 함수를 둬야 함. enum_primitive 또는 enum_primitive_derive 등의 crate를 사용해 이 함수를 손쉽게 만들 수 있음.

유닛형이 아니더라도 뒤에 `= value` 형식으로 값을 특정지을 수는 있지만, 어찌된 영문인지 `as`를 이용해 정수형으로 형변환하면, 이상한 값이 나옴.

### 메모리 구조
구조체와 유사한 메모리 구조로 enum 값의 가장 앞에는 tag가 오고 뒤에는 값이 있다면 값을 위한 공간이 옴. 다만, 구조체와 마찬가지로 Rust는 enum의 구체적인 레이아웃에 대해 어떠한 약속도 하지 않음.

### 제네릭 enum
구조체에서와 유사하게 정의. 아래는 `Option`과 `Result`의 정의.
```rust
enum Option<T> {
    None,
    Some(T),
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

여기서 Rust는 `T`가 레퍼런스이거나 Box이거나 기타 스마트 포인터 타입일 경우, tag 필드를 제거할 수도 있음. 포인터 타입은 null 값이 될 수 없으므로, Option을 예로 들면, `None`을 0으로 `Some(T)`를 0이 아닌 주소 값으로 두면 됨.

### 주의
구조체의 경우처럼, `==`과 같은 연산자도 직접 구현하거나 `derive()`를 이용해 요청해야 함.

## Pattern
Rust에서의 패턴은 Haskell, Erlang, Elixir 등에서 사용되는 패턴과 같음. 필요한 거의 대부분의 장소에서 패턴과 패턴 매칭을 자유롭게 사용할 수 있음. Elixir만큼은 아니더라도 왠만한 상용 언어들에 비해 괄목할만한 수준의 패턴 매칭을 언어차원에서 지원.

참고로, enum의 튜플형 베리언트나 구조체형 베리언트에서 안에 있는 값에 접근하는 유일한 방법은 패턴 매칭.

### 동작 방식
패턴 매칭은 값과 패턴을 똑같이 맞춤. 맞추는 과정에서 패턴에 식별자가 존재하면, 이때 식별자는 지역변수가 되고 이의 값은 패턴과 패턴 매칭 중인 값이 최대한 일치하는 방향으로 결정되며 값이 이동하거나 복사됨.

패턴과 값이 완전히 일치할 수 있으면 매칭 성공이고 그렇지 않으면 실패.

### 용처
- 바인딩 연산자(`=`) : 부인할 수 있는 패턴에 대해서는 `let ... else`를 사용해야만 함(`let`만 쓰면 안 됨).
- 함수 : 함수의 오버로딩을 지원하지는 않기 때문에 제한적.
- 클로저 : 복사본이 필요한데 레퍼런스를 넘기는 상황에서 유용함.
- `for` 표현식 : `for`과 `in` 사이에 단순한 식별자 뿐만 아니라 패턴도 넣을 수 있음.
- `match` 표현식 : 가드를 사용할 수 있는 유일한 용처.
- `if let` 표현식
- `while let` 표현식

**부인할 수 없는 패턴** : 반드시 매칭되는 패턴. 예: `Point3d { x, y, z }`, `(x, y)` 등

**부인할 수 있는 패턴** : 매칭되지 않을 수도 있는 패턴. 예: `Ok(v)`, `'0'..='9'` 등

**부인할 수 없는 패턴만 사용할 수 있는 곳** : 함수의 인수, 클로저의 인수, `for` 뒤

### 종류
책 282~283 표

표에 여러 종류의 패턴이 있는데 이들 패턴은 이들 중 하나만 써야되는 것은 아님. 패턴 안에 이와 다른 종류의 패턴을 넣을 수도 있음.

### 주의
`(x, x) = (1, 1)`과 같은 매칭의 경우, x에 1이 바인딩되며 성공할 것 같지만, Rust는 `x`가 2번 이상 바인딩되었다면 에러를 발생시킴 (참고로 유사한 코드를 작성했을 때 Haskell은 에러, Elixir, Erlang은 성공).

Elixir는 pin 연산자를 지원해서 패턴 내에서 식별자를 바인딩 대상뿐만 아니라 값으로도 사용할 수 있지만, Rust는 pin 연산자를 지원하지 않기 때문에 식별자를 패턴에 값으로 이용하려면 가드를 사용해야 됨(const는 예외).

`..`은 구조체 패턴에서와 슬라이스 패턴에서의 쓰임이 다름. 구조체 패턴에서는 다른 필드를 무시하겠다는 의미고, 슬라이스 패턴에서는 남은 요소를 모두 매칭시킨다는 의미. 단순하게 사용하면 큰 차이가 없지만, 구조체 패턴에서는 `[h, t @ ..]`과 같은 형식의 패턴을 사용할 수 없음.

### 클래스와의 비교
**장점** : 단순성. 속도, 안전성, 코드량, 문서화 용이성 등 대부분의 측면에서 클래스보다 좋음.

**단점** : 유연성. 최종 사용자가 확장 또는 수정할 수 없음.