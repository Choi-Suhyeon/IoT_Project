<link rel="stylesheet" href="../style/style.css">

# 00. Data Type

## 0. 개요
### 특징
강타입, 정적 타입의 언어. 하지만, 타입 추론과 제네릭으로 인해 번거로움을 상당히 줄여줌. 아래 두 코드는 완벽히 같은 머신 코드를 생성.
```rust
fn build_vec() -> Vec<i16> {
    let mut v: Vec<i16> = Vec::<i16>::new();
    v.push(10i16);
    v.push(20i16);
    v
}
```
```rust
fn build_vec() -> Vec<i16> {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v
}
```

### 타입 별칭
C++의 `typedef`처럼 기존 타입을 위한 새 이름을 선언하는데 사용되는 `type` 키워드가 있음.
```rust
type Bytes = Vec<u8>;

fn main() {
    let sample: Bytes = vec![1, 2, 3, 4, 5];

    println!("{:?}", sample);
}
```

## 1. 타입 요약
56page 표

rust 문서를 보게 되면 상수나 메서드 등 다양한 애들을 볼 수 있는데 메서드 중에서 self를 받는 애들이 있고 안 받는 애들이 있음. 받는 애들은 `a.method()`처럼 호출해도 되고 아니면 `self`에 직접 넘겨서 `i32::method(a)`와 같이 타입과 함께 호출해도 됨. 하지만 `self`를 받지 않는 아이들은 `a.method()`처럼 호출하면 안 됨.

## 2. 수치 타입
### 2.0. 기본 정보
**타입 표기** : <해석><크기> (기본적인 의미나 개념은 C와 같음 (모르면 컴퓨터 구조론 참고))
- 해석 : u(unsigned int), i(signed int), f(float)
- 크기 : bit 단위. 8, 16, 32, 64, 128, size(f 뒤에는 32 또는 64만 가능)

**타입 크기** : 타입 표기에서 표기된 크기와 같음. `isize`, `usize`는 모두 머신 워드 크기.

**타입 형태** : 각 타입에서 설명.

**타입 설명** : 정수 또는 부동소수점 수를 표현하는 타입.

### 2.1. 특징 및 부가 정보
**타입 접미사** : 타입을 숫자 리터럴 뒤에 붙여 리터럴의 타입을 명시.
- 생략 시 결정적 단서가 없으면 결정을 미룸. 정수는 `i32`, 부동소수점 수는 `f64`가 후보군에 있으면 이를 타입으로 결정하고 없다면 에러.
- 해당 리터럴에 대한 메서드를 호출하는 경우 타입이 명시가 안 되면 메서드를 결정할 수 없으므로 `i32`나 `f64`의 메서드를 사용하는 것이 아닌 에러.

**숫자 사이 언더스코어** : 숫자 중간에 언더스코어(_)를 넣어 숫자의 가독성을 높이거나 접두사 또는 접미사와 숫자를 분리할 수 있음.
- 주의할 점 : 어느 곳에 위치한 숫자던 언더스코어로 끝나는 것은 되지만, 시작하는 것은 안 됨.
```rust
fn main() {
    let a = 1_23_.45_6_e+_1_2_f64;
    let b = 0x_ff_ff_ff_ff_u32;

    println!("{}\n{}", a, b);
}

/* 실행 결과
123456000000000
4294967295
*/
```

### 2.2. 정수 타입
**진법 접두사** : `0x`, `0o`, `0b`를 말함. 접두사의 알파벳(x, o, b)은 소문자로만 작성할 수 있음.

**문자와의 관계** : C는 `char`로 문자도 표현 가능하고 1바이트 부호 있는 정수도 표현 가능하지만, Rust에서 `char`는 `u8`도 `u32`도 아님. 단, byte literal을 통해 `b'A'`와 같은 식으로 표현 가능하며 이는 `65u8`과 완전히 동일한 값.
- byte literal 유의 사항 :
    - 아스키 문자만 올 수 있음.
    - 문자 타입에서 이스케이프 시퀀스로 사용하는 것들은 똑같이 이스케이프 시퀀스로 사용해야 함.
    - `\u{HHHHHH}` 형태의 이스케이프 시퀀스는 사용 불가.

**크기와 범위** : C에서는 표현에 필요한 byte의 크기만 타입의 크기를 넘어가지 않으면 비트열 자체는 에러 없이 그대로 메모리에 들어감(설사 넘어가더라도 잘리고 들어감). 하지만 Rust는 표현에 필요한 byte의 크기를 넘어가지 않더라도 숫자가 표현 가능한 범위를 넘어서면 에러가 발생.

C :
```c
#include <stdio.h>

int main(void) {
    char a = 0xFF;

    printf("%d\n", a);

    return 0;
}

// 실행 결과 >> -1
```
Rust :
```rust
fn main() {
    let a: i8 = 0xFF;

    println!("{}", a);
}

// 실행 결과 >> error: literal out of range for `i8`
```

만약, 이것이 의도된 것이면, `#![allow(overflowing_literals)]`를 붙여야 함.

**checked, wrapping, saturating, overflowing 접두사** : 기본적인 연산은 오버플로우가 발생하면 디버그 빌드에서는 패닉, 릴리즈 빌드에서는 순환임. 아래 접두사들은 메 서드 앞에 붙어 빌드와 상관 없이 보다 명확한 동작 또는 추가적인 동작을 추가로 갖음.
- `checked_` : 연산의 결과를 Option에 담아서 반환함. 수학적으로 옳은 결과가 주어진 타입으로 표현 가능하면 `Some(v)`, 아니면 `None`.
- `wrapping_` : 수학적으로 옳은 결과의 비트열을 주어진 타입의 크기로 잘라서 해석함. 단, 비트별 자리 이동 연산의 경우 주어진 타입의 크기 내에서 순환.
- `overflowing_` : `wrapping_` 결과와 함께 overflow 발생 여부를 나타내는 bool 타입 값도 반환. 즉, 반환은 `(result, overflowed)` 형태의 tuple임.
- `saturating_` : 수학적으로 옳은 결과에 가장 가까운 주어진 타입 내의 값을 반환.

| methods | `checked_` | `wrapping_` | `overflowing_` | `saturating_` |
| :--- | :---: | :---: | :---: | :---: |
| `abs` | O | O | O | O |
| `add` | O | O | O | O |
| `add_unsigned` | O | O | O | O |
| `div` | O | O | O | O |
| `div_euclid` | O | O | O | O |
| `mul` | O | O | O | O |
| `neg` | O | O | O | O |
| `pow` | O | O | O | O |
| `sub` | O | O | O | O |
| `sub_unsigned` | O | O | O | O |
| `rem` | O | O | O | X |
| `rem_euclid` | O | O | O | X |
| `shl` | O | O | O | X |
| `shr` | O | O | O | X |
| `ilog` | O | X | X | X |
| `ilog10` | O | X | X | X |
| `ilog2` | O | X | X | X |
| `next_multiple_of` | O | X | X | X |

### 2.3. 부동소수점 타입
**리터럴의 형태와 생략** : 지수는 생략 가능. 소수부도 생략 가능하나, 만약 뒤에 지수 또는 타입 접미사가 오는 경우 생략 불가.

리터럴 형태 : `31415.92e-4f64`
- `31415` : 정수부
- `92` : 소수부
- `e-4` : 지수 (e를 E로 작성 가능)
- `f64` : 타입 접미사

## 3. bool 타입
### 3.0. 기본 정보
**타입 표기** : bool

**타입 크기** : 8bit

**타입 형태** : `true`, `false`

**타입 설명** : 참 또는 거짓을 표현하는 타입.

### 3.1. 특징 및 부가 정보
C의 경우 문자, 숫자, 포인터를 암묵적으로 bool 값으로 이용했고, Python은 문자열, 리스트, 딕셔너리 등 또한 bool 문맥에 사용할 수 있었음. 하지만, Rust는 Haskell이나 Go처럼 이를 엄격히 금지하며, 논리 연산자 또한 두 피연산자 모두 bool 타입의 값이어야 함.

## 4. 튜플 타입
### 4.0. 기본 정보
**타입 표기** : `(&str, i32)` 🠔 담고 있는 요소들의 자료형을 표시.
- `i64`나 `bool`처럼 튜플이라는 형태 전체를 표현하는 타입은 없음.
- 만약 하나의 값만을 갖는 튜플 타입을 표기할 때는 Python처럼 `(&str,)` 작성해 단순한 괄호 표현식과 구별해야만 함.

**타입 크기** : (추정) 8byte보다 크기가 작으면 해당 크기로 표현. 크면 8byte를 단위로 각 단위가 넘치지 않게 최대한 넣음. 예를 들어, 6byte까지 채워지고 다음 마지막  요소가 4byte면 전체 크기는 10byte나 16byte가 아니라 12byte.

**타입 형태** : `("Korea", 1945)`

**타입 설명** : 다양한 타입의 값들을 모아 묶은 요소 간 순서가 존재하는 타입. 아래는 여러 사용 상황 중 2가지 예시.
1. 함수가 2개 이상의 값을 반환할 때.
1. 순서가 의미를 갖는 간단한 구조체처럼 사용할 때 (예: 그래프의 순서쌍).
### 4.1. 특징 및 부가 정보
**제로 튜플** : `()`. unit type으로도 부름. 딱히 전달할 만한 의미 있는 값이 존재하지 않음에도 불구하고 맥락상 타입이 필요한 경우에 사용.
```rust
fn swap<T>(x: &mut T, y: &mut T) -> (); // 이럴 경우 보통 반환 타입 생략이 일반적.
fn write_image(filename: &str, pixels: &[u8], bounds: (usize, usize)) -> Result<(), std::io::Error>; // 반환 타입 의미 : 성공하면 아무 값도 반환하지 않겠지만, 실패하면 std::io::Error값을 반환하겠다.
```

**요소 접근** : `t.0`이나 `t.1`처럼 상수로 된 색인만 사용 가능. `t.i` 또는 `t[i]`로는 접근 불가.

## 5. 포인터 타입
### 5.0. 기본 정보
// TODO : 소유와 이동, 레퍼런스까지 보고 부족한 내용 채우기.

**타입 표기** :
- 레퍼런스 :
    - `&T` : 참조 값 변경이 불허된 공유된 레퍼런스
    - `&mut T` : 참조 값 변경이 허가된 배타적 레퍼런스
- 박스 : `Box<T>`
- 원시 포인터 : `*mut T`, `*const T`

**타입 크기** : 머신 워드 크기

**타입 형태** : 메모리 주소 (예: `&a`)

**타입 설명** : 메모리 주소를 저장하는 타입.
### 5.1. 특징 및 부가 정보
**배경** : Java는 물리적으로 한 객체가 다른 객체를 포함하는 것이 불가능(예: `class Rectangle`이 `Vector2D upperLeft`를 필드로 갖을 때, `upperLeft`는 별도로 생성되 는 또 다른 `Vector2D` 객체의 레퍼런스). 하지만, Rust는 할당을 최소화 하도록 설계돼 값은 기본적으로 스택에 빈틈 없이 배치됨. 이 때문에, 다른 값을 가리키는 값이 필요할 때는 명시적으로 포인터를 사용해야 함.

**참조와 역참조** : C에서와 마찬가지로 `&`, `*`을 사용.
- `&` : `&x`는 `x`대한 참조를 생성. '`x`에 대한 레퍼런스를 빌려온다'고 표현.
- `*` : `*r`은 `r`이 가리키는 공간의 값을 가져옴.

### 5.2. 레퍼런스
이미 존재하는 공간(즉, 수명이 다하지 않은 변수에 바인딩 된 공간)에 대한 참조를 저장. C의 포인터와 마찬가지로 레퍼런스가 수명을 다해도 가리키고 있던 공간이 해제되지는 않음. 다만, 가리키고 있던 공간보다 더 오래 생존할 수는 없음.

**C/C++에서의 포인터와의 차이** :
- `NULL`(C)이나 `nullptr`(C++)이 존재하지 않음. 따라서 적어도 안전한 공간에서는 레퍼런스가 절대 null이 될 수 없음.
- 참조 공간의 소유권과 수명을 추적. dangling pointer나 double free 등의 실수들이 컴파일 시점에 배제됨.

**`&T` vs `&mut T`** :
- `&T` : C의 `const T *`처럼 참조 값을 수정할 수 없음. 대신 공유된 레퍼런스.
- `&mut T` : C의 `T *`처럼 참조 값을 수정할 수 있음(따라서, 불변 변수에 대한 참조는 얘로 불가능). 대신 레퍼런스가 존재하는 동안은 같은 공간을 참조하는 다른 레퍼런스를 가질 수 없음.
> Single Writer Or Multiple Reader

Rust는 레퍼런스를 통해 위 규칙을 구현한다. 해석하면, 값을 저장하고 있는 한 공간에 대해 '값을 읽고 쓸 수 있는 상태' 또는 '여러 리더끼리 공유할 수 있는 상태' 둘 중  하나의 상태만 가능해야 한다는 것이다.
```rust
fn main() {
    let mut a = 4;
    let b = &a;
    let c = &a; // read-only는 여러 개가 가능함.

    a += 5; // error : mut라 하더라도 이미 b와 c에서 read-only로 빌려갔기 때문에 값 변경이 안 됨.

    println!("{} {} {}", a, b, c);
}
```

### 5.3. 박스
메모리의 heap공간에 값을 할당하는 방법 중 하나. heap에 새로운 공간을 할당하고 값을 넣는 형태. 특정 heap공간을 가리키는 박스가 수명을 다하는 즉시 해당 heap공간도 해제 (단, 반환 등의 이유로 이미 이동된 경우는 예외).

**박스 만드는 방법**
```rust
let t = (12, "eggs");
let b = Box::new(t); // 튜플을 heap에 할당.
```
```rust
fn main() {
    let mut a = 4;
    let b = (&mut a,); // a에서 b로 '이동'이 발생. writer는 하나여야만 함.
    let c = Box::new(b); // 같은 이유로 여기서도 b에서 c로 '이동'이 발생.

    println!("{} {}", b.0, (*c).0); // error: borrow of moved value: `b`
}
```

### 5.4. 원시 포인터

## 6. 배열 타입
### 6.0. 기본 정보
**타입 표기** : `[T; N]`
- T : 배열에 담을 요소의 타입. 배열은 튜플과 다르게 서로 다른 타입을 하나에 담는 것이 불가능.
- N : `usize`타입의 요소 개수. 요소 개수는 배열의 일부이며, 컴파일 타임에 결정되어야 함. 따라서 배열 크기의 확장 또는 축소 불가능, N은 상수 (즉, 리터럴이거나, `const`로 정의된 상수여야 함).

**타입 크기** : `std::mem::size_of<T>()` $\times$ `N`. stack에 연속적으로 저장됨.

**타입 형태** : Rust에서는 초기화 되지 않은 배열 요소란 존재할 수 없음. 따라서, C의 복잡한 초기화 문법(지정 초기화, 배열 크기 선언 여부, 크기와 실제 요소 개수 차이에서 오는 동작 차이 ...)이 없음.
- 서로 다른 값으로 초기화 : `let a: [bool; 5] = [true, false, false, true, false]` 
- 하나의 값만으로 초기화 : `let b: [bool; 5] = [false; 5]` 이때도 뒤의 `5` 자리에 변수를 쓸 수는 없음.

**타입 설명** : 튜플과 마찬가지로 타입에 크기가 고정되며, stack에 연속적으로 저장됨. 다만, 튜플은 여러 타입을 담을 수 있지만, 배열은 하나의 타입만 담을 수 있음.

### 6.1. 특징 및 부가 정보
**요소 참조** : 튜플과는 다르게 `a[i]`의 형태로 사용. 이러한 방식은 벡터와 슬라이스에서도 동일하게 적용됨. 여타 대부분의 언어(R, Julia 등 제외)와 마찬가지로 첫 요소는 `a[0]`, 마지막 요소는 `a[a.len() - 1]`. 주의할 점은 아래와 같음.
- `i`는 `usize`타입이어야만 함.
- C와는 달리 `i`가 항상 범위 안에 존재하는지 확인 (길이가 0인 배열에 인덱스로 접근하면 항상 패닉).

## 7. 벡터 타입
### 7.0. 기본 정보
**타입 표기** : `Vec<T>`. `T`는 벡터에 담을 요소의 타입.

**타입 크기** : `std::mem::size_of<usize>()` $\times\ 3\ +\ $`std::mem::size_of<T>()` $\times$ `v.capacity()`

**타입 형태** : 
- 빈 벡터 : `Vec::new()`, `Vec::<bool>::new()` 🠔 타입 명시, `Vec::with_capacity(10)` 🠔 용량이 주어진 값인 빈 벡터를 만듬.
- 벡터 매크로 : `vec![2, 3, 5, 7]`, `vec![0u8; 10]`

**타입 설명** : 크기 조절이 가능한 배열. 모든 요소를 heap에 저장.

### 7.1. 특징 및 부가 정보
**내부 구성** : 3개의 정보(heap에 할당된 공간을 가리키는 포인터, 개수, 용량)는 stack에 저장되고 heap에는 배열과 비슷하게 요소들이 연속된 공간에 저장됨.
- 개수 vs. 용량 :
    - 개수 : 현재 담고 있는 요소의 수. `v.len()`으로 확인 가능.
    - 용량 : 재할당 없이 담을 수 있는 요소의 최대 개수. `v.capacity()`로 확인 가능.
- 주의할 점 : 예를 들어, heap에 8byte를 할당했다고 해서 꼭 8byte만 할당되는 것은 아님. 하나의 청크는 헤더와 데이터로 구성되고 헤더에는 청크 관리를 위한 정보가 있음. draemhack에서 공부할 때 16byte였던 것으로 기억하는데 지금은 어떤지 모르겠음.

## 8. 슬라이스 타입
### 8.0. 기본 정보
**타입 표기** : `[T]`
- 길이 제한이 슬라이스는 없기 때문에, 변수에 바인딩 또는 함수에 인수로 전달 불가. 항상 레퍼런스로 저장 또는 전달 (`&[T]` 또는 `&mut [T]`).

**타입 크기** : 2 $\times$ `std::mem::size_of<usize>()`

**타입 형태** : 리터럴과 같은 형태가 있다기 보다는 배열이나 벡터를 통해 만들 수 있음.
- 레퍼런스 : `let s: &[f64] = &a;` 🠔 타입 명시 안 하면 슬라이스가 안 됨.
- 범위 인덱스 : `let s = &a[1..7]`, `let s = &a[..]` 🠔 전범위 슬라이싱.

**타입 설명** : 첫 요소를 가리키는 포인터와 요소의 개수로 구성된 팻 포인터(fat pointer).

### 8.1. 특징 및 부가 정보
**레퍼런스 vs. 슬라이스** : 
- 레퍼런스 : 단일 값을 가리키는 소유권 없는 포인터.
- 슬라이스 : 메모리 상의 연속된 여러 값을 가리키는 소유권 없는 포인터.

## 9. 문자 타입
### 9.0. 기본 정보
**타입 표기** : `char`

**타입 크기** : 32bit

**타입 형태** : `'A'`

**타입 설명** : 문자 하나만을 표현하는 타입.

### 9.1. 특징 및 부가 정보
작은따옴표, 백슬래시, 개행, 캐리지 리턴, 탭, 널문자는 이스케이프 시퀀스로 작성해야 함.

만약 문자가 ASCII 문자 집합에 속한다면, 해당 문자를 `'\xHH'`로 표현 가능.

모든 유니코드 문자는 `'\u{HHHHHH}'`로 표현 가능. 여기서 중괄호 내 `HHHHHH`는 작성 가능한 16진수의 최대 자리수를 나타내며 저것보다 적어도 됨.

char 내의 문자는 0x0000~0xD7FF 또는 0xE000~0x10FFFF 사이의 유니코드 포인트를 가짐. surrogate pair(0xD800~0xDFFF) 사이 또는 0x10FFFF보다 큰 값을 갖는 일은 없음.

## A. 문자열 슬라이스 타입
### A.0. 기본 정보
**타입 표기** :
- 문자열 : `str`
- 문자열 슬라이스 `&str`

**타입 크기** : 2 $\times$ `std::mem::size_of<usize>()`

**타입 형태** : 그렇다 할 형태는 없음.

**타입 설명** : 문자열에 대한 슬라이스 타입.

### A.1. 특징 및 부가 정보
**문자열 리터럴** :
- 개념 : 읽기 전용 메모리에 저장되는 수정이 불가한 문자열. UTF-8을 사용해 저장하기 때문에 각 문자가 모두 동일한 크기를 갖지 않을 수 있음.
- 형태 :  `"blah blah"`
    - 이스케이프 시퀀스 사용 가능.
    - 여러줄 문자열을 쓸 수 있음.
    - 여러줄 문자열 뒤에 `\`를 붙이면 개행과 선행 공백이 삭제됨.
    - 원시 문자열 : 접두사 `r`을 붙여 만듬. 원시 문자열은 이 안에 있는 백슬래시와 공백 문자는 모두 그대로 출력됨. 문자열 앞 뒤로 해시를 원하는 만큼 붙여도 됨 (단, 개수만 같게 해서).
    - 바이트 문자열 : 접두사 `b`를 붙여 만듬. 유니코드 텍스트가 아니라 `u8` 배열에 대한 레퍼런스 형태.
    - 원시 바이트 문자열 : 접두사 `br`로 시작.

**문자열 길이** : 
- `.len()` : byte 단위로 측정한 문자열의 길이.
- `.chars().count()` : 문자의 개수.

## B. String 타입
### B.0. 기본 정보
**타입 표기** : `String`

**타입 크기** : `std::mem::size_of<usize>()` $\times\ 3\ +\ $`std::mem::size_of<T>()` $\times$ `v.capacity()`

**타입 형태** : 그렇다 할 형태는 없음. 벡터 만드는 식(`::new()`, `::with_capacity()` ...)으로 만들거나 `"blah blah".to_string()` 등으로 String을 만들 수 있음.

**타입 설명** : 벡터와 유사. 힙을 할당받아 그곳에 문자열을 저장.

### B.1. 특징 및 부가 정보
**유사 문자열 타입**
| 상황 | 유사 문자열 타입 |
| :--- | :--- |
| 파일 이름 | `std::path::PathBuf`, `&Path` |
| UTF-8로 인코딩 안 되는 바이너리 | `Vec<u8>`, `&[u8] ` 🠔 애초에 문자열 자체가 UTF-8로 인코딩 된 문자들을 저장하는 특수한 슬라이스 또는 벡터이기 때문에 가능. |
| 환경 변수 이름, 명령줄 인수 | `OsString`, `&OsStr` |
| C 라이브러리와 연동 | `std::ffi::CString`, `&CStr` |