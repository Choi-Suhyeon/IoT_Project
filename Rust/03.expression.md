# 03. Expression

## 개요
### Expression-oriented Programming Language

언어의 거의 모든 구성이 표현식으로 이루어져, 값을 산출하는 프로그래밍 언어를 말함. 다만, 매크로 정의, 전처리기 명령어, 선언 등은 안에서도 표현식이 아닌 문으로 처리하는 언어들이 많음.

**속하는 언어들** : 
- 모든 함수형 언어 : Lisp, ML, Erlang ...
- 그 외 : Rust, Scala, Kotlin, ...

중요한 것은 Rust가 expression-oriented programming language라는 사실.

### 우선순위와 결합성

153page부터 있는 표에 너무 정리가 잘 돼 있음.

## 블록과 세미콜론
### 블록
**개념** : 중괄호(`{}`)로 둘러쌓인 코드.

**반환 값** : 마지막 표현식의 값. 마지막 줄이 세미콜론으로 끝나면 빈 튜플(`()`)을 반환.

```rust
let display_name = match post.author() {
    Some(v) => v.name(),
    None    => {
        let network_info = post.get_network_metadata()?;
        let ip           = network_info.client_address();

        ip.to_string() // 얘가 반환 값.
    },
};
```

세미콜론은 단순히 문의 끝을 나타내는 것 뿐만 아니라 블록 내에서는 반환 값의 유무 또한 나타냄. 그렇기 때문에 세미콜론이 필요한 상황에서 세미콜론을 작성하지 않으면 컴파일러가 대신 채워주지 않고 에러를 발생시킴. 비슷하게 표현식으로 써야하는데 세미콜론으로 끝내 문으로 만들어 버리면 에러가 발생. 몰론 빈 튜플(`()`)을 반환해야 되는 상황에서 세미콜론으로 끝내는 것은 됨.

## 선언문
**개념** : Rust에 존재하는 몇 안 되는 문 중 하나. `let`, `struct`, `fn`, `use`, `mod` 등의 키워드를 이용하며, 식별자와 형식 등에 대한 정보를 지정.

중요한 점은 블록은 선언문을 표함할 수 있음. `let` 선언문 뿐만 아니라 `fn` 선언문, 심지어 모듈 선언을 위한 `mod` 선언문 또한 포함할 수 있음.

**let 선언문** : 
- 구문 : `let pattern: type = expr;` 기본적인 형식이 이렇다는 것이지 이게 전부는 아님.
- 생략 : 타입은 생략할 수도 있음. 생략 시 컴파일러가 추론. 추론을 할 수 없는 상황이면 에러.
- 특징 : 
    - `mut`로 선언하지 않아도, 선언만 먼저 하고 초기화는 나중에 진행할 수도 있음. 당연히 `mut`로 선언하지 않았으면 사용 전 최초 한 번만 초기화 가능. 초기화 전에 사용하면 에러.
    - 패턴 매칭 : Rust는 많은 부분에서 패턴 매칭을 활용할 수 있는데 `let`은 가장 대표적으로 패턴 매칭을 사용하는 곳임. 패턴 매칭은 간단하게 왼쪽과 오른쪽을 똑같게 맞춰주는 것이라 생각하면 됨.
    - 섀도잉 : 이전 변수명과 같은 이름의 변수명을 선언해 자신이 속한 블록이 끝날 때까지 기존 변수를 덮음. 기존 변수에는 섀도잉 시점부터 블록이 끝날 때까지 접근 할 수 없음. 같은 블록 내에서 섀도잉이 발생하면 기존 변수는 더 이상 사용할 수 없음.