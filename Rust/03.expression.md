# 03. Expression

## 개요
### Expression-oriented Programming Language

언어의 거의 모든 구성이 표현식으로 이루어져, 값을 산출하는 프로그래밍 언어를 말함. 다만, 매크로 정의, 전처리기 명령어, 선언 등은 안에서도 표현식이 아닌 문으로 처리하는 언어들이 많음.

**속하는 언어들** : 
- 모든 함수형 언어 : Lisp, ML, Erlang ...
- 그 외 : Rust, Scala, Kotlin, ...

중요한 것은 Rust가 expression-oriented programming language라는 사실.

대부분이 표현식이기 때문에 이 글을 정리한 사람의 개인적인 생각엔 자유도가 그렇지 않은 언어에 비해 상당히 높아, 복잡하게 작성하려면 한 없이 복잡하게 작성할 수 있을 것 같음. 예를 들어 `loop`의 결과와 `if`의 결과를 비교해서 비교 결과에 따라 `if`를 수행하는 등.
```rust
use std::io;

fn main() {
    let mut raw_input = String::new();

    io::stdin().read_line(&mut raw_input).expect("failed to read");

    let input_i32 = raw_input.trim().parse::<i32>().unwrap();

    println!("{}", if if input_i32 > 100 { 100 } else { 0 } < loop { break input_i32; } { "too big" } else { "good" });
}
```

### 우선순위와 결합성

153page부터 있는 표에 너무 정리가 잘 돼 있음.

## 블록과 세미콜론
### 블록
**개념** : 중괄호(`{}`)로 둘러쌓인 코드.

**반환 값** : 마지막 표현식의 값. 마지막 줄이 세미콜론으로 끝나면 빈 튜플(`()`)을 반환.

```rust
let display_name = match post.author() {
    Some(v) => v.name(),
    None    => {
        let network_info = post.get_network_metadata()?;
        let ip           = network_info.client_address();

        ip.to_string() // 얘가 반환 값.
    },
};
```

세미콜론은 단순히 문의 끝을 나타내는 것 뿐만 아니라 블록 내에서는 반환 값의 유무 또한 나타냄. 그렇기 때문에 세미콜론이 필요한 상황에서 세미콜론을 작성하지 않으면 컴파일러가 대신 채워주지 않고 에러를 발생시킴. 비슷하게 표현식으로 써야하는데 세미콜론으로 끝내 문으로 만들어 버리면 에러가 발생. 몰론 빈 튜플(`()`)을 반환해야 되는 상황에서 세미콜론으로 끝내는 것은 됨.

## 선언문
**개념** : Rust에 존재하는 몇 안 되는 문 중 하나. `let`, `struct`, `fn`, `use`, `mod` 등의 키워드를 이용하며, 식별자와 형식 등에 대한 정보를 지정.

중요한 점은 블록은 선언문을 표함할 수 있음. `let` 선언문 뿐만 아니라 `fn` 선언문, 심지어 모듈 선언을 위한 `mod` 선언문 또한 포함할 수 있음.

**let 선언문** : 
- 구문 : `let pattern: type = expr;` 기본적인 형식이 이렇다는 것이지 이게 전부는 아님.
- 생략 : 타입은 생략할 수도 있음. 생략 시 컴파일러가 추론. 추론을 할 수 없는 상황이면 에러.
- 특징 : 
    - `mut`로 선언하지 않아도, 선언만 먼저 하고 초기화는 나중에 진행할 수도 있음. 당연히 `mut`로 선언하지 않았으면 사용 전 최초 한 번만 초기화 가능. 초기화 전에 사용하면 에러.
    - 패턴 매칭 : Rust는 많은 부분에서 패턴 매칭을 활용할 수 있는데 `let`은 가장 대표적으로 패턴 매칭을 사용하는 곳임. 패턴 매칭은 간단하게 왼쪽과 오른쪽을 똑같게 맞춰주는 것이라 생각하면 됨.
        - `let`이 패턴 매칭에 실패할 수도 있는 상황에서는 `let` 선언문 뒤에(세미콜론 바로 앞에) `else { ... }`을 붙여서 실패했을 때의 처리를 해야만 함.
    - 섀도잉 : 이전 변수명과 같은 이름의 변수명을 선언해 자신이 속한 블록이 끝날 때까지 기존 변수를 덮음. 기존 변수에는 섀도잉 시점부터 블록이 끝날 때까지 접근 할 수 없음. 같은 블록 내에서 섀도잉이 발생하면 기존 변수는 더 이상 사용할 수 없음.

## if & match 표현식
작게는 `if`, `if let`, `match` 3가지가 존재. 간단한 설명은 아래와 같음.
- `if` : 조건을 비교(즉, bool 타입의 표현식을 통해 비교).
- `if let` : 간단한 패턴 매칭을 지원 (`if`보다는 `match`에 가까움).
- `match` : 패턴 매칭을 지원. C언어의 `switch case`와 비슷해보일 수 있지만, 근본적으로 `switch case`는 문이며, 이를 차치하더라도 월등히 강력함. Haskell의 `case of`와 통사론적, 의미론적 측면에서 상당히 유사.

### if 표현식
```rust
if cond1 { body1 }
else if cond2 { body2 }
else { body_n }
```
- 조건식은 반드시 bool 타입의 표현식이어야 함. 암묵적 형변환은 당연히 존재하지 않음. 명시적으로도 bool 타입으로는 형변환 불가.
- 조건식을 소괄호 내에 둘 필요가 없음. 단, 바디는 반드시 중괄호 내에 둬야 함.
- 표현식이라는 이름에서도 알 수 있듯, 값을 반환함. 단, 각 블록은 반드시 동일 타입의 값을 반환해야 함.
- `else`는 생략할 수 있음. 생략하면 빈 `else`문이 존재하는 것처럼 작동. 비어있으면 빈 튜플을 반환하므로 `if`도 빈 튜플을 반환해야 함. 사실상 문과 다를 것이 없음.


### if let 표현식
```rust
if let pattern = expr { body1 }
else { body2 }
```
`if`와 비슷한 형태를 하고 있지만, bool 타입의 표현식을 평가해 바디를 실행시키는 것이 아닌 패턴 매칭을 해 매칭에 성공하면 `body1`을 실패하면 `body2`를 실행.

`if let` 또한 여러개의 `else if`를 중간에 가질 수 있으며, `if let`을 쓰던 중에 `if`를 사용하거나 `if`를 사용하던 중에 `if let`을 사용할 수 있음. 간단하게, `if` 키워드와 `{ body }` 사이에는 bool 타입의 표현식 또는 `let` 키워드로 시작하는 바인딩이 들어간다고 기억하는 것이 편할 것 같음.

`if let`이 `match`의 축약 표현.
```rust
match expr = {
    pattern => { body1 }
    _ => { body2 }
}
```

### match 표현식
하나의 값을 여러 패턴에 매칭시켜 매칭된 패턴에 따라 실행해야될 때 사용됨. 패턴 매칭의 강력함은 일부 함수형 언어를 사용해봤다면 알 것이라 생각 (Haskell, Erlang, Elixir ...).
```rust
match value {
    pattern1 => expr1,
    pattern2 => expr2,
}
```
- 패턴 뒤 표현식이 블록일 경우 쉼표(`,`)는 생략 가능.
- 언더스코어(`_`)는 패턴 매칭 와일드 카드. 즉, 모든 패턴과 매칭됨. 따라서 가장 아래 있지 않으면 이것보다 아래 위치한 패턴에는 절대 값이 매칭될 수 없음.
- 입력될 수 있는 모든 경우의 값은 적어도 한 가지 패턴과 매칭이 되야 함. 그렇지 않으면 에러가 발생.
- 당연히, `if`, `if let`과 마찬가지로, 어떤 표현식이 실행되던 동일 타입의 값이 반환되어야 함.
- `pattern` 뒤에 guard 절을 붙일 수 있음 (guard를 붙일 수 있는 유일한 장소. guard를 let에도 붙이려면 guard crate를 사용해야 함). `if expr`의 형태. Haskell의 느낌보다는 Elixir의 느낌으로 guard가 붙음. 하나의 패턴에는 단 하나의 guard만 붙을 수 있고, 같은 패턴이라도 가드가 다르면 따로 나눠서 작성해야 함.