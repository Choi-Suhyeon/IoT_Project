<link rel="stylesheet" href="../style/style.css">

# 02. Reference

## 개요
### move의 문제점과 reference의 사용
move는 소유권이 이동한다는 큰 단점이 있음. 이동이 효율적인 경우도 있지만, 단순한 처리에서 나중에 다시 사용할 값에 대해 이동을 적용시키는 것은 코드 작성을 어렵게 만듬. 여기에 `.clone()`을 사용하는 것은 오히려 비효율.

그래서 레퍼런스가 있고 이는 **소유권을 갖지 않는(값에 대한 기존 소유권에 영향을 미치지 않는) 포인터**임. 하지만, 레퍼런스가 소유권을 갖지 않기 때문에 값을 책임지지 않고, 소유권을 갖고 있던 변수가 값을 드랍하면 레퍼런스는 그대로 댕글링 포인터가 됨. 때문에, Rust에서의 **레퍼런스는 참조 대상보다 오래 살 수 없으며 이 점을 코드에 명시해야 함**. 이런 연유로 Rust에서 레퍼런스를 만드는 것을 '빌려 온다'(borrow)고 표현.

### 레퍼런스 비교 : C++ vs. Rust
**공통점** : 두 언어에서 레퍼런스는 모두 머신 수준의 주소.

**차이점** : 

C++ :
- 레퍼런스가 암묵적으로 생성됨.
- 역참조 또한 암묵적으로 진행.
- 레퍼런스가 참조하는 대상을 변경할 수 없음.
```c++
int x = 10;
int & r = x; // 초기화는 암묵적으로 레퍼런스를 생성.

assert(r == 10); // r을 암묵적으로 역참조.

r = 20; // x에 20을 저장. r이 가리키는 대상은 x에서 변하지 않음.
```
Rust :
- 레퍼런스를 명시적으로 생성해야 함.
- 역참조 또한 명시적으로 진행해야 함.
- 레퍼런스가 참조하는 대상을 변경할 수 있음.
- 특정 상황에서는 암묵적인 차용 또는 역참조가 발생할 수 있음.
    - `.`연산자를 사용해 구조체의 멤버에 접근하는 경우, 암묵적인 차용과 역참조가 발생.
    - 비교연산자를 통해 비교할 때 암묵적 역참조 발생 (비교연산자의 피연산자들의 타입은 같아야 함).
    - 산술연산자는 한 수준에 한해 암묵적 역참조 발생. 이때 피연산자의 타입은 한 수준에 한해 갖지 않아도 됨 (`i32`와 `&i32`는 연산 가능).
```rust
fn main() {
    let x: i32 = 10;
    let y: i32 = 20;
    let mut r: &i32 = &x; // 연산자 &를 이용해 명시적으로 레퍼런스를 생성.

    assert_eq!(*r, 10); // 연산자 *를 이용해 명시적으로 레퍼런스를 역참조.

    r = &y; // r이 가리키는 대상 변경 가능 (r이 mut가 아니면 당연히 불가능).

    let mut z: i32 = 32;
    let s: &mut i32 = &mut z; // 가변 레퍼런스
    
    *s += 32; // z의 값을 갱신하기 위해 레퍼런스를 명시적으로 역참조.
    
    assert_eq!(*s, 64);
}
```

### 레퍼런스와 null
Rust에는 C의 `NULL`이나 C++의 `nullptr` 뿐만 아니라 레퍼런스를 위한 기본 초기값 또한 존재하지 않음. 정수 값을 레퍼런스로 변환할 수도 없음.

만약 C/C++에서처럼 null을 이용해 주소 값이 없는 상태를 나타내야만 하는 상황에서는 `Option<&T>`를 사용. 그럼 컴파일러는 머신 수준에서 `None`을 null 포인터로 `Some(r)`을 0이 아닌 주소로 표현. 효율적이면서도 Rust에서는 Option 값을 사용하기 전에 `None`인지를 반드시 확인해야 하므로 훨씬 안전.

### 레퍼런스와 유사한 특징을 갖는 Fat Pointer
Rust는 2가지 종류의 fat pointer(특정 값의 주소와 이의 값을 사용하는데 필요한 부가 정보를 같이 갖는 포인터)를 기본 제공. 
1. Slice Reference : 첫 요소를 가리키는 포인터와 요소 개수로 구성됨.
1. Trait Object : 11장에서 설명.

이들은 레퍼런스와 마찬가지로,
1. 참조 대상을 소유할 수 없음.
1. 참조 대상보다 오래 살 수 없음.
1. shared 또는 mutable로 사용할 수 있음.

## 레퍼런스의 사용
### 레퍼런스의 종류
레퍼런스의 종류에는 공유 레퍼런스(shared reference)와 가변 레퍼런스(mutable reference)가 존재.

레퍼런스와 관련된 유명한 규칙 중 하나는 'multiple readers or single writer'임. 이를 시행하기 위해 레퍼런스의 종류를 위와 같이 나눔.

**공유 레퍼런스** : 
- Copy 타입.
- 읽기 가능. 쓰기 불가.
- 동일 값을 참조하는 공유 레퍼런스의 수는 동시에 둘 이상 존재 가능.
- 참조 동안에 동일 값을 참조하는 가변 레퍼런스 생성 불가.

**가변 레퍼런스** : 
- Move 타입.
- 읽기 가능. 쓰기 가능.
- 참조 동안에 동일 값을 참조하는 가변 레퍼런스 사용 불가(공유 레퍼런스는 가능).
- 참조 동안에 동일 값을 참조하는 공유 레퍼런스 생성 가능.

책에서는 가변 레퍼런스의 참조 기간 동안에 값은 값을 참조하는 다른 모든 종류의 레퍼런스를 사용할 수 없다고 나오지만, 아래와 같은 코드는 잘만 돌아감.

```rust
fn main() {
    let mut a: i32 = 4;
    
    let b: &mut i32 = &mut a;
    let c: &i32     = &*b; // b가 참조하는 대상으로 역참조한 다음 이의 공유 레퍼런스를 빌려옴.

    println!("{b} {c}"); // 4 4
}
```

위의 규칙은 소유자에게도 똑같이 적용됨. 만약 소유자를 `let mut`로 선언했다 하더라도 공유 레퍼런스로 소유자에게서 값을 빌렸으면 소유자도 해당 레퍼런스가 수명을 다할때까지 값을 변경할 수 없음. 가변 레퍼런스로 빌리면 가변 레퍼런스의 수명이 끝날 때까지 소유자는 값에 접근도 못 함.

**값에 의한 전달 & 참조에 의한 전달** : 
- 값에 의한 전달(pass by value) : 함수에 인수로 넘길 때 소유권이 함께 넘어가거나 복사되어 넘어가는 경우.
- 참조에 의한 전달(pass by reference) : 함수에 인수로 넘길 때 레퍼런스가 넘어가는 경우.

**레퍼런스 사용 시 주의 사항** : 레퍼런스를 반복 처리할 때는 참조 대상의 각 필드에 대해서도 공유된 레퍼런스를 만들도록 정의됨.

### 레퍼런스의 레퍼런스
C/C++에서 다차원 포인터를 만들 듯 Rust에서도 레퍼런스의 레퍼런스를 만들 수 있음. 다만, 위에서도 잠깐 언급했듯이 `.`연산자는 레퍼런스가 최종적으로 가리키는 대상을 찾을 때까지 거듭해서 참조의 연결고리를 따라감. 즉, 최종적으로 가리키는 대상을 꿰뚫어 봄.
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let pnt = Point { x: 1000, y: 729 };
    let r   = &pnt;
    let rr  = &r;
    let rrr = &rr;

    assert_eq!(rrr.y, 729);
}
```

### 레퍼런스 비교
비교 연산자도 `.`연산자처럼 레퍼런스가 최종적으로 가리키는 대상을 꿰뚫어 봄. 다만, 레퍼런스 비교가 그렇다고 하더라도 두 피연산자의 타입은 반드시 일치해야 함.

레퍼런스를 비교할 때는 위에서 설명한 것처럼 최종적으로 가리키는 대상을 비교하기 때문에 두 레퍼런스가 같은 메모리를 가리키는지 확인하는 데는 무리가 있음. 이럴 때는 `std::ptr:eq()`를 사용. 그럼 레퍼런스가 담고 있는 주소를 비교.
```rust
fn main() {
    let x = 10;
    let y = 10;

    let rx = &x;
    let ry = &y;

    let rrx = &rx;
    let rry = &ry;

    // 최종 값 비교 vs. 담고 있는 주소 비교
    assert!(rx == ry); // 최종적으로 가리키는 값은 같음.
    assert!(!std::ptr::eq(rx, ry)); // rx와 ry가 담고 있는 주소는 다름.

    // 비교하려는 두 피연산자의 타입은 같아야 함. 아래는 그 방법.
    assert_eq!(&rx, rrx);
    assert_eq!(rx, *rrx);
    assert_eq!(&&x, rrx);
    // assert_eq!(rx, rrx); // error: can't compare `{integer}` with `&{integer}`
}
```

### 임의 표현식에 대한 레퍼런스
C/C++과는 다르게 Rust는 어떤 종류의 표현식이더라도 이에서 산출되는 값의 레퍼런스를 빌려올 수 있음.

**동작** : 표현식의 값을 저장할 익명 변수를 만들고 이에 대한 레퍼런스를 만듬.

**수명** : 
- `let`문에서 레퍼런스를 변수에 바로 바인딩하거나 바로 바인딩되는 구조체나 배열의 요소로 만들면 익명 변수의 수명을 `let`이 초기화하는 변수의 수명과 같도록 만듬.
- 위와 같은 상황이 아니라면, 레퍼런스의 바깥쪽 실행문이 끝날 때까지만 살아있게 됨.

```rust
fn factorial(n: usize) -> usize {
    (1..=n).product()
}

fn main() {
    let r = &factorial(6); // r과 수명을 같이 함.
    let a = 1;

    // 산술 연산은 레퍼런스를 한 단계는 꿰뚫어 볼 수 있음.
    // &1009는 println!이 끝날 때까지만 살아있음.
    println!("{}", r + a + &1009);

    // 실행 결과 : 1730
}
```

## 레퍼런스 안전성
### 지역변수 빌려 오기
지역 변수의 레퍼런스를 빌려 올 때는, 레퍼런스가 참조 대상보다 오래 생존하면 댕글링 포인터가 되어버리기 때문에, 레퍼런스를 해당 변수의 스코프 밖으로 가지고 나갈 수가 없음.

**수명(lifetime)** : 실행문, 표현식, 변수 스코프 등 프로그램에서 레퍼런스가 안전하게 쓰일 수 있는 구간을 의미하며, 컴파일 시점에만 존재하는 가상의 개념 (런타임 시점에서 레퍼런스는 그저 주소).

**제약 사항** : 아래 두 가지 제약 사항을 모두 지켜야 함. 여기에 관계되는 수명은 참조 대상의 수명, 레퍼런스의 수명, 레퍼런스를 담는 변수의 수명으로 세 가지.
1. 수명의 상한 : 참조 대상의 수명은 자신의 레퍼런스의 수명을 포함할 수 있어야 함.
1. 수명의 하한 : 레퍼런스의 타입이 이를 담는 레퍼런스 변수의 수명(초기화 되는 시점부터 마지막으로 사용되는 시점까지) 내내 유효해야 한다.

> 참조 대상의 수명 [ **레퍼런스의 수명** [ 레퍼런스를 담는 변수의 수명 [...] ] ]
- 레퍼런스를 담는 변수의 수명이라는 표현은 별로 적절하지는 않음. 위의 표현대로 '초기화 되는 시점부터 마지막으로 사용되는 시점까지 유효해야 함'이 더 맞는 표현. 즉, 레퍼런스를 담는 변수는 레퍼런스보다 오래 살 수도 있음. 하지만, 레퍼런스의 수명이 끝났는데 레퍼런스를 참조해 사용하면 컴파일 타임에서 에러가 발생.

```rust
fn main() {
    let r;
    {
        let x = 1;
        r = &x;
    }

    println!("{}", *r);

    // error : `x` does not live long enough
    // 참조 대상이 레퍼런스보다 수명을 완전히 포함하지 못 함.
}
```
```rust
fn read_from_stdin() -> String {
    let mut raw_input = String::new();

    io::stdin()
        .read_line(&mut raw_input)
        .expect("failed to read");

    raw_input
}

fn read_two_i32s() -> (i32, i32) {
    let mut mapped = read_from_stdin() // error : temporary value dropped while borrowed
        .trim()
        .split_whitespace()
        .map(|x| i32::from_str(x).expect("expected to input integer"));

    // 여기서도 사용을 하는데 값을 담고 있던 임시 변수가 위의 let이 끝나면 드랍이 됨.
    (mapped.next().unwrap(), mapped.next().unwrap())
}
```

### 함수와 레퍼런스
**함수의 매개변수로 전달받기** :

Rust는 수명 매개변수를 통해 <u>레퍼런스</u>(매개변수 아님)의 수명을 명시할 수 있음.
```rust
fn f<'a>(p: &'a i32) {} // "임의의 수명 'a에 대해" ... "매개변수 p는 수명이 'a인 i32의 레퍼런스를 받음" 정도로 읽으면 됨.
fn g(p: &'static i32) {} // 'static 수명이라고 부르며, static은 프로그램이 시작될 때 만들어져 프로그램 종료 시점까지 지속되는 값.
```

위 코드에서 수명 `'a`는 참조 대상의 수명에 포함되어야 함. 즉, 함수 `f`로 넘길 수 있는 레퍼런스는 중 가장 짧은 수명은 `f`의 호출 구간을 딱 맞게 애워싸는 수명.

함수의 시그니처만으로도 레퍼런스를 전역 변수에 담으려 하는지, 레퍼런스가 함수의 호출 구간보다 수명이 더 긴 곳에 보관될 일은 없는지 등을 알 수 있음.

**함수의 매개변수로 전달하기** : 

수명 매개변수가 함수의 시그니처에 명시돼 있더라도 호출할 때는 이를 언급할 필요가 없음.

```rust
fn h<'a>(p: &'a i32) { ... } // 매개변수 p가 함수의 호출구간보다 더 긴 수명을 가진 곳에 저장되지는 않는다는 것을 알 수 있음.

fn main() {
    let x = 10;
    g(&x); // &x에 대해 쓸 수 있는 가장 짧은 수명을 'a로 넘김.
}
```

위 코드에서 `'a`가 아니라 `'static`이면 컴파일 실패. 레퍼런스의 수명을 `'static`이라 명시했기 때문에 적어도 수명이 `'static`만큼은 되어야 하는데, x의 레퍼런스인 `&x`는 `x`보다 오래살면 안 되기 때문에 `'static`보다 수명이 짧음.

**함수에서 반환하기** :

Rust는 함수의 매개변수가 하나뿐이고 인수와 반환값의 타입이 모두 레퍼런스일 때, 이 둘은 동일한 수명을 소유할 것이라 가정함. 그렇지 않으면 직접 수명을 명시해야 됨.
```rust
// 아래처럼 수명 매개변수를 명시할 수 있지만, 위에서 설명한대로 두 레퍼런스의 수명이 갖다고 가정하기 때문에 생략이 일반적.
fn smallest(v: &[i32]) -> &i32 {
    let mut s = &v[0];

    for r in &v[1..] {
        if r < s { s = r };
    }

    s
}

// 위와 같은 가정이 없으므로 반드시 수명매개변수를 명시해야 함.
fn smallest2<'a>(v1: &'a[i32], v2: &'a [i32]) -> &'a i32 {
    let mut result = &v1[0];

    for i in &v1[1..] {
        if i < result { result = i; };
    }

    for i in v2 {
        if i < result { result = i; };
    }

    result
}

fn main() {
    let s;
    {
        let temp1 = [9, 4, 1, 0, 1, 4, 9];
        s = smallest(&temp1);
    }
    
    println!("{s}"); // error : &temp1는 temp1보다 오래 지속될 수 없고, s의 수명은 이의 마지막 사용 시점까지는 덮어야 하므로 이를 모두 만족하는 스코프는 존재하지 않음.

    let r;
    let temp2 = [3, 6, 1, -1, 9, 8, 1];
    {
        let temp3 = [4, 5, 1, 9, 2, 0];
        r = smallest2(&temp2, &temp3);
    }
    
    println!("{}", r); // error: smallest2의 모든 레퍼런스는 동일한 수명을 갖는데 &temp3는 temp3보다 오래 지속될 수 없고 r은 temp3의 스코프 밖에서도 쓰이니 이를 모두 만족하는 스코프는 존재하지 않음.
}
```
예시로 보면 당연해 보이지만, Rust로 실제 개발을 하다보면 이를 지키기가 생각보다 힘들고 잘 놓침. 물론 컴파일러가 꼼꼼하게 알려주지만, 기존의 프로그래밍 언어에서는 크게 신경쓰지 않았던 부분이라 쉽게 간과함.
```rust
// TODO : 실제 예시 필요!!
```

### 구조체와 레퍼런스
레퍼런스 타입을 타 타입의 정의 내에 둘 경우, 반드시 수명을 함께 기재해야 함. 아래 예시에서 `S2`와 같이 수명을 기재하면 `S2`로 된 값을 생성할 때마다 새로운 수명 `'a`가 부여됨.
```rust
struct S1 {
    r: &'static i32
}

struct S2<'a> {
    r: &'a i32
}
```

수명 관련 제약 사항은 함수일 때와 동일하게 적용됨.

- `r`에 저장하는 레퍼런스의 수명은 `'a`를 에워싸야 함.
- `'a`는 초기화 시점부터 마지막으로 사용되는 시점까지 유효해야 함.
- `r`에 저장하는 레퍼런스의 수명은 참조 대상의 수명 안에 포함되어야 하므로 `'a`또한 `r`의 참조 대상 수명 안에 포함되어야 함.

만약 구조체가 수명 매개변수를 갖는다면 해당 구조체를 다른 구조체의 필드로 사용할 때도 수명을 명시해야 함.
```rust
struct D<'a> {
    r: S<'a>
}
```

### 고유한 수명 매개변수
레퍼런스가 여러개 있을 때 이들의 수명이 모두 같다면, 사용에 있어 제약이 불필요하게 많아짐.
```rust
struct S<'a> {
    a: &'a i32,
    b: &'a i32,
}

fn main() {
    let x = 10;
    let r;
    {
        let y = 20;
        {
            let s = S { a: &x, b: &y };
            r = s.a;
        }
    }

    println!("{r}");
}
```
위 코드는 댕글링 포인터도 만들지 않지만 에러가 발생. 아래는 이유.
1. `s.b`를 `&y`로 초기화하므로 `'a`가 `y`의 수명보다 길면 안 됨. 두 레퍼런스는 수명이 같아야 하기 때문에 범위가 더 좁은 `s.b`에 수명이 맞춰짐.
1. `r`이 `s.a`를 저장하기 때문에 `s.a`의 수명 이후에는 사용되면 안 됨.

마지막 `println!()`에서 `s.a`의 수명이 끝났음에도 불구하고 사용했기 때문에 에러가 발생.

위와 같은 문제는 각 레퍼런스가 고유한 수명을 갖도록 만들어 주면 쉽게 해결됨.
```rust
struct S<'a, 'b> {
    a: &'a i32,
    b: &'b i32,
}

fn main() {
    let x = 10;
    let r;
    {
        let y = 20;
        {
            let s = S { a: &x, b: &y };
            r = s.a;
        }
    }

    println!("{r}");
}
```

### 수명 매개변수 생략
- 입력 수명이 필요하면 필요한 만큼의 서로 다른 임의의 수명을 암묵적으로 포함.
- 입력 수명이 하나라면 모든 출력 수명에 입력 수명을 배정.

예외적으로, 함수가 특정 타입의 메서드이면서 `self` 매개변수를 레퍼런스로 받으면, `self`의 수명이 반환 값에 배정 (`self`는 C++의 `this`나 Python의 `self`에 해당).

**주의 사항** : 

입력 수명이 하나가 아닌데 출력 수명이 명시되어 있지 않고 `self` 매개변수를 레퍼런스로 받지도 않는다면 에러가 발생.

수명 매개변수의 생략은 코드 작성의 편의를 위한 문법적 설탕일 뿐임. 만약 생략 시의 동작이 의도와 다르면 어떤 상황에서든 명시적으로 수명을 기재할 수 있음.

## 공유와 변경
- 공유 레퍼런스 : 소유 관계 트리에서 자신의 모든 자식 노드는 읽기 전용으로 변경. 부모 노드와 부모 노드의 부모 노드들도 읽기 전용으로 변경.
- 가변 레퍼런스 : 소유 관계 트리에서 자신의 부모 노드와 부모 노드의 부모 노드들은 접근 불가. 자식 노드들은 레퍼런스를 통해서만 접근 가능 (공유 가변 상관 없음).

여기서 중요한 점은, 공유 레퍼런스와 가변 레퍼런스 모두 참조 대상의 소유 경로는 변경할 수 없음. 공유 레퍼런스는 소유 경로를 읽기 전용으로 만들고, 가변 레퍼런스는 접근 불가능하게 만들기 때문.

문자열과 벡터는 구조체 또는 튜플은 구조가 다르기 때문에 표면만 보면 결과가 예상과 다를 수 있음. 소유 관계 트리에서 구조체와 튜플은 각각의 필드가 서로 다른 노드지만, 문자열과 벡터는 인덱스가 다른 값이라 하더라도 하나의 노드임. (참 말로 설명하기 힘든데) 문자열, 벡터, 구조체, 튜플의 내부구조를 보면 알 수 있음.

```rust
fn main() {
    let mut a = (1, 2);
    let d = &mut a;
    let c = &mut d.0;

    *c += 100;
    a.1 += 200; // error:  cannot use `a.1` because it was butably borrowed


    let r = &mut d.1;

    println!("{:?} {:?} {:?}", a.0, a.1, a);
}
```

위 코드는 에러가 발생하지만, 아래 코드는 에러가 발생하지 않음. 코드 한 줄 옮겨갔을 뿐인데 에러가 사라진 이유는 레퍼런스의 수명은 레퍼런스가 마지막으로 사용되는 시점까지만 유효하면 문제 없기 때문. `d`는 `let r = &mut d.1;`까지만 쓰이고 아래에서는 사용되지 않으므로 `d`의 수명의 하한은 `let r = &mut d.1;`로 봐도 무방함. 그 이후부터는 `a`에 직접 접근해도 상관이 없음.

```rust
fn main() {
    let mut a = (1, 2);
    let d = &mut a;
    let c = &mut d.0;
    let r = &mut d.1;

    *c += 100;
    a.1 += 200;
    
    println!("{:?} {:?} {:?}", a.0, a.1, a);
}
```

위 예시처럼 Rust는 한 줄만 옮겨도 컴파일 되던 것도 안 되고 안 되던 것도 될 수도 있음. Rust가 레퍼런스의 접근 및 변경과 관련된 그리고 레퍼런스의 수명과 관련된 제약 사항을 엄격하게 지키기 때문이라고 생각되는데, 아래와 같은 밈도 존재함.

![rust meme](https://i.imgur.com/VShLfAL.png)
