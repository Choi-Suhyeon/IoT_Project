<link rel="stylesheet" href="../style/style.css">

# 02. Reference

## 개요
### move의 문제점과 reference의 사용
move는 소유권이 이동한다는 큰 단점이 있음. 이동이 효율적인 경우도 있지만, 단순한 처리에서 나중에 다시 사용할 값에 대해 이동을 적용시키는 것은 코드 작성을 어렵게 만듬. 여기에 `.clone()`을 사용하는 것은 오히려 비효율.

그래서 레퍼런스가 있고 이는 **소유권을 갖지 않는(값에 대한 기존 소유권에 영향을 미치지 않는) 포인터**임. 하지만, 레퍼런스가 소유권을 갖지 않기 때문에 값을 책임지지 않고, 소유권을 갖고 있던 변수가 값을 드랍하면 레퍼런스는 그대로 댕글링 포인터가 됨. 때문에, Rust에서의 **레퍼런스는 참조 대상보다 오래 살 수 없으며 이 점을 코드에 명시해야 함**. 이런 연유로 Rust에서 레퍼런스를 만드는 것을 '빌려 온다'(borrow)고 표현.

### 레퍼런스 비교 : C++ vs. Rust
**공통점** : 두 언어에서 레퍼런스는 모두 머신 수준의 주소.

**차이점** : 

C++ :
- 레퍼런스가 암묵적으로 생성됨.
- 역참조 또한 암묵적으로 진행.
- 레퍼런스가 참조하는 대상을 변경할 수 없음.
```c++
int x = 10;
int & r = x; // 초기화는 암묵적으로 레퍼런스를 생성.

assert(r == 10); // r을 암묵적으로 역참조.

r = 20; // x에 20을 저장. r이 가리키는 대상은 x에서 변하지 않음.
```
Rust :
- 레퍼런스를 명시적으로 생성해야 함.
- 역참조 또한 명시적으로 진행해야 함.
- 레퍼런스가 참조하는 대상을 변경할 수 있음.
- 특정 상황에서는 암묵적인 차용 또는 역참조가 발생할 수 있음.
    - `.`연산자를 사용해 구조체의 멤버에 접근하는 경우, 암묵적인 차용과 역참조가 발생.
    - 비교연산자를 통해 비교할 때 암묵적 역참조 발생 (비교연산자의 피연산자들의 타입은 같아야 함).
    - 산술연산자는 한 수준에 한해 암묵적 역참조 발생. 이때 피연산자의 타입은 한 수준에 한해 갖지 않아도 됨 (`i32`와 `&i32`는 연산 가능).
```rust
fn main() {
    let x: i32 = 10;
    let y: i32 = 20;
    let mut r: &i32 = &x; // 연산자 &를 이용해 명시적으로 레퍼런스를 생성.

    assert_eq!(*r, 10); // 연산자 *를 이용해 명시적으로 레퍼런스를 역참조.

    r = &y; // r이 가리키는 대상 변경 가능 (r이 mut가 아니면 당연히 불가능).

    let mut z: i32 = 32;
    let s: &mut i32 = &mut z; // 가변 레퍼런스
    
    *s += 32; // z의 값을 갱신하기 위해 레퍼런스를 명시적으로 역참조.
    
    assert_eq!(*s, 64);
}
```

### 레퍼런스와 null
Rust에는 C의 `NULL`이나 C++의 `nullptr` 뿐만 아니라 레퍼런스를 위한 기본 초기값 또한 존재하지 않음. 정수 값을 레퍼런스로 변환할 수도 없음.

만약 C/C++에서처럼 null을 이용해 주소 값이 없는 상태를 나타내야만 하는 상황에서는 `Option<&T>`를 사용. 그럼 컴파일러는 머신 수준에서 `None`을 null 포인터로 `Some(r)`을 0이 아닌 주소로 표현. 효율적이면서도 Rust에서는 Option 값을 사용하기 전에 `None`인지를 반드시 확인해야 하므로 훨씬 안전.

## 레퍼런스의 사용
### 레퍼런스의 종류
레퍼런스의 종류에는 공유 레퍼런스(shared reference)와 가변 레퍼런스(mutable reference)가 존재.

레퍼런스와 관련된 유명한 규칙 중 하나는 'multiple readers or single writer'임. 이를 시행하기 위해 레퍼런스의 종류를 위와 같이 나눔.

**공유 레퍼런스** : 
- Copy 타입.
- 읽기 가능. 쓰기 불가.
- 동일 값을 참조하는 공유 레퍼런스의 수는 동시에 둘 이상 존재 가능.
- 참조 동안에 동일 값을 참조하는 가변 레퍼런스 생성 불가.

**가변 레퍼런스** : 
- Move 타입.
- 읽기 가능. 쓰기 가능.
- 참조 동안에 동일 값을 참조하는 가변 레퍼런스 사용 불가(공유 레퍼런스는 가능).
- 참조 동안에 동일 값을 참조하는 공유 레퍼런스 생성 가능.

책에서는 가변 레퍼런스의 참조 기간 동안에 값은 값을 참조하는 다른 모든 종류의 레퍼런스를 사용할 수 없다고 나오지만, 아래와 같은 코드는 잘만 돌아감.

```rust
fn main() {
    let mut a: i32 = 4;
    
    let b: &mut i32 = &mut a;
    let c: &i32     = &*b; // b가 참조하는 대상으로 역참조한 다음 이의 공유 레퍼런스를 빌려옴.

    println!("{b} {c}"); // 4 4
}
```

위의 규칙은 소유자에게도 똑같이 적용됨. 만약 소유자를 `let mut`로 선언했다 하더라도 공유 레퍼런스로 소유자에게서 값을 빌렸으면 소유자도 해당 레퍼런스가 수명을 다할때까지 값을 변경할 수 없음. 가변 레퍼런스로 빌리면 가변 레퍼런스의 수명이 끝날 때까지 소유자는 값에 접근도 못 함.

**값에 의한 전달 & 참조에 의한 전달** : 
- 값에 의한 전달(pass by value) : 함수에 인수로 넘길 때 소유권이 함께 넘어가거나 복사되어 넘어가는 경우.
- 참조에 의한 전달(pass by reference) : 함수에 인수로 넘길 때 레퍼런스가 넘어가는 경우.

**레퍼런스 사용 시 주의 사항** : 레퍼런스를 반복 처리할 때는 참조 대상의 각 필드에 대해서도 공유된 레퍼런스를 만들도록 정의됨.

### 레퍼런스의 레퍼런스
C/C++에서 다차원 포인터를 만들 듯 Rust에서도 레퍼런스의 레퍼런스를 만들 수 있음. 다만, 위에서도 잠깐 언급했듯이 `.`연산자는 레퍼런스가 최종적으로 가리키는 대상을 찾을 때까지 거듭해서 참조의 연결고리를 따라감. 즉, 최종적으로 가리키는 대상을 꿰뚫어 봄.
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let pnt = Point { x: 1000, y: 729 };
    let r   = &pnt;
    let rr  = &r;
    let rrr = &rr;

    assert_eq!(rrr.y, 729);
}
```

### 레퍼런스 비교
비교 연산자도 `.`연산자처럼 레퍼런스가 최종적으로 가리키는 대상을 꿰뚫어 봄. 다만, 레퍼런스 비교가 그렇다고 하더라도 두 피연산자의 타입은 반드시 일치해야 함.

레퍼런스를 비교할 때는 위에서 설명한 것처럼 최종적으로 가리키는 대상을 비교하기 때문에 두 레퍼런스가 같은 메모리를 가리키는지 확인하는 데는 무리가 있음. 이럴 때는 `std::ptr:eq()`를 사용. 그럼 레퍼런스가 담고 있는 주소를 비교.
```rust
fn main() {
    let x = 10;
    let y = 10;

    let rx = &x;
    let ry = &y;

    let rrx = &rx;
    let rry = &ry;

    // 최종 값 비교 vs. 담고 있는 주소 비교
    assert!(rx == ry); // 최종적으로 가리키는 값은 같음.
    assert!(!std::ptr::eq(rx, ry)); // rx와 ry가 담고 있는 주소는 다름.

    // 비교하려는 두 피연산자의 타입은 같아야 함. 아래는 그 방법.
    assert_eq!(&rx, rrx);
    assert_eq!(rx, *rrx);
    assert_eq!(&&x, rrx);
    // assert_eq!(rx, rrx); // error: can't compare `{integer}` with `&{integer}`
}
```

### 임의 표현식에 대한 레퍼런스
C/C++과는 다르게 Rust는 어떤 종류의 표현식이더라도 이에서 산출되는 값의 레퍼런스를 빌려올 수 있음.

**동작** : 표현식의 값을 저장할 익명 변수를 만들고 이에 대한 레퍼런스를 만듬.

**수명** : 
- `let`문에서 레퍼런스를 변수에 바로 바인딩하거나 바로 바인딩되는 구조체나 배열의 요소로 만들면 익명 변수의 수명을 `let`이 초기화하는 변수의 수명과 같도록 만듬.
- 위와 같은 상황이 아니라면, 레퍼런스의 바깥쪽 실행문이 끝날 때까지만 살아있게 됨.

```rust
fn factorial(n: usize) -> usize {
    (1..=n).product()
}

fn main() {
    let r = &factorial(6); // r과 수명을 같이 함.
    let a = 1;

    // 산술 연산은 레퍼런스를 한 단계는 꿰뚫어 볼 수 있음.
    // &1009는 println!이 끝날 때까지만 살아있음.
    println!("{}", r + a + &1009);

    // 실행 결과 : 1730
}
```