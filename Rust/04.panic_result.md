# 04. Error Handling

## 개요
Rust에는 에러를 표현, 보고, 전파, 대응, 폐기하기 위한 2가지 상호 보완적 체계가 존재.

### Panic
프로그램에서 탐지된 버그로 인한 에러를 구성하는 데 사용됨. 아래는 대표적인 사례.
- `Err`인 `Result`에 `.expect()` 호출.
- 배열의 범위 밖 요소에 접근.
- 정수를 0으로 나눗셈.
- 단언문 실패.

### Result
두 가지 종류의 연산 결과 (성공: `Ok(T)`, 실패: `Err(E)`)를 하나로 랩핑하는 데 사용됨. 

## Panic
### 개념
위 개요에서 설명했듯이 런타임 중에 프로그램에서 탐지된 버그로 인한 에러로, 스레드를 패닉 상태로 만듬. 발생하는 panic의 대부분은 프로그래머가 저지르는 실수. 하지만, 때로는 의도한 결과이기도 함(예: `.expect()`, `.unwrap()`).

### 처리
panic이 발생하면, 두 가지(해제, 중단) 중 하나로 동작. 둘의 가장 큰 차이는 panic이 발생했을 때 중단시키는 범위. 해제는 발생한 스레드만 종료시키는 반면에, 중단은 프로세스 전체를 중단시킴. 기본 값은 해제이지만, 이는 개발자가 선택할 수도 있음.

**해제** : 다음의 과정으로 진행됨.

1. 터미널에 에러 메시지 출력 : `RUST_BACKTRACE=1`로 환경 변수를 설정하면, 해당 지점의 스택을 같이 덤프해서 보여줌.
1. 스택 해제 : 함수가 사용했던 임시 값, 지역변수, 파라미터는 모두 생성 순서의 역순으로 drop됨. 이 과정을 스택 끝에 닿을 때까지 caller로 이동하며 반복.
1. 스레드 종료 : 패닉에 빠진 스레드가 메인 스레드였다면, 전체 프로세스 종료. 즉, 패닉에 빠졌더라도 해당 스레드가 메인 스레드가 아니면 프로세스는 계속 실행됨.

**중단** : 아래 두 가지 상황에서는 스택 해제를 Rust가 시도하지 않음.
- 첫 번째 panic을 Rust가 정리하던 중에 메서드 `.drop()`이 두 번째 panic을 유발하면, 치명적인 상황으로 간주해서 해제를 멈추고 전체 프로세스 중단.
- `-C panic=abort` 옵션으로 프로그램을 컴파일하면 첫 번째 panic이 발생하는 즉시 프로세스 중단.

### 특징
Rust의 어떤 안전 규칙도 panic은 위반하지 않음. 안 좋은 일이 벌어지기 전에 Rust는 이를 잡아내 스택을 해제함.

TODO : std::panic 정리. 특히, catch_unwind()

## Result
### 개념
Rust에는 다른 언어와는 달리 예외가 존재하지 않음. 실패할 수 있는 함수는 대신 반환 타입으로 `Result<T, E>`를 가짐. 즉, 실패 가능성을 암시. 성공 결과(`Ok(...)`) 또는 실패 결과(`Err(...)`)를 반환.

### 에러 잡기
**match 표현식 사용** : 가장 기본적이고 철저한 방법.
```rust
match try_something(just) {
    Ok(res)  => display_result(res),
    Err(err) => {
        println("error: {}", err);
        retry_something();
    }
}
```

**제공되는 메서드 이용** : 몇몇 상황에서 유용하게 쓸 수 있는 메서드를 제공.
TODO : std::result::Result 정리

### 에러 출력
표준 라이브러리에는 다양한 에러 타입이 정의돼 있지만, 이들은 모두 std::error::Error 트레이트를 구현하고 있음. 따라서 아래의 기능과 메서드 모두를 각각의 에러에서 사용할 수 있음.

**`println!()` 사용** : 형식 지정자 `{}`로 간단한 에러 메시지 표시 가능. 보다 자세한 debug 뷰를 보려면, 형식 지정자 `{:?}`를 대신 사용하면 됨.

**`err.to_string()`** : 에러 메시지를 String 타입으로 반환.

**`err.source()`** : `err`의 원인이 되는 에러를 Option으로 반환. 원인이 되는 에러가 있다면 `Some(...)`의 형태로 해당 에러를 반환하고 발생한 에러가 문제의 근본 원인이라면 `None`을 반환.

만약, 에러에 관한 정보를 낱낱이 출력하고 싶다면 아래의 함수를 사용.
```rust
use std::error::Error;
use std::io::{Write, stderr};

fn print_error(mut err: &dyn Error) {
    let _ = writeln!(stderr(), "error: {}", err);

    while let Some(src) = err.source() {
        let _ = writeln!(stderr(), "caused by: {}", src);

        err = src;
    }
}
```

TODO : anyhow 정리.
### 에러 전파
간단하게 연산자 `?`를 Result를 산출하는 표현식 뒤에 붙이면 됨. 아니면 `try!()` 매크로로 감싸도 됨 (하지만, `?`가 훨씬 간결, `try!()`는 `?`가 도입되기 이전에 사용됨).

동작은 성공한 경우에는 Result를 풀어서 성공 결과를 가져오고, 실패한 경우에는 즉시 에러 결과를 자신의 caller에게 반환. 이 때문에 내부에서 연산자 `?`를 사용했다면 반환 타입은 Result여야만 함.

아래는 연산자 `?`와 거의 동일한 동작을 하는 코드.
```rust
let idx = match buffer.trim().parse::<f64>() {
    Ok(success) => success,
    Err(err) => return Err(err),
};
```

참고로, `?`는 Option 타입에 대해서도 유사하게 동작. Option을 반환하는 함수 내부에서 `?`를 통해 값을 풀면, 만약 `None`일 경우 조기 복귀.

### 여러 에러 타입 다루기
만약, 전파하려는 에러의 타입이 서로 다르면, 에러가 발생. 2가지 정도의 방법으로 이를 해결할 수 있음.

**자체 에러 타입 정의** : 자체 에러 타입을 정의한 후, 변환 방법 구현. `thiserror` 크레이트를 사용하면 보다 편리하게 에러 타입 정의 가능.
TODO : 크레이트 thiserror 정리

**Rust 내장 기능 사용** : `Box<dyn std::error::Error + Send + Sync + 'static>` 타입으로 모든 에러는 변환될 수 있음. 이를 사용해 `Result`를 만들고 사용하면 됨. 다만, 이것도 `anyhow` 크레이트를 사용하면 훨씬 간편함.
TODO : 크레이트 anyhow 정리

위와 같은 다양한 에러에 대한 단일 타입으로의 반환은 발생한 또는 발생할 수 있는 에러를 특정지어주지 않음. 특정 유형의 에러를 따로 처리하려면, 메서드 `error.downcat_ref::<ErrorType>()`를 사용해야 함. 이는 만약 `error`의 내부 값의 타입이 `ErrorType`과 같다면, 이에 대한 레퍼런스를 `Some`에 담아 반환하고, 그렇지 않으면 `None`을 반환.

### 발생할 리 없는 에러 다루기
`Result`를 반환하는 함수의 경우, 상황에 따라서는 실패하지 않을 것을 위의 코드를 통해 프로그래머가 충분히 알 수 있거나, 절대 실패하지 않는 경우도 있음.

- `?` 사용 : 함수가 `Result`를 반환한다면, 간단하게 `?`를 사용하면 됨.
- `.unwrap()`, `.expect()` 사용 : `Ok`면 성공 결과를 반환하고 `Err`면 패닉에 빠짐. 둘의 차이는 `.expect()`는 안에 인수로 실패했을 때의 메시지를 줄 수 있음.

`.unwrap()`이나 `.expect()`를 사용했을 때 프로그래머의 판단 착오로 에러가 발생하게 되면 `?`과 다르게 그대로 패닉. 상황이 너무 최악이라 패닉 말고는 답이 없는 경우를 제외하고는 이런 식의 에러가 발생하는 것은 최대한 피해야 함.

### 에러 무시
Rust는 사용하지 않은 `Result` 값이 있을 경우 컴파일 타임에 경고를 내보냄(사실, `Result` 값 뿐만이 아니라 사용하지 않은 값에 대해서는 모두 경고를 보냄). 하지만, 에러의 전파가 더 중요해 해당 함수에서는 에러를 무시해 처리하고 싶지 않을 경우 관용구 `let _ = ...`를 사용.

```rust
let _ = writeln!(stderr(), "error: {}", err);
```

### main 함수에서 에러 처리
오류 전파의 끝은 결국 main 함수이기 때문에, main 함수에서는 이에 대해 조치를 취해야만 함. 조치는 3가지 정도가 있음.

**`.expect()` 사용** : 패닉에 빠짐. 메인 스레드에서 패닉이 발생했으므로, 에러 메시지가 출력되고, 0 아닌 종료 코드와 함께 프로세스 종료. 단점은 에러 메시지가 다소 난해.

**main 함수의 반환 타입을 `Result`로 변경** : `{:?}`로 출력 가능한 모든 에러 타입에 대해 작동하고 에러 메시지가 단순. 또한, `?`를 사용할 수 있음. 단점이라면, 에러 메시지가 단순한 것이 단점.

**에러 메시지 직접 출력 및 직접 종료** : 위에서 정의한 `print_error` 등의 함수를 정의해 직접 에러 메시지를 출력하고, 함수 `std::process::exit()`을 사용해 직접 종료하는 방식이 있음. 단점은 따로 정의하고 처리할 부분이 늘어 번거로움.

### 사용자 정의 에러 타입 선언
단순히 구조체를 만들면 되지만, 표준 오류 타입 처럼 작동하려면 `fmt::Display`와 `std::error::Error` 트레이트를 구현해야함.

이것도 thiserror를 사용하면 쉽게 가능.

TODO : thiserror 정리.

### Result의 장점
- 에러가 발생할 수 있는 모든 위치에서 프로그래머가 모종의 결정을 내린 후 그것을 코드에 기록할 것을 강제. 에러의 발생이나 처리를 프로그래머가 놓쳐 이것이 방치되는 것을 막을 수 있음.
- 보통의 결정은 오류가 전파되도록 하는 것인데, 이때 필요한 코드는 `?` 한 문자 뿐이므로 코드가 더러워질 일이 없음.
- 반환 타입에 에러 가능성이 명시되므로, 함수의 시그니처만 봐도 함수 실행 시 에러 발생 여부를 알 수 있음.
- `Result`라는 하나의 타입 안에 성공 결과와 오류 결과를 모두 담을 수 있으므로, 이들을 같은 컬렉션에 담을 수 있음.