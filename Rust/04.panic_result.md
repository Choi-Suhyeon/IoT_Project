# 04. Error Handling


## 개요
Rust에는 에러를 표현, 보고, 전파, 대응, 폐기하기 위한 2가지 상호 보완적 체계가 존재.

### Panic
프로그램에서 탐지된 버그로 인한 에러를 구성하는 데 사용됨. 아래는 대표적인 사례.
- `Err`인 `Result`에 `.expect()` 호출.
- 배열의 범위 밖 요소에 접근.
- 정수를 0으로 나눗셈.
- 단언문 실패.

### Result
두 가지 종류의 연산 결과 (성공: `Ok(T)`, 실패: `Err(E)`)를 하나로 랩핑하는 데 사용됨. 

## Panic
### 개념
위 개요에서 설명했듯이 런타임 중에 프로그램에서 탐지된 버그로 인한 에러로, 스레드를 패닉 상태로 만듬. 발생하는 panic의 대부분은 프로그래머가 저지르는 실수. 하지만, 때로는 의도한 결과이기도 함(예: `.expect()`, `.unwrap()`).

### 처리
panic이 발생하면, 두 가지(해제, 중단) 중 하나로 동작. 둘의 가장 큰 차이는 panic이 발생했을 때 중단시키는 범위. 해제는 발생한 스레드만 종료시키는 반면에, 중단은 프로세스 전체를 중단시킴. 기본 값은 해제이지만, 이는 개발자가 선택할 수도 있음.

**해제** : 다음의 과정으로 진행됨.

1. 터미널에 에러 메시지 출력 : `RUST_BACKTRACE=1`로 환경 변수를 설정하면, 해당 지점의 스택을 같이 덤프해서 보여줌.
1. 스택 해제 : 함수가 사용했던 임시 값, 지역변수, 파라미터는 모두 생성 순서의 역순으로 drop됨. 이 과정을 스택 끝에 닿을 때까지 caller로 이동하며 반복.
1. 스레드 종료 : 패닉에 빠진 스레드가 메인 스레드였다면, 전체 프로세스 종료. 즉, 패닉에 빠졌더라도 해당 스레드가 메인 스레드가 아니면 프로세스는 계속 실행됨.

**중단** : 아래 두 가지 상황에서는 스택 해제를 Rust가 시도하지 않음.
- 첫 번째 panic을 Rust가 정리하던 중에 메서드 `.drop()`이 두 번째 panic을 유발하면, 치명적인 상황으로 간주해서 해제를 멈추고 전체 프로세스 중단.
- `-C panic=abort` 옵션으로 프로그램을 컴파일하면 첫 번째 panic이 발생하는 즉시 프로세스 중단.

### 특징
Rust의 어떤 안전 규칙도 panic은 위반하지 않음. 안 좋은 일이 벌어지기 전에 Rust는 이를 잡아내 스택을 해제함.

TODO : std::panic 정리. 특히, catch_unwind()

## Result
### 개념
Rust에는 다른 언어와는 달리 예외가 존재하지 않음. 실패할 수 있는 함수는 대신 반환 타입으로 `Result<T, E>`를 가짐. 즉, 실패 가능성을 암시. 성공 결과(`Ok(...)`) 또는 실패 결과(`Err(...)`)를 반환.

### 에러 잡기
**match 표현식 사용** : 가장 기본적이고 철저한 방법.
```rust
match try_something(just) {
    Ok(res)  => display_result(res),
    Err(err) => {
        println("error: {}", err);
        retry_something();
    }
}
```

**제공되는 메서드 이용** : 몇몇 상황에서 유용하게 쓸 수 있는 메서드를 제공.
TODO : std::result::Result 정리

### 에러 출력
표준 라이브러리에는 다양한 에러 타입이 정의돼 있지만, 이들은 모두 std::error::Error 트레이트를 구현하고 있음. 따라서 아래의 기능과 메서드 모두를 각각의 에러에서 사용할 수 있음.

**`println!()` 사용** : 형식 지정자 `{}`로 간단한 에러 메시지 표시 가능. 보다 자세한 debug 뷰를 보려면, 형식 지정자 `{:?}`를 대신 사용하면 됨.

**`err.to_string()`** : 에러 메시지를 String 타입으로 반환.

**`err.source()`** : `err`의 원인이 되는 에러를 Option으로 반환. 원인이 되는 에러가 있다면 `Some(...)`의 형태로 해당 에러를 반환하고 발생한 에러가 문제의 근본 원인이라면 `None`을 반환.

만약, 에러에 관한 정보를 낱낱이 출력하고 싶다면 아래의 함수를 사용.
```rust
use std::error::Error;
use std::io::{Write, stderr};

fn print_error(mut err: &dyn Error) {
    let _ = writeln!(stderr(), "error: {}", err);

    while let Some(src) = err.source() {
        let _ = writeln!(stderr(), "caused by: {}", src);

        err = src;
    }
}
```

TODO : anyhow 정리.
### 에러 전파
간단하게 연산자 `?`를 Result를 산출하는 표현식 뒤에 붙이면 됨. 아니면 `try!()` 매크로로 감싸도 됨 (하지만, `?`가 훨씬 간결, `try!()`는 `?`가 도입되기 이전에 사용됨).

동작은 성공한 경우에는 Result를 풀어서 성공 결과를 가져오고, 실패한 경우에는 즉시 에러 결과를 자신의 caller에게 반환. 이 때문에 내부에서 연산자 `?`를 사용했다면 반환 타입은 Result여야만 함.

아래는 연산자 `?`와 거의 동일한 동작을 하는 코드.
```rust
let idx = match buffer.trim().parse::<f64>() {
        Ok(success) => success,
        Err(err) => return Err(err),
    };
```

### 여러 에러 타입 다루기

### 발생할 리 없는 에러 다루기

### 에러 무시

### main 함수에서 에러 처리

### 사용자 정의 에러 타입 선언

### 주의
Result의 값은 사용되지 않으면 컴파일러가 경고를 보냄. Rust에서는 실패할 수 있는 값에 대한 처리를 코드에 반드시 명시해야 함.