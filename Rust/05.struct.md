# 05. Structs

## 개요
Rust의 구조체는 C++ 또는 Swift의 구조체와 유사. 여러 타입의 값들이 하나의 값을 구성하기 때문에 하나의 단위로 다룰 수 있다는 것이 가장 큰 특징. 개별 요소에 접근하고 수정할 수 있으며, 메서드와 연관 상수를 정의할 수 있음.

기명 필드로 된 구조체, 튜플형 구조체, 유닛형 구조체가 있음.

- 기명 필드로 된 구조체 : 일반적인 C++에서의 구조체와 같은 형태. 필드의 이름을 직접 지정할 수 있음.
- 튜플형 구조체 : 튜플에 이름이 붙어있는 것과 같은 형태로 각 필드는 차례대로 0, 1, 2, ... n의 이름을 가짐.
- 유닛형 구조체 : 필드가 존재하지 않는 구조체. 물리적인 형태는 존재하지 않으며(메모리 상에 저장되거나 이를 다루기 위한 코드를 생성하지 않음), 논리적으로는 하나의 값만 갖는 타입.

## 정의
### 기명 필드로 된 구조체
```rust
struct Grayscale {
    pixels: Vec<u8>,
    size: (usize, usize)
}
```

### 튜플형 구조체
```rust
struct Bounds(usize, usize);
```

### 유닛형 구조체
```rust
struct Onesuch;
```

**주의** : `sturct Onesuch;`와 `struct Onesuch {}`는 다름. 전자는 유닛형 구조체이고, 후자는 필드가 없는 기명 필드로 된 구조체.
```rust
struct Temp1;
struct Temp2 {}

fn main() {
    let a = Temp1; // 가능
    let b = Temp1 {}; // 가능

    let c = Temp2; // 불가
    let d = Temp2 {}; // 가능
}
``` 

### 접근제한자
구조체도 필드도 비공개가 기본. 선언된 모듈과 이의 하위 모듈에서만 볼 수 있음. `pub` 키워드를 구조체나 필드의 앞에 붙이면 모듈 외부에서도 볼 수 있음. 구조체는 공개여도 필드는 비공개일 수 있음(예: String, Vec).
```rust
pub struct Grayscale { // 구조체는 공개
    pixels: Vec<u8>, // 필드 앞에 pub이 없으므로, 비공개
    size: (usize, usize) // 마찬가지로 비공개
}
```
```rust
pub struct Bounds(pub usize, pub usize);
```

### Copy & Clone
기본적으로 모든 구조체는 move 타입(설사 모든 필드가 copy 타입이라 할지라도). 만약, 구조체를 copy 타입으로 만들거라면, 구조체 정의 위에 `#[derive(Copy, Clone)]`을 붙여야 됨. 당연히 이때 모든 필드는 copy 타입이어야 함. 또한 `.clone()`을 사용하기 위해선 `#[derive(Clone)]`이 필요함.

## 표현식
정의했을 때와 비슷하게 사용하면 됨. 다만 몇 가지 문법적 설탕이 있음.

만약, 필드의 이름과 해당 필드에 넣으려는 변수의 이름이 같다면, 변수명 하나만 써도 됨. 
```rust
struct Temp {
    x: u32,
    y: u32,
    z: u32
}

fn main() {
    let x = 10;
    let y = 20;

    let c = Temp { x, y, z: 30 }; // Temp { x: x, y: y, z: 30 }로 작성하는 것과 같음.
}
```

표현식 내에서 이름이 있는 필드 다음에 `.. EXPR`가 오면, 앞에서 언급되지 않은 모든 필드의 값은 `EXPR`에서 가져옴. 아래는 유의 사항.
- `EXPR`의 반환 타입은 동일한 구조체 타입이어야 함.
- 복사 또는 이동으로 필드를 가져옴(`.clone()`해서 가져오지 않음).
- 튜플형도 이와 마찬가지로 중괄호를 이용해 작성할 수 있음(소괄호 형태에서는 `.. EXPR`를 사용할 수 없음).
```rust
struct Temp(u32, u32);

fn main() {
    let a = Temp(1, 2);
    let b = Temp { 0: 3, .. a };
}
```
튜플형 구조체의 경우, `STRUCT_NAME(ARG1, ARG2)` 형태인 표현식도 갖는데, 형태에서 볼 수 있 듯, 함수. 즉, 함수를 인수로 받는 함수에 튜플형 구조체의 이름 또한 넘길 수 있음.

## 메모리 레이아웃
Rust에서는 C언어와는 달리 필드를 메모리에 어떻게 배치할지에 관해 어떠한 것도 규정하고 있지 않음. 적어도 Python이나 Javascript처럼 힙에 각 필드를 위한 공간을 할당하고 이들의 포인터를 갖는 형태는 아니고, C언어처럼 직접 박아 넣음.

만약, C/C++과 호환되는 방식으로 배치해야 하거나 패딩을 1로 반드시 고정해야 하는 상황이라면, `#[repr(C)]`나 `#[repr(align(1))]`을 고려해볼 수 있음.

TODO : https://doc.rust-lang.org/nomicon/data.html 정리.

