# 07. Trait & Generic

## Trait
Rust의 trait는 타 언어의 인터페이스나 추상 클래스의 역할을 함. Go의 interface와 상당히 유사해 거의 같다고 생각해도 되지만, Rust의 trait에는 Haskell에서 가져온 추가적인 문법과 개념이 존재.
- 기존 타입에 확장 메서드 추가.
- 타입에의 trait 추가가 메모리 비용을 증가시키지 않음.
- trait 사용 시 가상 메서드 호출 비용이 발생하지 않게 할 수 있음.

### 개념
trait는 타입의 능력(타입이 할 수 있는 무엇)을 나타냄. 하나의 특정한 trait가 존재한다고 했을 때, 임의의 타입이 이를 지원할 수도 있고 하지 않을 수도 있음. 하지만, 이를 지원하는 모든 타입(설사 지금 존재하지 않는 타입이더라도)은 같은 방법으로 데이터를 처리할 수 있음. 아래는 예시.
- `std::iter::Iterator` : 이를 구현하는 값은 일련의 값을 산출할 수 있음.
- `std::clone::Clone` : 이를 구현하는 값은 메모리에 자기 자신을 복제할 수 있음.
- `std::fmt::Debug` : 이를 구현하는 값은 `println!()`과 같은 매크로에서 형식 지정자 `{:?}`를 사용할 수 있음.
```rust
// trait를 사용하려면 이것이 반드시 범위 내에 존재해야 됨.
// 없으면, trait 내부 메서드가 전혀 보이지 않음.
use std::io::Write;
use std::fs::File;
use std::io;

fn say_hello(out: &mut dyn Write) -> io::Result<()> {
    out.write_all(b"hello world!\n")?;
    out.flush()
}

fn main() -> io::Result<()> {
    let mut fp = File::create("hello.txt")?;
    say_hello(&mut fp)?; // 필요하면 일반적인 레퍼런스를 trait 객체로 암묵적 형변환함.

    // 위와는 다른 타입임에도 둘 다 Write trait를 구현하고 있기 때문에 같은 방식으로 처리 가능.
    // 아직 정의되지 않은 타입도 Write trait를 구현하면, say_hello 함수 이용 가능.
    let mut bytes = Vec::<u8>::new();
    say_hello(&mut bytes)?;

    println!("{}", String::from_utf8(bytes).unwrap());
    Ok(())
}
```

### Trait 객체

trait 타입을 가리키는 레퍼런스. Rust는 필요하면 일반적인 레퍼런스를 trait 객체로 묵시적으로 변환. Box 또는 Rc 등의 내부에 있더라도 마찬가지.

Go에서는 인터페이스에 대해 다운캐스팅을 지원하지만, Rust는 이를 지원하지 않음. 매개변수에 trait를 한정하면 trait가 정의하고 있는 메서드만을 함수 내부에서 사용할 수 있음. 

```rust
let mut buf: Vec<u8> = vec![];
let writer: &mut dyn Write = &mut buf;
```
- `mut` 앞에 있는 `&`를 제거하면, 에러가 발생. 변수의 크기는 컴파일 타임에 결정돼야 하는데, 이를 구현하고 있는 타입의 크기는 당연히 모두 각기 다를 것이기 때문. Java나 C#에서도 OutputStream 타입의 변수는 OutputStream을 구현하고 있는 임의 객체에 대한 참조를 갖고 있으므로, Rust에서도 참조로 사용하면 됨. 다만, 이를 명기해야 함.
- `dyn`은 trait 객체 타입임을 나타내는 접두사.

### 레이아웃
trait 객체 : fat pointer(값을 가리키는 포인터 + V테이블 포인터). 따라서, 2 머신 워드를 차지함.

V테이블 : 런타임 중에 타입 정보를 갖고 있는 테이블. 함수 포인터 배열. C++도 비슷한 것을 갖고 있음. 하지만, C++은 구조체 내부에 vptr이 저장되는 반면에, Rust는 fat pointer를 사용. 이로 인해 vptr 하나조차 제대로 수용할 공간이 없는 `isize`와 같은 타입도 trait를 구현할 수 있음.

TODO : "C++보다 조금 더 좋은 V테이블 포인터 관리 방법을 차용함"정도로만 설명했지만, C++의 V테이블에 대해 더 자세히 알아봐야 함.

### 제네릭 함수와 타입 매개변수
위에서 정의한 함수 `sayHello`를 제네릭 함수로 변경해 함수 시그니처만 비교해보면(바디는 달라질 것이 없기 때문에) 아래와 같다.

## Generic
Rust에서 trait와 함께 다형성을 책임지는 다른 한 축. C++의 템플릿처럼 동일한 코드로 다양한 타입의 값들을 처리할 수 있음.