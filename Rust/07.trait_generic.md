# 07. Trait & Generic

## Trait
Rust의 trait는 타 언어의 인터페이스나 추상 클래스의 역할을 함. Go의 interface와 상당히 유사해 거의 같다고 생각해도 되지만, Rust의 trait에는 Haskell에서 가져온 추가적인 문법과 개념이 존재.
- 기존 타입에 확장 메서드 추가.
- 타입에의 trait 추가가 메모리 비용을 증가시키지 않음.
- trait 사용 시 가상 메서드 호출 비용이 발생하지 않게 할 수 있음.

### 개념
trait는 타입의 능력(타입이 할 수 있는 무엇)을 나타냄. 하나의 특정한 trait가 존재한다고 했을 때, 임의의 타입이 이를 지원할 수도 있고 하지 않을 수도 있음. 아래는 예시.
- `std::iter::Iterator` : 이를 구현하는 값은 일련의 값을 산출할 수 있음.
- `std::clone::Clone` : 이를 구현하는 값은 메모리에 자기 자신을 복제할 수 있음.
- `std::fmt::Debug` : 이를 구현하는 값은 `println!()`과 같은 매크로에서 형식 지정자 `{:?}`를 사용할 수 있음.

### 사용
trait 메서드를 사용하려면, trait가 반드시 범위 내에 존재해야 함. 그렇지 않으면 trait 내부에 있는 메서드가 한 개도 보이지 않음.
```rust
use std::io::Write; // 이 줄이 없으면 메서드 write_all을 사용할 수 없음.

fn main() {
    let mut buf: Vec<u8> = vec![];

    buf.write_all(b"Hello").unwrap();
}
```

Rust는 필요하면 일반적인 레퍼런스를 trait 객체로 묵시적으로 변환. Box 또는 Rc 등의 내에 있더라도 마찬가지.

Go에서는 인터페이스에 대해 다운캐스팅을 지원하지만, Rust는 이를 지원하지 않음. 매개변수의 trait를 한정하면 trait가 정의하고 있는 메서드만을 함수 내부에서 사용할 수 있음. 

### 레이아웃
**트레이트 객체** : trait 타입을 가리키는 레퍼런스. 레퍼런스 없이는 사용될 수 없음(변수의 크기는 컴파일 시점에 결정돼야 하는데 trait를 구현하는 타입의 크기가 각기 다르기 때문).

trait는 값을 가리키는 포인터와 값의 타입을 나타내는 테이블을 가리키는 포인터로 이루어진 fat pointer.

## Generic
Rust에서 trait와 함께 다형성을 책임지는 다른 한 축. C++의 템플릿처럼 동일한 코드로 다양한 타입의 값들을 처리할 수 있음.