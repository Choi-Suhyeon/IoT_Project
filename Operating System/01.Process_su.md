# 01. Process

## Process
어떻게 다수의 CPU 상에서 동작하는 것처럼 보이게 할까?

시분할(time sharing) : 하나의 프로세스를 실행하다 얼마 후 중단시키고 다른 프로세스를 실행하는 작업을 반복하면서 단일 또는 소수의 CPU로 그보다 많은 CPU가 존재하는 듯한 환상을 만들어냄. 결과적으로 여러 프로세스를 동시에 실행하는 것처럼 만듬. 단, CPU를 공유하기 때문에, 각 프로세스의 성능은 낮아짐.

공간 분할(space sharing) : 시분할에 대응되는 개념. (e.g. 메모리를 여러 프로세스가 공유, 하드디스크 공간을 여러 파일들이 공유)

### Mechanism vs. Policy
다수의 운영체제의 공통된 설계 패러다임 중 하나는 고수준 policy을 저수준 mechanism으로부터 분리하는 것. 간단하게 mechanism은 '어떻게'에 대한 답이며, policy는 '어느 것'에 대한 답. 이는 모듈성의 한 형태로, policy를 변경할 때 mechanism의 변경을 고민할 필요가 없게 만듬.

#### Mechanism
필요한 기능의 일부를 구현하는 저수준의 방법이나 프로토콜로 정해진 절차에 따라 단순하고 고정적으로 결과를 내는 저수준의 기계적인 절차를 의미함. 여기에는 새로운 생각이 들어갈 여지가 없음. (e.g. context switching).

#### Policy
운영체제에서 일종의 결정을 내리는 고수준의 알고리즘. 관점에 따라 장단을 다툴 여지가 있는 문제를 처리하는 것은 policy로 봄 (e.g. scheduling policy).

**scheduling policy** : 간단하게 프로세스에게 효율적으로 자원을 할당하기 위한 정책. 아래는 기준.
- historical information
- workload knowledge
- performance matrics

### Process의 개념
운영체제가 실행 중인 프로그램이라는 개념을 제공하기 위한 추상화의 일종.

프로세스가 실행되는 동안의 특정한 순간마다 프로세스가 접근했거나 영향을 미친 시스템의 다양한 자원에 대한 목록으로 프로세스를 요약할 수 있음. 이러한 목록을 machine state라 부름.

#### 대표적인 machine state 요소
- address space : 운영체제가 독립적으로 할당해서 준 메모리의 특정 영역에 대한 주소
- register : 명령어가 처리될 때의 CPU 상태 (e.g. program counter, stack pointer, frame pointer)
- I/O Information : 프로세스가 현재 열어 놓은 파일 목록.

### Process API
운영체제는 많은 프로세스 API를 제공. 아래는 필히 API로 제공해야만 하는 기본 기능.
- Create : 새로운 프로세스 생성.
- Destroy : 프로세스를 강제로 제거.
- Wait : 프로세스의 실행이 중지될 때까지 대기.
- Status : 프로세스의 status 정보 확인.
    - state vs. status
        - state : 보다 본질적인 것 (The overall physical condition of something; the ability of something to be used, enjoyed, etc).
        - status : state의 일부를 관찰하는 하는 상황을 전제로 사용 (the current state of someone or something).
- 각종 control : 프로세스의 중지, 재개 등.

#### Process 생성
어떻게 프로그램을 준비시키고 실행하는가? 어떻게 프로세스를 생성하는가?

1. 보조기억장치에 실행 파일 형식으로 저장된 프로그램을 메모리 공간(프로세스의 주소 공간)에 load.
    - eager loading : 프로그램을 실행시키기 전에 프로그램 전부를 로딩. 일단 실행된 이후에는 디스크가 프로그램 실행에 개입하지 않음 (즉, 프로그램이 빠르게 실행됨).
    - lazy loading : 코드 또는 데이터의 일부만 필요한 경우에 로딩. 실행되지 않는 부분은 loading하지 않을 수 있음.
1. 프로그램의 stack을 위한 메모리 영역을 할당.
1. 프로그램의 heap을 위한 메모리 영역을 할당.
1. 입출력과 관계된 초기화 작업을 수행.
1. entry point로 분기.
1. 운영체제는 CPU를 새로 생성된 프로세스에 넘김.

#### Process State
프로세스는 아래 세 상태 중 하나에 존재할 수 있음.
- Running : 프로세서에서 실행 중인 상태.
- Ready : 실행 할 준비는 되어 있지만, 운영체제가 다른 프로세스를 실행하는 등의 이유로 대기 중인 상태.
- Blocked : 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단 중인 상태. 다른 프로세스가 Running이 될 수 있음.

### 자료 구조
운영체제는 앞의 개념을 구현하기 위해 여러 자료 구조를 갖고 있음.

```c
// 프로세스를 중단하고 이후에 재개하기 위해 저장하고 복원하는 레지스터􏰈􏰉􏰊 􏰋􏰌
 struct context { // 운영체제가 32bit임을 알 수 있음.
    int eip;
    int esp;
    int ebx;
    int ecx;
    int edx;
    int esi;
    int edi;
    int ebp;
};

// 가능한 프로세스 􏰝􏰞
enum proc_state { UNUSED, EMBRYO, SLEEPING,
RUNNABLE, RUNNING, ZOMBIE };
􏰉􏰗 􏰩􏰪
// 레지스터 context와 프로세스 state를 포함하여 각 프로세스에 대해 xv6가 추적하는 정보.
struct proc {
    char *mem;
    uint sz;
    char *kstack;
    enum proc_state state; // 프로세스 state. 위에 열거형으로 정의됨.
    int pid;
    struct proc *parent;
    void *chan;
    int killed;
    struct file *ofile[NOFILE];􏱁􏱂 􏱃􏱄
    struct inode *cwd; 􏱆􏱇􏰚􏰭
    struct context context; // 프로세스가 정지된 상태가 되면 이의 내용을 여기에 저장.
    struct trapframe *tf;
};
```