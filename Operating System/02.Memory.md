# 02. Memory

## Memory
보다 대화식으로 CPU를 사용하기를 원했고 time-sharing 방식으로 CPU를 이용하게 됨. 짧은 time slice 동안 특정 프로세스가 CPU를 사용하고 이후에 다른 프로세스로 scheduler가 scheduling을 해줌. 실행되는 동안에 프로세스는 메모리 공간을 전부 사용할 권한이 주어지는데 이 실행 중이던 메모리 공간에 대한 정보를 디스크에 전부 저장을 하자니 속도가 너무 느렸음. 프로세스 전환 시 프로세스를 메모리에 그대로 유지하면서 운영체제가 time-sharing 시스템을 효율적으로 구성할 수 있도록 해줘야 함. 그래서 메모리 가상화가 필요함. 또한 여러 프로그램이 메모리에 동시에 존재해야 하기 때문에 '보호'가 중요한 문제가 됨.

### Address Space
#### 의미
해당 영역에 대한 보호가 고려된 물리 메모리의 추상
실행 중인 프로그램의 메모리에 대한 관점

#### 구성
- Code Segment : 실행할 코드가 저장되는 정적 영역.
- Heap Segment : 필요한 메모리를 동적으로 할당받는 동적 영역. 아래에서 위로 자람.
- Stack Segment : 스택 프레임, 지역 변수, 함수의 인자와 반환 값 등이 저장되는 동적 영역. 위에서 아래로 자람.

이러한 배치는 관례이며, address space에 여러 thread가 공존할 때 이런 식의 배치를 사용하면 동작하지 않게 됨.

#### 목표
- 투명성 : 프로그램이 가상 메모리의 존재를 인지하지 못하도록 가상 메모리 시스템을 구현해야 함.
- 효율성 : 가상화가 시간 및 공간 측면에서 효율적이도록 해야 함.
- 보호 : 임의 프로세스를 이와 다른 프로세스로부터 보호해야 하고 운영체제 자신도 프로세스로부터 보호해야함. 즉, 어떤 식으로든 타 프로세스나 운영체제의 메모리에 접근하거나 영향을 줄 수 있어서는 안 됨.

#### 메모리 관련 흔한 오류
- 할당을 잊거나 : 해당 스택 또는 힙 공간의 값을 주소로 보고 거기에 있는 값을 읽거나 씀. 덮으면 안 될 곳을 덮는 등 예상치 못한 동작을 할 수가 있음.
- 메모리를 부족하게 할당받거나 : 버퍼 오버플로우에 취약. 리턴 주소를 원하는 코드의 주소로 덮는 식으로 악용할 수 있음.
- 메모리를 초기화하지 않거나 : 힙이라는 공간이 정말 랜덤하게만 공간을 주는 것은 아니라 한 번 할당받고 free한 다음에 다시 같은 크기로 할당받으면 줬던 공간 다시 그대로 줌. 우리는 원하지 않고 해커는 원하는 값이 할당받은 공간에 있을 수 있음. use after free의 원인이 됨(사실 UAF를 막으려면 free 전에 메모리 공간을 전부 초기화해주고 free한 pointer도 NULL로 변경해야 함).
- 메모리를 해제하지 않거나 : 메모리 누수를 부름
메모리를 해제하고 해당 포인터를 초기화하지 않거나 : 해제된 메모리의 주소 값으로 접근할 수 있기 때문에 힙을 관리하는 원형 링크드리스트를 망가트리거나 use after free가 가능함.
- 반복적으로 메모리를 해제하거나 : double free 에러가 발생
