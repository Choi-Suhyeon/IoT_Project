### 1. 페이징 : 개요
- 운영체제는 거의 모든 공간 관리 문제를 해결할 때 두 가지 중 하나를 사용
  - 첫 번째 방법은 가변 크기의 조각들로 분할하는 것
    - 문제 : 공간을 다양한 크기의 청크로 분할할 때 공간 자체가 단편화(fragmented) 될 수 있고, 할당은 점점 더 어려워짐
  - 두 번째 방법은 공간을 동일 크기의 조각으로 분할하는 페이징(paging)
    - 프로세스의 주소 공간을 몇 개의 가변 크기의 논리 세그멘트(예] 코드, 힙, 스택)로 나누는 것이 아니라 고정 크기의 단위로 나눔
    - 이 각각의 고정 크기 단위를 페이지(page)라고 부름



<br>

#### 1.1. 간단한 예제 및 개요
- 페이징은 이전 방식에 비해 많은 장점을 가지고 있는데, 가장 중요한 개선은 유연성
- 페이징을 사용하면 프로세스의 주소 공간 사용 방식과는 상관없이 효율적으로 주소 공간 개념을 지원할 수 있음
  - 예를 들어 힙과 스택이 어느 방향으로 커지는가, 어떻게 사용되는가에 대한 가정을 하지 않아도 됨
- 또 다른 장점은 페이징이 제공하는 빈 공간 관리의 단순함

<br>

- 주소 공간의 각 가상 페이지에 대한 물리 메모리 위치 기록을 위하여 운영체제는 프로세스 마다 **페이지 테이블(page table)** 이라는 자료 구조를 유지함
- 페이지 테이블의 주요 역할은 주소 공간의 가상 페이지 주소 변환(address translation)정보를 저장하는 것
  - 각 페이지가 저장된 물리 메모리의 위치가 어디인지 알려줌
- 페이지 테이블은 프로세스마다 존재한다는 사실을 숙지해야 함(역 페이지 테이블(inverted page table)이라는 예외적인 기법도 존재)




<br>

#### 1.2. 페이지 테이블은 어디에 저장되는가
- 작은 세그멘트 테이블이나 베이스-바운드 쌍에 비해서 페이지 테이블은 매우 커질 수 있음
  - 물리 주소로의 변환 정보와 다른 필요한 정보를 저장하기 위하여 페이지 테이블 항목(page table entry, PTE)마다 4바이트가 필요하다고 가정하면, 각 페이지 테이블을 저장하기 위하여 4MB의 메모리가 필요하게 됨
  - 이것은 꽤 커다란 크기이며 프로세스 100개가 실행 중이라고 가정했을 때, 주소변환을 위해서 운영체제가 400MB의 메모리를 필요로 하는 것을 의미

<br>

- 페이지 테이블이 매우 크기 때문에 현재 실행 중인 프로세스의 페이지 테이블을 저장할 수 있는 회로를 MMU 안에 유지하지 않을 것
- 대신 각 프로세스의 페이지 테이블을 메모리에 저장함
- 페이지 테이블은 운영체제 가상 메모리에 저장할 수 있고 심지어 디스크에 스왑될 수 있음




<br>

#### 1.3. 페이지 테이블에는 실제 무엇이 있는가
- 페이지 테이블은 가상 주소(또는 실제로는 가상 페이지 번호)를 물리 주소(물리 프레임 번호)로 매핑(mapping)하는 데 사용되는 자료구조
- 임의의 자료 구조도 사용 가능
- 가장 간단한 형태는 선형 페이지 테이블(linear page table)로 단순한 배열
- 운영체제는 원하는 물리 프레임 번호(PFN)를 찾기 위하여 가상 페이지 번호(VPN)로 배열의 항목에 접근하고 그 항목의 페이지 테이블 항목(PTE)을 검색함

<br>

- 각 PTE에는 심도있는 이해가 필요한 비트들이 존재함
- Valid bit는 특정 변환의 유효 여부를 나타내기 위하여 포함됨
  - Valid bit는 할당되지 않은 주소 공간을 표현하기 위해 반드시 필요
  - 주소 공간의 미사용 페이지를 모두 표시함으로써 이러한 페이지들에게 물리 프레임을 할당할 필요를 없애 대량의 메모리를 절약
- 페이지가 읽을 수 있는지, 쓸 수 있는지, 또는 실행될 수 있는지를 표시하는 protection bit
  - Protection bit가 허용하지 않는 방식으로 페이지에 접근하려고 하면 운영체제에 트랩을 생성함
- Present bit는 이 페이지가 물리 메모리에 있는지 혹은 디스크에 있는지(즉, 스왑 아웃되었는지) 가리킴
- dirty bit 또한 일반적인데, 메모리에 반입된 후 페이지가 변경되었는지 여부를 나타냄
- reference bit(또는 accessed bit)는 때때로 페이지가 접근되었는지를 추적하기 위해 사용됨
  - 또한, 어떤 페이지가 인기가 있는지 결정하여 메모리에 유지되어야 하는 페이지를 결정하는 데에도 유용
  - 이 정보는 페이지 교체에 매우 중요함





<br>

#### 1.4. 페이징 : 너무 느림
- 페이징을 사용한 메모리 접근
  ```
    // 가상 주소에서 VPN 추출
    VPN = (VirtualAddress & VPN_MASK) >> SHIFT
    // 페이지 테이블 항목(PTE)의 주소 형성 
    PTEAddr = PTBR + (VPN * sizeof(PTE))
    // PTE 반입
    PTE = AccessMemory(PTEAddr)
    // 프로세스가 페이지를 접근할 수 있는지 확인
    if (PTE.Valid == False)
      RaiseException(SEGMENTATION_FAULT)
    else if (CanAccess(PTE.ProtectBits) == False)
      RaiseException(PROTECTION_FAULT)
    else
      // 접근 가능하면 물리 주소 만들고 값 가져오기
      offset = VirtualAddress & OFFSET_MASK
      PhysAddr = (PTE.PFN << PFN_SHIFT) | offset
      Register = AccessMemory(PhysAddr)
  ```





