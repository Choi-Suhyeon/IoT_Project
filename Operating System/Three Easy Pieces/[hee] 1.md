### 1. 운영체제
  - 프로그램은 매우 단순한 일을 함
    - 명령어를 실행
    - 프로세서는 명령어를 초당 수백만 번(요즘은 수십억 번) **반입(fetch)** 하고, **해석(decode)** 하고, **실행(execute)** 함
    - 명령어 작업을 완료한 후 프로세서는 계속 그 다음 명령어로 프로그램이 완전히 종료될 때까지 실행을 계속함
  - 프로그램을 쉽게 실행하고 (심지어 동시에 여러 발의 프로그램을 실행시킬 수도 있음), 프로그램 간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양한 흥미로운 일을 할 수 있게 하는 소프트웨어
  - 시스템을 사용하기 편리하면서 정확하고 올바르게 동작시킬 책임이 있기 때문에 소프트웨어를 운영체제(operating system, OS)라고 부름

<br>

  - 운영체제는 언급했던 일들을 하기 위하여 **가상화(virtualization)** 라고 불리는 기법을 사용
  - 운영체제는 프로세서, 메모리, 또는 디스크와 같은 물리적(physical)인 자원을 이용하여 일반적이고, 강력하고, 사용이 편리한 가상(virtual) 형태의 자원을 생성
    => 때로는 **가상 머신(virtual machine)** 이라고 부름

<br>

  - 사용자 프로그램의 프로그램 실행, 메모리 할당, 파일 접근과 같은 가상 머신과 관련된 기능들을 운영체제에게 요청할 수 있도록, 운영체제는 사용자에게 API를 제공
  - 보통 운영체제는 응용 프로그램이 사용 가능한 수백 개의 **시스템 콜**을 제공
  - 운영체제가 프로그램 실행, 메모리와 장치에 접근, 기타 이와 관련된 여러 작업을 진행하기 위해 시스템 콜을 제공하기 때문에, 우리는 운영체제가 표준 라이브러리(standard library)를 제공한다고도 함

<br>

  - 가상화는 많은 프로그램들이 CPU를 공유하여, 동시에 실행될 수 있게 함
    - 프로그램들이 각자 명령어와 데이터를 접근할 수 있게 함
    - 프로그램들이 디스크등의 장치를 공유할 수 있게 함
    => 운영체제는 자원 관리자(resource manager)라고도 불림

<br>

  - CPU, 메모리, 및 디스크는 시스템의 자원이므로 효율적으로, 공정하게 자원을 관리하는 것이 운영체제의 역할

<br>

#### 1-1. CPU 가상화
- **Spin()** 1초 동안 실행된 후 리턴하는 함수

- cpu.c
  ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/time.h>
    #include <assert.h>
    #include "common.h"
    int
    main(int argc, char *argv[])
    {
      if (argc != 2) {
        fprintf(stderr, "usage: cpu <string>\n");
        exit(1);
      }
      char *str = argv[1];
      while (1) {
        Spin(1);
        printf("%s\n", str);
      }
      return 0;
    }
  ```

  - 단일 프로세서
    ```
      prompt> gcc −o cpu cpu.c −Wall
      prompt> ./cpu“A ”
      A
      A
      A
      A
      ∧C
      prompt>
    ```

  - 여러 인스턴스를 동시에 실행
    ```
      prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
      [1] 7353
      [2] 7354
      [3] 7355
      [4] 7356
      A
      B
      D
      C
      A
      B
      D
      C
      A
      C
      B
      D
      ...
    ```

=> 하나의 CPU 또는 소규모 CPU 집합을 무한개의 CPU가 존재하는 것처럼 변환하여 동시에 많은 수의 프로그램을 실행시키는 것 -> **CPU 가상화(virtualizing the CPU)**


<br>

#### 1-2. 메모리 가상화
- 현재 우리가 사용하고 있는 컴퓨터에서의 **물리 메모리(physical memory)** 모델은 매우 단순 -> 바이트의 배열
- 메모리를 읽기 위해서는 데이터에 **주소(address)** 를 명시해야 함
- 메모리에 쓰기 (혹은 갱신) 위해서는 주소와 데이터를 명시해야 함

- 메모리는 프로그램이 실행되는 동안 항상 접근됨
- 프로그램은 실행 중에 자신의 모든 자료 구조를 메모리에 유지하고 load와 store 또는 기타 메모리 접근을 위한 명령어를 통하여 자료 구조에 접근
- 명령어 역시 메모리에 존재하며 명령어를 반입할 때마다 메모리가 접근됨

<br>

- 메모리 접근 프로그램
  - mem.c
    ```
      #include <unistd.h>
      #include <stdio.h>
      #include <stdlib.h>
      #include "common.h"
      int
      main(int argc, char *argv[])
      {
        int *p = malloc(sizeof(int)); // a1
        assert(p != NULL);
        printf("(%d) memory address of p: %08x\n", getpid() , (unsigned) p); // a2
        *p = 0; // a3
        while (1) {
          Spin(1);
          *p = *p + 1;
          printf("(%d) p: %d\n", getpid() , *p); // a4
        }
        return 0;
      }
    ```

    - 출력 결과
      ```
        prompt> ./mem
        (2134) memory address of p: 00200000
        (2134) p: 1
        (2134) p: 2
        (2134) p: 3
        (2134) p: 4
        (2134) p: 5
        ∧C
      ```
      - 우선 메모리를 할당 받음 (a1 행)
      - 그런 후 할당받은 메모리의 주소를 출력 (a2)
      - 새로 할당받은 메모리의 첫 슬롯에 숫자 0을 넣음 (a3)
      - 마지막으로 루프로 진입하여 1초 대기 후, 변수 p가 가리키는 주소에 저장되어 있는 값을 1 증가시킴
      - 출력할 때마다 실행 중인 프로그램의 프로세스 식별자(PID : 프로세스의 고유의 값) 값이 함께 출력

    - 메모리 프로그램 여러 번 실행
      ```
        prompt> ./mem &; ./mem &
        [1] 24113
        [2] 24114
        (24113) memory address of p: 00200000
        (24114) memory address of p: 00200000
        (24113) p: 1
        (24114) p: 1
        (24114) p: 2
        (24113) p: 2
        (24113) p: 3
        (24114) p: 3
        (24113) p: 4
        (24114) p: 4
        ...
      ```

  - 각 프로세스는 자신만의 **(가상) 주소 공간(virtual address space)** 을 갖음
  - 운영체제는 이 가상 주소 공간을 컴퓨터의 물리 메모리로 매핑(mapping) 함
  - 하나의 프로그램이 수행하는 각종 메모리 연산은 다른 프로그램의 주소 공간에 영향을 주지 않음
  - 실제로는 물리 메모리는 공유 자원이고, 운영체제에 의해 관리됨


<br>

#### 1-3. 병행성
- 프로그램이 한 번에 많은 일을하려 할 때 (즉, 동시에) 발생하는 그리고 반드시 해결해야 하는 문제들을 가리킬 때 사용
- 병행성 문제는 우선 운영체제 자체에서 발생
- 병행성 문제는 운영체제만의 문제는 아니며 **멀티 쓰레드** 프로그램도 동일한 문제

- 여러개의 명령어가 **원자적(atomically)** 으로 (한 번에 여러개 모두) 실행되지 않으면, 명령어가 한 번에 하나씩만 실행되기 때문에 문제가 발생 할 수 있음


<br>

#### 1-4. 영속성
- DRAM과 같은 장치는 데이터를 휘발성(volatile) 방식으로 저장하기 때문에 메모리의 데이터는 쉽게 손실될 수 있음
- 전원 공급이 끊어지거나 시스템이 갑자기 고장나면(crash) 메모리의 모든 데이터가 사라짐

<br>

- 하드웨어는 입력/출력(input/output) 혹은 I/O 장치 형태로 제공됨
- 요즘에는 solid-state drives(SSDs)가 많이 사용되고 있지만 장기간 보존할 정보를 저장하는 장치로는 일반적으로 **하드 드라이브(hard drive)** 가 사용됨

<br>

- 디스크를 관리하는 운영체제 소프트웨어를 **파일 시스템(file system)** 이라고 부르며 사용자가 생성한 파일을 시스템의 디스크에 안전하고 효율적인 방식으로 저장할 책임이 있음

<br>

- 운영체제는 프로그램 별로 가상 디스크를 따로 생성하지 않음

<br>

- 시스템 콜(system call)은 운영체제에서 파일 시스템(file system)이라 불리는 부분으로 전달됨
- 파일 시스템은 요청을 처리하고 경우에 따라 사용자에게 에러 코드를 반환

<br>

- 데이터를 디스크에 쓰기 위해서 운영체제가 실제로 하는 일
  - 파일 시스템은 많은 작업을 해야 함
    - 먼저 새 데이터가 디스크의 어디에 저장될지 결정
    - 파일 시스템이 관리하는 다양한 자료 구조를 통하여 데이터의 상태를 추적
  - 이런 작업을 하기 위해서는 저장 장치로부터, 기존 자료 구조를 읽거나 갱신해야 함
  - 운영체제는 시스템 콜이라는 표준화된 방법으로 장치들을 접근할 수 있게 함
  - 운영체제는 **표준 라이브러리(standard library)** 처럼 보이기도 함
 
<br>

- 장치를 접근하는 방법과 파일 시스템이 데이터를 영속적으로 관리하는 방법은 이보다 훨씬 더 복잡함
- 성능향상을 위해서 대부분의 파일 시스템은 쓰기요청을 지연시켜 취합된 요청들을 한 번에 처리
- 쓰기 중에 시스템의 갑작스런 고장에 대비해서 많은 파일 시스템들이 **저널링(journaling)** 이나 **쓰기-시-복사(Copy-On-Write)** 와 같은 복잡한 쓰기 기법을 사용
- 이런 기법들은 쓰기 순서를 적절히 조정하여 고장이 발생하더라도 정상적인 상태로 복구될 수 있게 함
- 효율적인 디스크 작업을 위해 단순 리스트에서 복잡한 B-트리까지 다양한 종류의 자료 구조를 사용



<br>

#### 1-5. 설계 목표
- 운영체제는 CPU, 메모리, 디스크와 같은 물리 자원을 **가상화(virtualize)** 함
- 운영체제는 병행성과 관련된 복잡한 문제를 처리
- 파일을 **영속적**으로 저장하여 아주 오랜 시간 동안 안전한 상태에 있게 함
- 그런 시스템을 구현하려면 몇 가지를 목표를 세워야 하며, 이러한 목표는 설계와 구현에 집중하고 필요한 경우 절충안을 찾는 데 필수적

<br>

- 가장 기본적인 목표는 시스템을 편리하고 사용하기 쉽게 만드는 데 필요한 개념(abstraction)들을 정의
- 컴퓨터 과학에서 추상화는 모든 일에 근간이며 추상화를 통해 큰 프로그램을 이해하기 쉬운 작은 부분들로 나누어 구현할 수 있음
  - 어셈블리 코드를 몰라도 C와 같은 고수준 언어로 큰 프로그램을 작성하는 것이 가능함
  - 추상화는 논리 게이트를 고려하지 않고도 어셈블리 코드를 작성할 수 있게하며, 트랜지스터에 대한 지식없이도 게이트를 이용하여 프로세서를 만들 수 있게 함

<br>

- 운영체제의 설계와 구현에 중요한 목표는 **성능**
- 다른 말로 표현하면 오버헤드를 최소화(minimize the overhead)하는 것
- "가상화"와 "사용하기 쉬운 시스템을 만드는것"은 의미가 있지만 반드시 해야 하는 것은 아님
- 가상화 및 다른 운영체제 기능을 과도한 오버헤드 없이 제공해야 함
- 오버헤드는 시간(더 많은 명령어)과 공간(메모리 또는 디스크)의 형태로 나타남

<br>

- 또 다른 목표는 응용 프로그램 간의 **보호**, 그리고 운영체제와 응용 프로그램 간의 보호
- 다수 프로그램들이 동시에 실행되기 때문에, 운영체제는 한 프로그램의 악의적인 또는 의도치 않은 행위가 다른 프로그램에게 피해를 주지 않는다는 것을 보장해야 함
- 보호는 운영체제의 원칙 중 하나인 **고립(isolation)** 원칙의 핵심이며, 프로세스를 다른 프로세스로부터 고립시키는 일은 보호의 핵심이고 운영체제가 해야 하는 일 중 많은 부분의 근간이 됨

<br>

- 운영체제는 계속 실행되어야 하며, 운영체제가 실패하면 그 위에서 실행되는 모든 응용 프로그램도 실패하게 됨
- 이러한 종속성 때문에 운영체제는 높은 수준의 **신뢰성(reliability)** 을 제공해야 함
- 운영체제가 복잡해질수록 신뢰성 있는 운영체제를 구현하는 일이 매우 어려워짐

<br>

- **에너지-효율성(energy-eiciency)** 은 녹색 세상을 위해 중요함
- 악의적인 응용 프로그램에 대한 **보안(security**, 사실은 보호의 확장)은 현재와 같은 네트워크 환경에서 특히 중요
- **이동성(mobility)** 은 운영체제가 작은 장치에서 사용될수록 중요해지고 있음



<br>
<br>

### 2. 프로세스
- 운영체제가 제공하는 핵심개념 중 하나
- 일반적으로 프로세스는 실행 중인 프로그램으로 정의
  - 프로그램은 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음
  - 이 명령어와 데이터 묶음을 읽고 실행하여 프로그램에 생명을 불어넣는 것이 운영체제

<br>

- 하나의 프로세스를 실행하고, 중단시키고 다른 프로세스를 실행하는 작업을 반복하면서 실제 하나 또는 소수의 CPU로 여러 개의 가상 CPU가 존재하는 듯한 환상을 만들어 냄
  -> **시분할(time sharing)** : 원하는 수 만큼의 프로세스를 동시에 실행할 수 있게 함
      - CPU를 공유하기 때문에 각 프로세스의 성능은 낮아짐

<br>

- 운영체제에서 CPU 가상화를 잘 구현하기 위해 저수준의 도구와 고차원적인 지능이 필요
  - 저수준 도구를 **메커니즘(mechanism)** 이라 함
  - 메커니즘은 필요한 기능을 구현하는 방법이나 규칙을 의미
  - CPU에서 프로그램 실행을 잠시 중단하고 다른 프로그램을 실행하는 것을 **문맥 교환**이라고 함 
  - 이 기법은 모든 현대 운영체제들이 채택하고 있음

<br>

- **시분할**은 자원 공유를 운영체제가 사용하는 가장 기본 기법 중 하나
  - 한 개체가 잠깐 자원을 사용한 후 다른 개체가 또 잠깐 자원을 사용하고 그 다음 개체가 사용하면서 이 자원을 많은 개체들이 공유
- **공간 분할(space sharing)** 은 개체에게 공간을 분할해 줌
  - 공간 분할의 예로 디스크가 있으며 디스크는 자연스럽게 공간 분할할 수 있는 자원으로, 블럭이 하나의 파일에 할당되면 파일을 삭제하기 전에는 다른 파일이 할당될 가능성이 낮음

<br>

- 운영체제의 지능은 **정책(policy)** 의 형태로 표현됨 
  - 정책은 운영체제 내에서 어떤 결정을 내리기 위한 알고리즘


<br>

#### 2-1. 프로세스의 개념
- 운영체제는 실행 중인 프로그램의 개념을 제공하는데 이를 **프로세스(process)**라 함
- 프로세스의 구성 요소를 이해하기 위해서는 **하드웨어 상태(machine state)** 를 이해해야 함
  - 프로그램이 실행되는 동안 하드웨어 상태를 읽거나 갱신할 수 있음

<br>

- 프로세스의 하드웨어 상태 중 가장 중요한 구성 요소는 **메모리**
- 명령어는 메모리에 저장되며 실행 프로그램이 읽고 쓰는 데이터 역시 메모리에 저장됨
- 프로세스가 접근할 수 있는 메모리(**주소 공간(address space)** 이라 불림)는 프로세스를 구성하는 요소

<br>

- 레지스터도 프로세스의 하드웨어 상태를 구성하는 요소 중 하나
- 많은 명령어들이 레지스터를 직접 읽거나 갱신함

<br>

- 프로세스의 하드웨어 상태를 구성하는 레지스터 중에 특별한 레지스터들이 존재
  - **프로그램 카운터(program counter, PC)** 는 프로그램의 어느 명령어가 실행 중인지를 알려줌
    - **명령어 포인터(instruction pointer, IP)** 라고도 불림
  - **스택 포인터(stack pointer)** 와 **프레임 포인터(frame pointer)** 는 함수의 변수와 리턴 주소를 저장하는 스택을 관리할 때 사용하는 레지스터
- 프로그램은 영구 저장장치(persistent storage)에 접근하기도 하는데 이 입출력 정보는 프로세스가 현재 열어 놓은 파일 목록을 가지고 있음



<br>

#### 2-2. 프로세스 API
- 운영체제가 반드시 API로 제공해야 하는 몇몇 기본 기능
  - 생성(Create) : 운영체제는 새로운 프로세스를 생성할 수 있는 방법을 제공해야 함
                  <br> 쉘에 명령어를 입력하거나 응용 프로그램의 아이콘을 더블클릭하여 프로그램을 실행시키면, 운영체제는 새로운 프로세스를 생성
  - 제거(Destroy) : 프로세스를 강제로 제거할 수 있는 인터페이스를 제공해야 함
                  <br> 프로세스가 스스로 종료하지 않으면 사용자는 그 프로세스를 제거하길 원할 것이고, 필요없는 프로세스를 중단시키는 API는 매우 유용
  - 대기(Wait) : 어떤 프로세스의 실행 중지를 기다릴 필요가 있기 때문에 여러 종류의 대기 인터페이스가 제공됨
  - 각종 제어(Miscellaneous Control) : 프로세스의 제거, 대기 이외에 여러 가지 제어 기능들이 제공됨
  - 상태(Status) : 프로세스 상태 정보를 얻어내는 인터페이스도 제공됨
                  <br> 상태 정보에는 얼마 동안 실행되었는지 또는 프로세스가 어떤 상태에 있는지 등이 포함됨


<br>

#### 2-3. 프로세스 생성
- 프로그램 실행을 위하여 운영체제가 하는 첫 번째 작업은 프로그램 코드와 정적 데이터(static data, 예)초기값을 가지는 변수)를 메모리, 프로세스의 주소 공간에 **탑재(load)** 하는 것
- 프로그램은 **디스크** 또는 요즘 시스템에서는 **플래시 기반 SSD** 에 특정 **실행 파일 형식**으로 존재
- 코드와 정적 데이터를 메모리에 탑재하기 위해서 운영체제는 디스크의 해당 바이트를 읽어서 메모리의 어딘가에 저장해야 함

<br>

- 초기 운영체제들은 프로그램 실행 전에 코드와 데이터를 모두 메모리에 탑재했음
- 현대의 운영체제들은 이 작업을 늦추어 프로그램을 실행하면서 코드나 데이터가 필요할 때 필요한 부분만 메모리에 탑재함
  - 코드와 데이터의 늦은 탑재의 동작을 정확하게 이해하기 위해서는 **페이징(paging)** 과 **스와핑(swapping)** 동작의 이해가 필요함

<br>

- 코드와 정적 데이터가 메모리로 탑재된 후, 프로세스를 실행시키기 전에 운영체제가 해야 할 일
  - 일정량의 메모리가 프로그램의 **실행시간 스택(run-time stack, 스택)** 용도로 할당되어야 함
  - 운영체제는 스택을 주어진 인자로 초기화함

<br>

- 운영체제는 프로그램의 **힙(heap)** 을 위한 메모리 영역을 할당
- 힙은 연결 리스트, 해시 테이블, 트리 등 크기가 가변적인 자료 구조를 위해 사용됨

<br>

- 운영체제는 또 입출력과 관계된 초기화 작업을 수행

<br>

- 코드와 정적 데이터를 메모리에 탑재하고 스택과 힙을 생성하고 초기화하고 입출력 셋업과 관계된 다른 작업을 마치게 되면 운영체제는 프로그램 실행을 위한 준비를 마치게 됨
- 프로그램의 시작 지점(entry point), 즉 **main()** 에서부터 프로그램 실행을 시작하는 마지막 작업만이 남음
- main() 루틴으로 분기함으로써 운영체제는 CPU를 새로 생성된 프로세스에게 넘기게 되고 프로그램 실행이 시작됨


<br>

#### 2-4. 프로세스 상태
- 프로세스 상태의 개념은 초기 컴퓨터 시스템에서 등장
- 프로세스 상태를 단순화하면 세 상태 중 하나에 존재할 수 있음
  - 실행(Running) : 실행 상태에서 프로세스는 프로세서에서 실행 중
                  <br> 즉, 프로세스는 명령어를 실행하고 있음
  - 준비(Ready) : 준비 상태에서 프로세스는 실행할 준비가 되어 있지만 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중
  - 대기(Blocked) : 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산

<br>

- 프로세스는 준비 상태와 실행 상태를 운영체제의 정책에 따라 이동함
- 프로세스는 운영체제의 스케줄링 정책에 따라 스케줄이 되면 준비 상태에서 실행 상태로 변환
- 실행 상태에서 준비 상태로의 전이는 프로세스가 나중에 다시 스케줄 될 수 있는 상태가 되었다는 것을 의미
- 프로세스가 입출력 요청 등의 이유로 대기 상태가 되면 요청완료 등의 이벤트가 발생할 때까지 대기 상태로 유지됨
- 이벤트가 발생하면 프로세스는 다시 준비 상태로 전이되고 운영체제의 결정에 따라 바로 다시 실행될 수도 있음

<br>

- 운영체제에는 다양한 중요 자료 구조들이 많이 존재
- 프로세스 리스트가 그 중 첫 번째
  - 이 자료 구조는 단순하며 다수의 프로그램을 동시에 실행할 수 있는 모든 운영체제는 이와 유사한 자료 구조를 가지고 있고, 이 자료 구조를 이용하여 시스템에서 실행 중인 프로그램을 관리
  - 프로세스의 관리를 위한 정보를 저장하는 자료 구조를 **프로세스 제어 블럭(Process Control Block, PCB)**


<br>

#### 2-5. 자료 구조
- 운영체제도 일종의 프로그램으로 다른 프로그램들과 같이 다양한 정보를 유지하기 위한 자료 구조를 가지고 있음
- 프로세스 상태를 파악하기 위해 준비 상태의 프로세스들을 위한 **프로세스 리스트(process list)** 와 같은 자료 구조를 유지
- 어느 프로세스가 실행 중인지를 파악하기 위한 부가적인 자료 구조도 유지

<br>

- **레지스터 문맥(register context)** 자료 구조는 프로세스가 중단되었을 때 해당 프로세스의 레지스터값들을 저장
- 이 레지스터값들을 복원하여 운영체제는 프로세스 실행을 재개 -> **문맥 교환(context switch)**

<br>

- xv6 Proc 구조
  ```
    // 프로세스를 중단하고 이후에 재개하기 위해 xv6가 저장하고 복원하는 레지스터
    struct context {
      int eip;
      int esp;
      int ebx;
      int ecx;
      int edx;
      int esi;
      int edi;
      int ebp;
    };
  
    // 가능한 프로세스 상태
    enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
  
    // 레지스터 문맥과 상태를 포함하여 각 프로세스에 대하여 xv6가 추적하는 정보
    struct proc {
      char *mem;               // 프로세스 메모리 시작 주소
      uint sz;                 // 프로세스 메모리의 크기
      char *kstack;            // 이 프로세스의 커널 스택의 바닥 주소 
      enum proc_state state;   // 프로세스 상태
      int pid;                 // 프로세스 ID
      struct proc *parent;     // 부모 프로세스
      void *chan;              // 0이 아니면 chan에서 대기
      int killed;              // 0이 아니면 종료됨
      struct file *ofile[NOFILE];   // 열린 파일
      struct inode *cwd;       // 현재 디렉터리
      struct context context;  // 프로세스를 실행시키려면 여기로 교환
      struct trapframe *tf;    // 현재 인터럽트에 해당하는 트랩 프레임
    };
  ```


<br>
<br>

### Unix 시스템의 프로세스 생성
#### 1. fork() 시스템 콜
- 프로세스 생성에 fork() 시스템 콜을 사용

  ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    
    int
    main(int argc, char *argv[])
    {
      printf("hello world (pid:%d)\n", (int) getpid());
      int rc = fork();
      if (rc < 0) { 
        fprintf(stderr, "fork failed\n");
        exit(1);
      } else if (rc == 0) { 
        printf("hello, I am child (pid:%d)\n", (int) getpid());
      } else { 
        printf("hello, I am parent of %d (pid:%d)\n", rc, (int) getpid());
      }
      return 0;
    }
  ```

  - 결과

    ```
      hello world (pid:29146)
      hello, I am parent of 29147 (pid:29146)
      hello, I am child (pid:29147)
    ```

  - 실행이 시작될 때 프로세스는 "hello world ..." 메시지를 출력, 이 메시지에는 PID로도 알려진 프로세스 식별자(process identiier)가 포함
  -  프로세스는 fork() 시스템 콜을 호출
    - 생성된 프로세스가 호출한 프로세스의 복사본이라는 것을 확인할 수 있음
    - fork() 호출 직후를 살펴보면 운영체제 입장에서 봤을 때 프로그램 p1이 2개가 존재하며 두 프로세스가 모두 fork()에서 리턴하기 직전이고, 새로 생성된 프로세스는 main()함수 첫 부분부터 시작하지 않았다는 것을 알 수 있음
      <br> -> 자식 프로세스는 fork()를 호출하면서부터 시작되었음
      <br> -> fork() 시스템 콜의 반환 값이 서로 다르며 fork()로 부터 부모 프로세스는 생성된 자식 프로세스의 PID를 반환받고, 자식 프로세스는 0을 반환받음
      

<br>

#### 2. wait() 시스템 콜
- fork()와 wait() 호출

  ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/wait.h>
  
    int
    main(int argc, char *argv[])
    {
      printf("hello world (pid:%d)\n", (int) getpid());
      int rc = fork();
      if (rc < 0) { 
        fprintf(stderr, "fork failed\n");
        exit(1);
      } else if (rc == 0) { 
        printf("hello, I am child (pid:%d)\n", (int) getpid());
      } else { 
        int wc = wait(NULL);
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n", rc, wc, (int) getpid());
      }
      return 0;
    }
  ```

  - 결과
 
    ```
      hello world (pid:29266)
      hello, I am child (pid:29267)
      hello, I am parent of 29267 (wc:29267) (pid:29266)
    ```
    
  - 부모 프로세스는 wait() 시스템 콜을 호출하여 자식 프로세스 종료 시점까지 자신의 실행을 잠시 중지시키며, 자식 프로세스가 종료되면 wait()는 리턴


<br>

#### 3. exec() 시스템 콜
- 프로세스 생성 관련 API 중에서 중요한 시스템 콜은 exec() 시스템 콜
- 이 시스템 콜은 자기 자신이 아닌 다른 프로그램을 실행해야 할 때 사용
- 자신의 복사본이 아닌 다른 프로그램을 실행해야 할 경우에는 exec() 시스템 콜이 그 일을 함
  - fork(), wait(), 및 exec() 호출하기
    ```c
      #include <stdio.h>
      #include <stdlib.h>
      #include <unistd.h>
      #include <string.h>
      #include <sys/wait.h>
      int
      main(int argc, char *argv[])
      {
        printf("hello world (pid:%d)\n", (int) getpid());
        int rc = fork();
        if (rc < 0) { 
          fprintf(stderr, "fork failed\n");
          exit(1);
        } else if (rc == 0) {
          printf("hello, I am child (pid:%d)\n", (int) getpid());
          char *myargs[3];
          myargs[0] = strdup("wc"); 
          myargs[1] = strdup("p3.c"); 
          myargs[2] = NULL; 
          execvp(myargs[0], myargs); 
          printf("this shouldn't print out");
        } else { 
          int wc = wait(NULL);
          printf("hello, I am parent of %d (wc:%d) (pid:%d)\n", rc, wc, (int) getpid());
        }
        return 0;
      }
    ```
    
  - 결과
 
    ```
      hello world (pid:29383)
      hello, I am child (pid:29384)
            29 107 1030 p3.c
      hello, I am parent of 29384 (wc:29384) (pid:29383)
    ```

  - 실행 파일의 이름과(예) wc) 약간의 인자가 (예)p3.c) 주어지면 해당 실행 파일의 코드와 정적 데이터를 읽어 들여 현재 실행 중인 프로세스의 코드 세그멘트와 정적 데이터 부분을 덮어 씀
  - 힙과 스택 및 프로그램 다른 주소 공간들로 새로운 프로그램의 실행을 위해 다시 초기화 됨
  - 그런 다음 운영체제는 프로세스의 argv와 같은 인자를 전달하여 프로그램을 실행시킴
    - 새로운 프로세스를 생성하지는 않으며 현재 실행 중인 프로그램을(p3) 다른 실행 중인 프로그램으로(wc) 대체하는 것
  - 자식 프로세스가 exec()을 호출한 후에는 p3.c는 전혀 실행되지 않은 것처럼 보이며, exec() 시스템 콜이 성공하게 되면 p3.c는 절대로 리턴하지 않음


<br>

- 입출력 재지정의 모든 것
  ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <string.h>
    #include <fcntl.h>
    #include <sys/wait.h>
  
    int
    main(int argc, char *argv[])
    {
      int rc = fork();
      if (rc < 0) {             // fork 실패함; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
      } else if (rc == 0) {     // 자식 : 표준 출력 파일로 재지정
        close(STDOUT_FILENO);
        open("./p4.output", O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);
        
        // exec "wc"...
        char *myargs[3];
        myargs[0] = strdup("wc");     // 프로그램 : "wc"(단어 세기)
        myargs[1] = strdup("p4.c");   // 인자 : 단어 셀 파일
        myargs[2] = NULL;             // 배열의 끝 표시
        execvp(myargs[0], myargs);    // wc 실행
      } else {                   // 부모 프로세스는 이 경로를 따라 실행함(main)
        int wc = wait(NULL);
      }
      return 0;
    }
  ```


<br>

#### 4. 여타 API들
- **kill()** 시스템 콜은 프로세스에게 시그널(signal)을 보내는 데 사용
- 시그널은 프로세스를 중단시키고(block), 삭제하는 등의 작업에 사용
- 시그널이라는 운영체제의 메터니즘은 외부 사건을 프로세스에게 전달하는 토대이며 이 기반 구조는 시그널을 보내거나 전달받는 방법을 모두 포함
