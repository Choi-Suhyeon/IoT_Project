### 1. 운영체제
  - 프로그램은 매우 단순한 일을 함
    - 명령어를 실행
    - 프로세서는 명령어를 초당 수백만 번(요즘은 수십억 번) **반입(fetch)** 하고, **해석(decode)** 하고, **실행(execute)** 함
    - 명령어 작업을 완료한 후 프로세서는 계속 그 다음 명령어로 프로그램이 완전히 종료될 때까지 실행을 계속함
  - 프로그램을 쉽게 실행하고 (심지어 동시에 여러 발의 프로그램을 실행시킬 수도 있음), 프로그램 간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양한 흥미로운 일을 할 수 있게 하는 소프트웨어
  - 시스템을 사용하기 편리하면서 정확하고 올바르게 동작시킬 책임이 있기 때문에 소프트웨어를 운영체제(operating system, OS)라고 부름

<br>

  - 운영체제는 언급했던 일들을 하기 위하여 **가상화(virtualization)** 라고 불리는 기법을 사용
  - 운영체제는 프로세서, 메모리, 또는 디스크와 같은 물리적(physical)인 자원을 이용하여 일반적이고, 강력하고, 사용이 편리한 가상(virtual) 형태의 자원을 생성
    => 때로는 **가상 머신(virtual machine)** 이라고 부름

<br>

  - 사용자 프로그램의 프로그램 실행, 메모리 할당, 파일 접근과 같은 가상 머신과 관련된 기능들을 운영체제에게 요청할 수 있도록, 운영체제는 사용자에게 API를 제공
  - 보통 운영체제는 응용 프로그램이 사용 가능한 수백 개의 **시스템 콜**을 제공
  - 운영체제가 프로그램 실행, 메모리와 장치에 접근, 기타 이와 관련된 여러 작업을 진행하기 위해 시스템 콜을 제공하기 때문에, 우리는 운영체제가 표준 라이브러리(standard library)를 제공한다고도 함

<br>

  - 가상화는 많은 프로그램들이 CPU를 공유하여, 동시에 실행될 수 있게 함
    - 프로그램들이 각자 명령어와 데이터를 접근할 수 있게 함
    - 프로그램들이 디스크등의 장치를 공유할 수 있게 함
    => 운영체제는 자원 관리자(resource manager)라고도 불림

<br>

  - CPU, 메모리, 및 디스크는 시스템의 자원이므로 효율적으로, 공정하게 자원을 관리하는 것이 운영체제의 역할

<br>

#### 1-1. CPU 가상화
- **Spin()** 1초 동안 실행된 후 리턴하는 함수

- cpu.c
  ```c
    #include <stdio.h>
    #include <stdlib.h>
    #include <sys/time.h>
    #include <assert.h>
    #include "common.h"
    int
    main(int argc, char *argv[])
    {
      if (argc != 2) {
        fprintf(stderr, "usage: cpu <string>\n");
        exit(1);
      }
      char *str = argv[1];
      while (1) {
        Spin(1);
        printf("%s\n", str);
      }
      return 0;
    }
  ```

  - 단일 프로세서
    ```
      prompt> gcc −o cpu cpu.c −Wall
      prompt> ./cpu“A ”
      A
      A
      A
      A
      ∧C
      prompt>
    ```

  - 여러 인스턴스를 동시에 실행
    ```
      prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
      [1] 7353
      [2] 7354
      [3] 7355
      [4] 7356
      A
      B
      D
      C
      A
      B
      D
      C
      A
      C
      B
      D
      ...
    ```

=> 하나의 CPU 또는 소규모 CPU 집합을 무한개의 CPU가 존재하는 것처럼 변환하여 동시에 많은 수의 프로그램을 실행시키는 것 -> **CPU 가상화(virtualizing the CPU)**


<br>

#### 1-2. 메모리 가상화
- 현재 우리가 사용하고 있는 컴퓨터에서의 **물리 메모리(physical memory)** 모델은 매우 단순 -> 바이트의 배열
- 메모리를 읽기 위해서는 데이터에 **주소(address)** 를 명시해야 함
- 메모리에 쓰기 (혹은 갱신) 위해서는 주소와 데이터를 명시해야 함

- 메모리는 프로그램이 실행되는 동안 항상 접근됨
- 프로그램은 실행 중에 자신의 모든 자료 구조를 메모리에 유지하고 load와 store 또는 기타 메모리 접근을 위한 명령어를 통하여 자료 구조에 접근
- 명령어 역시 메모리에 존재하며 명령어를 반입할 때마다 메모리가 접근됨

<br>

- 메모리 접근 프로그램
  - mem.c
    ```
      #include <unistd.h>
      #include <stdio.h>
      #include <stdlib.h>
      #include "common.h"
      int
      main(int argc, char *argv[])
      {
        int *p = malloc(sizeof(int)); // a1
        assert(p != NULL);
        printf("(%d) memory address of p: %08x\n", getpid() , (unsigned) p); // a2
        *p = 0; // a3
        while (1) {
          Spin(1);
          *p = *p + 1;
          printf("(%d) p: %d\n", getpid() , *p); // a4
        }
        return 0;
      }
    ```

    - 출력 결과
      ```
        prompt> ./mem
        (2134) memory address of p: 00200000
        (2134) p: 1
        (2134) p: 2
        (2134) p: 3
        (2134) p: 4
        (2134) p: 5
        ∧C
      ```
      - 우선 메모리를 할당 받음 (a1 행)
      - 그런 후 할당받은 메모리의 주소를 출력 (a2)
      - 새로 할당받은 메모리의 첫 슬롯에 숫자 0을 넣음 (a3)
      - 마지막으로 루프로 진입하여 1초 대기 후, 변수 p가 가리키는 주소에 저장되어 있는 값을 1 증가시킴
      - 출력할 때마다 실행 중인 프로그램의 프로세스 식별자(PID : 프로세스의 고유의 값) 값이 함께 출력

    - 메모리 프로그램 여러 번 실행
      ```
        prompt> ./mem &; ./mem &
        [1] 24113
        [2] 24114
        (24113) memory address of p: 00200000
        (24114) memory address of p: 00200000
        (24113) p: 1
        (24114) p: 1
        (24114) p: 2
        (24113) p: 2
        (24113) p: 3
        (24114) p: 3
        (24113) p: 4
        (24114) p: 4
        ...
      ```

  - 각 프로세스는 자신만의 **(가상) 주소 공간(virtual address space)** 을 갖음
  - 운영체제는 이 가상 주소 공간을 컴퓨터의 물리 메모리로 매핑(mapping) 함
  - 하나의 프로그램이 수행하는 각종 메모리 연산은 다른 프로그램의 주소 공간에 영향을 주지 않음
  - 실제로는 물리 메모리는 공유 자원이고, 운영체제에 의해 관리됨


<br>

#### 1-3. 병행성
- 프로그램이 한 번에 많은 일을하려 할 때 (즉, 동시에) 발생하는 그리고 반드시 해결해야 하는 문제들을 가리킬 때 사용
- 병행성 문제는 우선 운영체제 자체에서 발생
- 병행성 문제는 운영체제만의 문제는 아니며 **멀티 쓰레드** 프로그램도 동일한 문제

- 여러개의 명령어가 **원자적(atomically)** 으로 (한 번에 여러개 모두) 실행되지 않으면, 명령어가 한 번에 하나씩만 실행되기 때문에 문제가 발생 할 수 있음


<br>

#### 1-4. 영속성
- DRAM과 같은 장치는 데이터를 휘발성(volatile) 방식으로 저장하기 때문에 메모리의 데이터는 쉽게 손실될 수 있음
- 전원 공급이 끊어지거나 시스템이 갑자기 고장나면(crash) 메모리의 모든 데이터가 사라짐

<br>

- 하드웨어는 입력/출력(input/output) 혹은 I/O 장치 형태로 제공됨
- 요즘에는 solid-state drives(SSDs)가 많이 사용되고 있지만 장기간 보존할 정보를 저장하는 장치로는 일반적으로 **하드 드라이브(hard drive)** 가 사용됨

<br>

- 디스크를 관리하는 운영체제 소프트웨어를 **파일 시스템(file system)** 이라고 부르며 사용자가 생성한 파일을 시스템의 디스크에 안전하고 효율적인 방식으로 저장할 책임이 있음

<br>

- 운영체제는 프로그램 별로 가상 디스크를 따로 생성하지 않음

<br>

- 시스템 콜(system call)은 운영체제에서 파일 시스템(file system)이라 불리는 부분으로 전달됨
- 파일 시스템은 요청을 처리하고 경우에 따라 사용자에게 에러 코드를 반환

<br>

- 데이터를 디스크에 쓰기 위해서 운영체제가 실제로 하는 일
  - 파일 시스템은 많은 작업을 해야 함
    - 먼저 새 데이터가 디스크의 어디에 저장될지 결정
    - 파일 시스템이 관리하는 다양한 자료 구조를 통하여 데이터의 상태를 추적
  - 이런 작업을 하기 위해서는 저장 장치로부터, 기존 자료 구조를 읽거나 갱신해야 함
  - 운영체제는 시스템 콜이라는 표준화된 방법으로 장치들을 접근할 수 있게 함
  - 운영체제는 **표준 라이브러리(standard library)** 처럼 보이기도 함
 
<br>

- 장치를 접근하는 방법과 파일 시스템이 데이터를 영속적으로 관리하는 방법은 이보다 훨씬 더 복잡함
- 성능향상을 위해서 대부분의 파일 시스템은 쓰기요청을 지연시켜 취합된 요청들을 한 번에 처리
- 쓰기 중에 시스템의 갑작스런 고장에 대비해서 많은 파일 시스템들이 **저널링(journaling)** 이나 **쓰기-시-복사(Copy-On-Write)** 와 같은 복잡한 쓰기 기법을 사용
- 이런 기법들은 쓰기 순서를 적절히 조정하여 고장이 발생하더라도 정상적인 상태로 복구될 수 있게 함
- 효율적인 디스크 작업을 위해 단순 리스트에서 복잡한 B-트리까지 다양한 종류의 자료 구조를 사용



<br>

#### 1-5. 설계 목표
- 운영체제는 CPU, 메모리, 디스크와 같은 물리 자원을 **가상화(virtualize)** 함
- 운영체제는 병행성과 관련된 복잡한 문제를 처리
- 파일을 **영속적**으로 저장하여 아주 오랜 시간 동안 안전한 상태에 있게 함
- 그런 시스템을 구현하려면 몇 가지를 목표를 세워야 하며, 이러한 목표는 설계와 구현에 집중하고 필요한 경우 절충안을 찾는 데 필수적

<br>

- 가장 기본적인 목표는 시스템을 편리하고 사용하기 쉽게 만드는 데 필요한 개념(abstraction)들을 정의
- 컴퓨터 과학에서 추상화는 모든 일에 근간이며 추상화를 통해 큰 프로그램을 이해하기 쉬운 작은 부분들로 나누어 구현할 수 있음
  - 어셈블리 코드를 몰라도 C와 같은 고수준 언어로 큰 프로그램을 작성하는 것이 가능함
  - 추상화는 논리 게이트를 고려하지 않고도 어셈블리 코드를 작성할 수 있게하며, 트랜지스터에 대한 지식없이도 게이트를 이용하여 프로세서를 만들 수 있게 함

<br>

- 운영체제의 설계와 구현에 중요한 목표는 **성능**
- 다른 말로 표현하면 오버헤드를 최소화(minimize the overhead)하는 것
- "가상화"와 "사용하기 쉬운 시스템을 만드는것"은 의미가 있지만 반드시 해야 하는 것은 아님
- 가상화 및 다른 운영체제 기능을 과도한 오버헤드 없이 제공해야 함
- 오버헤드는 시간(더 많은 명령어)과 공간(메모리 또는 디스크)의 형태로 나타남

<br>

- 또 다른 목표는 응용 프로그램 간의 **보호**, 그리고 운영체제와 응용 프로그램 간의 보호
- 다수 프로그램들이 동시에 실행되기 때문에, 운영체제는 한 프로그램의 악의적인 또는 의도치 않은 행위가 다른 프로그램에게 피해를 주지 않는다는 것을 보장해야 함
- 보호는 운영체제의 원칙 중 하나인 **고립(isolation)** 원칙의 핵심이며, 프로세스를 다른 프로세스로부터 고립시키는 일은 보호의 핵심이고 운영체제가 해야 하는 일 중 많은 부분의 근간이 됨

<br>

- 운영체제는 계속 실행되어야 하며, 운영체제가 실패하면 그 위에서 실행되는 모든 응용 프로그램도 실패하게 됨
- 이러한 종속성 때문에 운영체제는 높은 수준의 **신뢰성(reliability)** 을 제공해야 함
- 운영체제가 복잡해질수록 신뢰성 있는 운영체제를 구현하는 일이 매우 어려워짐

<br>

- **에너지-효율성(energy-eiciency)** 은 녹색 세상을 위해 중요함
- 악의적인 응용 프로그램에 대한 **보안(security**, 사실은 보호의 확장)은 현재와 같은 네트워크 환경에서 특히 중요
- **이동성(mobility)** 은 운영체제가 작은 장치에서 사용될수록 중요해지고 있음

