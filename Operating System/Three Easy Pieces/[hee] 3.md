### 1. 스케줄링 : 비례 배분
- 반환 시간이나 응답 시간을 최적화하는 대신 스케줄러가 각 작업에게 CPU의 일정 비율을 보장하는 것이 목적
- 비례 배분 스케줄링의 좋은 예가 Waldspurger and Weihl의 연구의 연구로 **추첨 스케줄링(lottery scheduling)** 으로 알려져 있으며 이 아이디어는 꽤 오래됨
  - 다음 실행될 프로세스를 추첨을 통해 결정하며, 더 자주 수행되어야 하는 프로세스는 당첨 기회를 더 많이 줌 

<br>

#### 1.1. 추첨권이 당신의 몫을 나타낸다
- 추첨권(티켓)이라는 기본적인 개념이 추첨 스케줄링의 근간을 이루며, 추첨권은 프로세스가 받아야 할 자원의 몫을 나타내는 데 사용됨
- 프로세스가 소유한 티켓의 개수와 전체 티켓에 대한 비율이 자신의 몫을 나타냄

<br>

- 추첨 스케줄링은 이러한 목적을 (타임 슬라이스가 끝날 때마다) 확률적으로 (하지만 결정적이지는 않게) 달성함
- 무작위성은 원하는 비율을 정확히 보장하지는 않지만 작업이 장시간 실행될수록, 원하는 비율을 달성할 가능성이 높아짐


<br>

#### 1.2. 추첨 기법
- 추첨권을 다루는 다양한 기법 중 **추첨권 화폐(ticket currency)** 의 개념은 사용자가 추첨권을 자신의 화폐 가치로 추첨권을 자유롭게 할당할 수 있도록 허용함
- 시스템은 자동적으로 화폐 가치를 변환함
  ```
    User A −> 500 (A's currency) to A1 −> 50 (global currency)
           −> 500 (A's currency) to A2 −> 50 (global currency)
    User B −> 10 (B's currency) to B1 −> 100 (global currency)
  ```

<br>

- 다른 유용한 기법은 **추첨권 양도(ticket transfer)**
  - 양도를 통하여 프로세스는 일시적으로 추첨권을 다른 프로세스에게 넘겨줄 수 있음
  - 이 기능은 클라이언트/서버 환경에서 특히 유용
    - 클라이언트 프로세스는 서버에게 메시지를 보내 자신을 대신해 특정 작업을 해달라고 요청
    - 작업이 빨리 완료될 수 있도록 클라이언트는 서버에게 추첨권을 전달하고 서버가 자신의 요청을 수행하는 동안 서버의 성능을 극대화하려고 함
    - 요청을 완수하면 서버는 추첨권을 다시 클라이언트에게 되돌려 줌

<br>

- 마지막으로, **추첨권 팽창(ticket inlation)** 도 유용하게 사용됨
  - 이 기법에서 프로세스는 일시적으로 자신이 소유한 추첨권의 수를 늘이거나 줄일 수 있음
  - 화폐 팽창 기법은 프로세스들이 서로 신뢰할 때 유용하며, 그런 경우 어떤 프로세스가 더 많은 CPU 시간을 필요로 한다면 시스템에게 이를 알리는 방법으로 다른 프로세스들과 통신하지 않고 혼자 추첨권의 가치를 상향 조정함



<br>

#### 1.3. 구현
- 추첨 스케줄링의 가장 큰 장점은 구현이 단순하다는 점
- 필요한 것은 난수 발생기와 프로세스들의 집합을 표현하는 자료 구조(예, 리스트), 추첨권의 전체 개수 뿐

<br>

- 추첨 스케줄링 결정 코드
  ```
    // 리스트를 사용하여 프로세스를 관리한다고 가정
    //A, B, C 세 개의 프로세스로 구성되고 각자 몇 장의 추첨권을 가짐
    // counter : 당첨자를 발견했는지 추적하는데 사용됨
    int counter = 0;
    
    // winner : 0부터 총 추첨권의 수 사이의 임의의 값을 얻기 위해 난수 발생기를 호출함
    int winner = getrandom(0, totaltickets);
    
    // current : 작업 목록을 탐색하는데 사용
    node_t *current = head;
    
    // 티켓 값 > winner를 만족할 때까지 반복
    while (current) {
      counter = counter + current−>tickets;
      if (counter > winner)
        break;      // 당첨자 발견
      current = current−>next;
    }
    // "current"는 당첨자를 가리킴 : 당첨자가 실행될 수 있도록 준비
  ```
  - 일반적으로 리스트를 내림차순으로 정렬하면 이 과정이 가장 효율적이 되며 정렬 순서는 알고리즘의 정확성에 영향을 주지는 않음
  - 그러나 리스트를 정렬해 놓으면 검색 횟수가 최소화되는 것을 보장함
    - 특히, 적은 수의 프로세스가 대부분의 추첨권을 소유하고 있는 경우에 효과적


<br>

#### 1.4. 추첨권 배분 방식
- 추첨 스케줄링에서 아직 언급하지 않은 문제는 추첨권을 작업에게 나누어주는 방식
- 시스템 동작이 추첨권 할당 방식에 따라 크게 달라지기 때문에 상당히 어려운 문제
- 한 가지 접근 방식은 사용자가 가장 잘 알고 있다고 가정하는 것
  - 각 사용자에게 추첨권을 나누어 준 후 사용자가 알아서 실행시키고자 하는 작업들에게 추첨권을 배분하는 것
- 하지만 이건 해결책이 아니며 주어진 작업 집합에 대한 추첨권 할당 문제는 여전히 미해결 상태


<br>

#### 1.6. 왜 결정론적(Deterministic) 방법을 사용하지 않는가
- 무작위성을 이용하면 스케줄러를 단순하게(그러나 어느 정도 정확하게) 만들 수 있지만, 정확한 비율을 보장할 수 없으며 짧은 기간만 실행되는 경우는 더 그렇게 됨
- 이 때문에 Waldspurger는 결정론적 공정 배분 스케줄러인 **보폭 스케줄링(stride scheduling)** 을 고안하였음

- 보폭 스케줄링
  - 시스템의 각 작업은 보폭을 가지고 있으며, 보폭은 자신이 가지고 있는 추첨권 수에 반비례하는 값
  - 프로세스가 실행될때마다 pass라는 값을 보폭만큼 증가시켜 얼마나 CPU를 사용하였는지를 추적
  - 스케줄러는 보폭과 pass 값을 사용하여 어느 프로세스를 실행시킬지 결정함
  - 가장 작은 pass 값을 가진 프로세스를 선택하며, 프로세스를 실행시킬 때마다 pass 값을 보폭만큼씩 증가시킴
  - Waldspurger가 작성한 의사코드
    ```
      current = remove_min(queue);   // pass 값이 최소인 클라이언트로 선택
      schedule(current);     // 자원을 타임 퀀텀만큼 선택된 프로세스에게 할당
      current−>pass += current−>stride;     // ݅다음 pass 값을 보폭 값을 이용하여 갱신
      insert(queue, current);     // ݅다시 큐에 저
    ```

- 추첨 스케줄링은 정해진 비율에 따라 확률적으로 CPU를 배분하며, 보폭 스케줄링은 각 스케줄링 주기마다 정확한 비율로 CPU를 배분함
- 추첨 스케줄링에서는 새 프로세스를 쉽게 추가할 수 있지만, 보폭 스케줄링은 어려움
- 둘 다 개념적으로 흥미롭지만 여러 이유로 CPU 스케줄러로서 널리 사용되고 있지 않음
  - 이유는 이러한 접근 방식이 특히 입출력과 맞물렸을 때, 제대로 동작하지 않는다는 것
  - 또 다른 이유는 추첨권 할당이라는 어려운 문제가 미해결 상태로 남아있다는 것
- 비례 배분 스케줄러는 추첨권 할당량을 비교적 정확하게 결정할 수 있는 환경에서 유용하게 사용됨
- 예를 들어, 가상화 데이터 센터에서 Windows 가상 머신에 CPU 사이클의 1/4을 할당하고 나머지는 Linux 시스템에 할당하고 싶은 경우 비례 배분이 간단하고 효과적임








