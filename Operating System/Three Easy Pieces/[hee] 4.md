### 1. 주소 변환의 원리
- **하드웨어-기반 주소 변환(hardware-based address translation)** 또는 짧게 **주소 변환(address translation)**
  - 이 기술은 제한적 직접 실행 방식에 부가적으로 사용되는 기능이라고 생각할 수 있으며, 주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장 등의 **가상** 주소를 정보가 실제 존재하는 **물리** 주소로 변환함
  - 프로그램의 모든 메모리 참조를 실제 메모리 위치로 재지정하기 위하여 하드웨어가 주소를 변환함



<br>

#### 1.1. 사례
- 메모리에서 값을 탑재하고, 3을 증가시키고, 다시 메모리에 저장하는 짧은 코드
  ```c
    void func() {
      int x = 3000;
      x = x + 3; 
  ```

<br>

- 컴파일러는 이 코드를 어셈블리 코드로 변환하고 그 결과는 x86 어셈블리로 다음과 같을 것
  ```
    128 : movl 0x0(\%ebx) , \%eax ; 0+ebx를 eax에 저장
    132 : addl \$0x03, \%eax ; eax 레지스터에 3을 더함 
    135 : movl \%eax, 0x0(\%ebx) ; eax를 메모리에 다시 저장
  ```
- 이 명령어가 실행되면 프로세스의 관점에서 아래와 같은 메모리 접근이 일어남
  • 주소 128의 명령어를 반입
  • 이 명령어 실행 (주소 15KB에서 탑재)
  • 주소 132의 명령어를 반입
  • 이 명령어 실행 (메모리 참조 없음)
  • 주소 135의 명령어를 반입
  • 이 명령어 실행 (15KB에 저장)

<br>

- 프로그램 관점에서 주소 공간은 주소 0부터 시작하여 최대 16KB까지
- 프로그램이 생성하는 모든 메모리 참조는 이 범위 내에 있어야 함



<br>

#### 1.2. 동적 (하드웨어-기반) 재배치
- 하드웨어 기반 주소 변환을 이해하기 위해 첫 번째 실현 사례 설명
  - 1950년대 후반의 첫 번째 시분할 컴퓨터에서 **베이스와 바운드(base and bound)** 라는 간단한 아이디어가 채택되었음
  - 이 기술은 또한 **동적 재배치(dynamic relocation)** 라고 함
  - 각 CPU마다 2개의 하드웨어 레지스터가 필요함
  - 하나는 **베이스(base)** 레지스터라고 불리고, 다른 하나는 **바운드(bound)** 레지스터 혹은 **한계(limit)** 레지스터라고 불림
  - 이 베이스와 바운드 쌍은 우리가 원하는 위치에 주소 공간을 배치할 수 있게함
  - 배치와 동시에 프로세스가 오직 자신의 주소 공간에만 접근한다는 것을 보장함
  - 이 설정에서 각 프로그램은 주소 0에 탑재되는 것처럼 작성되고 컴파일되며, 프로그램 시작 시 운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정하고 베이스 레지스터를 그 주소로 지정함
  -  프로세스에 의해 생성되는 모든 주소가 아래와 같은 방법으로 프로세서에 의해 **변환** 됨
    ```
      physical address = virtual address + base
    ```
    - 프로세스가 생성하는 메모리 참조는 **가상 주소**이며, 하드웨어는 베이스 레지스터의 내용을 이 주소에 더하여 **물리 주소**를 생성함

<br>

  - 가상 주소에서 물리 주소로의 변환이 **주소 변환**이라고 부르는 기술
  - 이 주소의 재배치는 실행 시에 일어나고 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기 때문에 **동적 재배치(dynamic relocation)** 라고도 불림

<br>

  - 바운드 레지스터는 보호를 지원하기 위해 존재함
  - 프로세서는 먼저 메모리 참조가 합법적인가를 확인하기 위해 가상 주소가 바운드 안에 있는지 확인함
  - 프로세스가 바운드보다 큰 가상주소 또는 음수인 가상 주소를 참조하면 CPU는 예외를 발생시키고 프로세스는 종료될 것임
  - 바운드의 요점은 프로세스가 생성한 모든 주소가 합법적이고 프로세스의 '범위'에 있다는 것을 확인하는 것

<br>

  - 베이스와 바운드 레지스터는 CPU 칩 상에 존재하는 하드웨어 구조임을 주의해야 하며(CPU당 1쌍), 주소 변환에 도움을 주는 프로세서의 일부를 **메모리 관리 장치(memory management unit, MMU)** 라고도 함

<br>

  - 바운드 레지스터는 두 가지 방식 중 하나로 정의될 수 있음
    - 첫 번째 방법은 앞에서 처럼 주소 공간의 크기를 저장하는 방식으로 하드웨어는 가상 주소를 베이스 레지스터에 더하기 전에 먼저 바운드 레지스터와 비교함
    - 두 번째 방식은 주소 공간의 마지막 물리 주소를 저장하는 방식으로 하드웨어는 먼저 베이스 레지스터를 더하고 그 결과가 바운드 안에 있는지 검사함
  - 두 방법 모두 논리적으로는 동일함
  


<br>

#### 1.3. 하드웨어 지원 : 요약
- 동적 재배치 : 하드웨어 요구사항
  ```
     하드웨어 요구사항                    노트
    =====================================================================================
     특권 모드                           사용자 모드 프로세스가 특권 연산을 실행하는 것을
                                         방지하기 위해 필요
    -------------------------------------------------------------------------------------
     베이스/바운드 레지스터              주소 변환과 범위 검사를 지원하기 위하여 CPU 당
                                         한 쌍의 레지스터가 필요
    -------------------------------------------------------------------------------------
     가상 주소를 변환하고 범위 안에      주소 변환과 범위 검사를 위한 회로. 매우 간단함
     있는지 검사하는 능력
    -------------------------------------------------------------------------------------
     베이스/바운드를 갱신하기 위한       프로그램 시작 전에 운영체제가 베이스와 바운드
     특권 명령어                         레지스터 값을 지정할 수 있어야 함
    -------------------------------------------------------------------------------------
     예외 핸들러 등록을 위한 특권        운영체제가 예외 처리 코드를 하드웨어에게 알려줄
     명령어                              수 있어야 함
    -------------------------------------------------------------------------------------
     예외 발생 기능                      프로세스가 특권 명령어 실행을 시도하거나 범위를
                                         벗어난 메모리의 접근을 시도할 때 예외를 
                                         발생시킬수 있어야 함
  ```



<br>

#### 1.4. 운영체제 이슈
- 동적 재배치 : 운영체제 책임
  ```
     운영체제 요구사항           노트
    ==============================================================================
     메모리 관리                 새 프로세스의 메모리 할당에 필요 
                                 종료 프로세스로부터 메모리 회수 
                                 빈 공간 리스트를 통한 일반적인 메모리 관리
    ------------------------------------------------------------------------------
     베이스/바운드 관리          문맥 교환 시 올바르게 베이스/바운드 설정
    ------------------------------------------------------------------------------
     예외 처리                   예외가 발생할 때 실행할 코드
                                 범법 프로세스를 종료하는 것이 가능성이 높은 처리
  ```



<br>

#### 1.5. 요약
- 제한된 실행 프로토콜 (동적 재배치)
  ```
     운영체제 @부트                           하드웨어
     (커널 모드)
    ------------------------------------------------------------------------------------------
     트랩 테이블을 초기화
                                              다음의 주소를 기억
                                                시스템 콜 핸들러
                                                타이머 핸들러
                                                불법적인 메모리 접근 핸들러
                                                불법적인 명령어 핸들러
     인터럽트 타이머 시작
                                              타이머 시작. X msec 후에 인터럽트
     프로세스 테이블 초기화
     빈 공간 리스트 초기화


     운영체제 @실행                             하드웨어                                   프로그램
     (커널 모드)                                                                           (사용자 모드)
    ---------------------------------------------------------------------------------------------------------------
     프로세스 A를 시작하기 위해 :
       프로세스 테이블의 항목 할당
       프로세스 메모리 할당
       베이스/바운드 레지스터 설정
       return-from-trap (A로)
                                                A의 레지스터 복원
                                                사용자 모드로 이동
                                                A의 (시작) PC로 분기
                                                                                          프로세스 A 실행
                                                                                          명령어 반입
                                                가상 주소 변환 및 반입 실행
                                                                                          명령어 실행
                                                명시적 탑재/저장이라면
                                                  주소가 범위 안 인지 확인
                                                  가상 주소 변환 및 탑재/저장 실행
                                                                                          ...
                                                타이머 인터럽트
                                                커널 모드로 이동
                                                인터럽트 핸들러로 분기
     트랩 처리
     switch() 루틴 호출
       A의 레지스터를 A의 proc-struct에
        저장 (베이스/바운드 포함)
       B의 레지스터를 B의 proc-struct에서
        복원 (베이스/바운드 포함)
     return-from-trap (B로)
                                                B의 레지스터 복원
                                                사용자 모드로 이동
                                                B의 PC로 분기
                                                                                          프로세스 B 실행
                                                                                            불법적인 탑재 실행
                                                바운드-밖 탑재
                                                커널 모드로 이동
                                                트랩 핸들러로 분기
     트랩 처리
       프로세스 B 종료시키기로 결정
       B의 메모리 회수
       프로세스 테이블의 B의 항목 해제
  ```






























