### 1. 주소 변환의 원리
- **하드웨어-기반 주소 변환(hardware-based address translation)** 또는 짧게 **주소 변환(address translation)**
  - 이 기술은 제한적 직접 실행 방식에 부가적으로 사용되는 기능이라고 생각할 수 있으며, 주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장 등의 **가상** 주소를 정보가 실제 존재하는 **물리** 주소로 변환함
  - 프로그램의 모든 메모리 참조를 실제 메모리 위치로 재지정하기 위하여 하드웨어가 주소를 변환함



<br>

#### 1.1. 사례
- 메모리에서 값을 탑재하고, 3을 증가시키고, 다시 메모리에 저장하는 짧은 코드
  ```c
    void func() {
      int x = 3000;
      x = x + 3; 
  ```

<br>

- 컴파일러는 이 코드를 어셈블리 코드로 변환하고 그 결과는 x86 어셈블리로 다음과 같을 것
  ```
    128 : movl 0x0(\%ebx) , \%eax ; 0+ebx를 eax에 저장
    132 : addl \$0x03, \%eax ; eax 레지스터에 3을 더함 
    135 : movl \%eax, 0x0(\%ebx) ; eax를 메모리에 다시 저장
  ```
- 이 명령어가 실행되면 프로세스의 관점에서 아래와 같은 메모리 접근이 일어남
  • 주소 128의 명령어를 반입
  • 이 명령어 실행 (주소 15KB에서 탑재)
  • 주소 132의 명령어를 반입
  • 이 명령어 실행 (메모리 참조 없음)
  • 주소 135의 명령어를 반입
  • 이 명령어 실행 (15KB에 저장)

<br>

- 프로그램 관점에서 주소 공간은 주소 0부터 시작하여 최대 16KB까지
- 프로그램이 생성하는 모든 메모리 참조는 이 범위 내에 있어야 함



<br>

#### 1.2. 동적 (하드웨어-기반) 재배치
- 하드웨어 기반 주소 변환을 이해하기 위해 첫 번째 실현 사례 설명
  - 1950년대 후반의 첫 번째 시분할 컴퓨터에서 **베이스와 바운드(base and bound)** 라는 간단한 아이디어가 채택되었음
  - 이 기술은 또한 **동적 재배치(dynamic relocation)** 라고 함
  - 각 CPU마다 2개의 하드웨어 레지스터가 필요함
  - 하나는 **베이스(base)** 레지스터라고 불리고, 다른 하나는 **바운드(bound)** 레지스터 혹은 **한계(limit)** 레지스터라고 불림
  - 이 베이스와 바운드 쌍은 우리가 원하는 위치에 주소 공간을 배치할 수 있게함
  - 배치와 동시에 프로세스가 오직 자신의 주소 공간에만 접근한다는 것을 보장함
  - 이 설정에서 각 프로그램은 주소 0에 탑재되는 것처럼 작성되고 컴파일되며, 프로그램 시작 시 운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정하고 베이스 레지스터를 그 주소로 지정함
  -  프로세스에 의해 생성되는 모든 주소가 아래와 같은 방법으로 프로세서에 의해 **변환** 됨
    ```
      physical address = virtual address + base
    ```
    - 프로세스가 생성하는 메모리 참조는 **가상 주소**이며, 하드웨어는 베이스 레지스터의 내용을 이 주소에 더하여 **물리 주소**를 생성함

<br>

  - 가상 주소에서 물리 주소로의 변환이 **주소 변환**이라고 부르는 기술
  - 이 주소의 재배치는 실행 시에 일어나고 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기 때문에 **동적 재배치(dynamic relocation)** 라고도 불림

<br>

  - 바운드 레지스터는 보호를 지원하기 위해 존재함
  - 프로세서는 먼저 메모리 참조가 합법적인가를 확인하기 위해 가상 주소가 바운드 안에 있는지 확인함
  - 프로세스가 바운드보다 큰 가상주소 또는 음수인 가상 주소를 참조하면 CPU는 예외를 발생시키고 프로세스는 종료될 것임
  - 바운드의 요점은 프로세스가 생성한 모든 주소가 합법적이고 프로세스의 '범위'에 있다는 것을 확인하는 것

<br>

  - 베이스와 바운드 레지스터는 CPU 칩 상에 존재하는 하드웨어 구조임을 주의해야 하며(CPU당 1쌍), 주소 변환에 도움을 주는 프로세서의 일부를 **메모리 관리 장치(memory management unit, MMU)** 라고도 함

<br>

  - 바운드 레지스터는 두 가지 방식 중 하나로 정의될 수 있음
    - 첫 번째 방법은 앞에서 처럼 주소 공간의 크기를 저장하는 방식으로 하드웨어는 가상 주소를 베이스 레지스터에 더하기 전에 먼저 바운드 레지스터와 비교함
    - 두 번째 방식은 주소 공간의 마지막 물리 주소를 저장하는 방식으로 하드웨어는 먼저 베이스 레지스터를 더하고 그 결과가 바운드 안에 있는지 검사함
  - 두 방법 모두 논리적으로는 동일함
  


<br>

#### 1.3. 하드웨어 지원 : 요약
- 동적 재배치 : 하드웨어 요구사항
  ```
     하드웨어 요구사항                    노트
    =====================================================================================
     특권 모드                           사용자 모드 프로세스가 특권 연산을 실행하는 것을
                                         방지하기 위해 필요
    -------------------------------------------------------------------------------------
     베이스/바운드 레지스터              주소 변환과 범위 검사를 지원하기 위하여 CPU 당
                                         한 쌍의 레지스터가 필요
    -------------------------------------------------------------------------------------
     가상 주소를 변환하고 범위 안에      주소 변환과 범위 검사를 위한 회로. 매우 간단함
     있는지 검사하는 능력
    -------------------------------------------------------------------------------------
     베이스/바운드를 갱신하기 위한       프로그램 시작 전에 운영체제가 베이스와 바운드
     특권 명령어                         레지스터 값을 지정할 수 있어야 함
    -------------------------------------------------------------------------------------
     예외 핸들러 등록을 위한 특권        운영체제가 예외 처리 코드를 하드웨어에게 알려줄
     명령어                              수 있어야 함
    -------------------------------------------------------------------------------------
     예외 발생 기능                      프로세스가 특권 명령어 실행을 시도하거나 범위를
                                         벗어난 메모리의 접근을 시도할 때 예외를 
                                         발생시킬수 있어야 함
  ```



<br>

#### 1.4. 운영체제 이슈
- 동적 재배치 : 운영체제 책임
  ```
     운영체제 요구사항           노트
    ==============================================================================
     메모리 관리                 새 프로세스의 메모리 할당에 필요 
                                 종료 프로세스로부터 메모리 회수 
                                 빈 공간 리스트를 통한 일반적인 메모리 관리
    ------------------------------------------------------------------------------
     베이스/바운드 관리          문맥 교환 시 올바르게 베이스/바운드 설정
    ------------------------------------------------------------------------------
     예외 처리                   예외가 발생할 때 실행할 코드
                                 범법 프로세스를 종료하는 것이 가능성이 높은 처리
  ```



<br>

#### 1.5. 요약
- 제한된 실행 프로토콜 (동적 재배치)
  ```
     운영체제 @부트                           하드웨어
     (커널 모드)
    ------------------------------------------------------------------------------------------
     트랩 테이블을 초기화
                                              다음의 주소를 기억
                                                시스템 콜 핸들러
                                                타이머 핸들러
                                                불법적인 메모리 접근 핸들러
                                                불법적인 명령어 핸들러
     인터럽트 타이머 시작
                                              타이머 시작. X msec 후에 인터럽트
     프로세스 테이블 초기화
     빈 공간 리스트 초기화


     운영체제 @실행                             하드웨어                                   프로그램
     (커널 모드)                                                                           (사용자 모드)
    ---------------------------------------------------------------------------------------------------------------
     프로세스 A를 시작하기 위해 :
       프로세스 테이블의 항목 할당
       프로세스 메모리 할당
       베이스/바운드 레지스터 설정
       return-from-trap (A로)
                                                A의 레지스터 복원
                                                사용자 모드로 이동
                                                A의 (시작) PC로 분기
                                                                                          프로세스 A 실행
                                                                                          명령어 반입
                                                가상 주소 변환 및 반입 실행
                                                                                          명령어 실행
                                                명시적 탑재/저장이라면
                                                  주소가 범위 안 인지 확인
                                                  가상 주소 변환 및 탑재/저장 실행
                                                                                          ...
                                                타이머 인터럽트
                                                커널 모드로 이동
                                                인터럽트 핸들러로 분기
     트랩 처리
     switch() 루틴 호출
       A의 레지스터를 A의 proc-struct에
        저장 (베이스/바운드 포함)
       B의 레지스터를 B의 proc-struct에서
        복원 (베이스/바운드 포함)
     return-from-trap (B로)
                                                B의 레지스터 복원
                                                사용자 모드로 이동
                                                B의 PC로 분기
                                                                                          프로세스 B 실행
                                                                                            불법적인 탑재 실행
                                                바운드-밖 탑재
                                                커널 모드로 이동
                                                트랩 핸들러로 분기
     트랩 처리
       프로세스 B 종료시키기로 결정
       B의 메모리 회수
       프로세스 테이블의 B의 항목 해제
  ```






<br>
<br>

### 2. 세그멘테이션
- 스택과 힙 사이의 공간은 사용되지 않더라도 주소 공간을 물리 메모리에 재배치할 때 물리 메모리를 차지함
- 베이스와 바운드 레지스터 방식은 메모리 낭비가 심하며 또한, 주소 공간이 물리 메모리보다 큰 경우 실행이 매우 어려움
- 이런 측면에서 볼 때 베이스와 바운드 방식은 유연성이 없음


<br>

#### 2.1. 세그멘테이션 : 베이스/바운드(base/bound)의 일반화
- 이 문제를 해결하기 위한 아이디어가 바로 **세그멘테이션(segmentat-ion)**
- MMU 안에 오직 하나의 베이스와 바운드 쌍만 존재하는 것이 아니라 주소 공간의 논리적인 **세그멘트(segment)** 마다 베이스와 바운드 쌍이 존재함
- 세그멘트는 특정 길이를 가지는 연속적인 주소 공간이며, 세그멘테이션을 사용하면 운영체제는 각 세그멘트를 물리 메모리의 각기 다른 위치에 배치할 수 있고 사용되지 않는 가상 주소 공간이 물리 메모리를 차지하는 것을 방지할 수 있음
- **세그멘트 위반(segment violation)** 또는 **세그멘트 폴트(segment fault)** : 세그멘트 사용 시스템에서 불법적인 주소 접근 시 발생



<br>

#### 2.2. 스택
- 다른 세그멘트들과는 다르게 반대 방향으로 확장이 되며, 다른 방식의 변환이 필요
  - 간단한 하드웨어가 추가로 필요함
    - 베이스와 바운드 값뿐 아니라 하드웨어는 세그멘트가 어느 방향으로 확장하는지도 알아야 함
    - 하드웨어는 세그멘트가 반대 방향으로 늘어날 수 있다는 것을 알고 있기 때문에, 그런 가상 주소에 대해서는 다른 방식으로 변환함



<br>

#### 2.3. 공유 지원
- 세그멘테이션 기법이 발전함에 따라 시스템 설계자들은 간단한 하드웨어 지원으로 새로운 종류의 효율성을 성취할 수 있다는 것을 깨달음
- 구체적으로, 메모리를 절약하기 위해 때로는 주소 공간들 간에 특정 메모리 세그멘트를 공유하는 것이 유용함
- 특히, 코드 공유가 일반적이며, 현재 시스템에서도 광범위하게 사용 중
- 공유를 지원하기 위해, 하드웨어에 protection bit의 추가가 필요하며, 세그멘트마다 protection bit를 추가하여 세그멘트를 읽거나 쓸 수 있는지 혹은 세그멘트의 코드를 실행시킬 수 있는지를 나타냄

<br>

- 코드 세그멘트를 읽기 전용으로 설정하면 주소 공간의 독립성을 유지하면서도 여러 프로세스가 주소 공간의 일부를 공유할 수 있음
- 각 프로세스는 여전히 자신의 전용 메모리를 사용하고 있다고 생각하지만 운영체제는 이 변경이 불가능하도록 설정된 메모리 영역을 비밀리에 공유시켜 그러한 환상을 유지토록 함
- protection bit를 사용하면 앞서 언급한 하드웨어 알고리즘이 수정되어야 함
- 가상 주소가 범위 내에 있는지 확인하는 것 이외에 특정 액세스가 허용되는지를 확인해야 함
- 사용자 프로세스가 읽기 전용 페이지에 쓰기를 시도하는 경우 또는 실행 불가 페이지에서 실행하려고 하면 하드웨어는 예외를 발생시켜서 운영체제가 위반 프로세스를 처리할 수 있게 해야 함




<br>

#### 2.4. 소단위 대 대단위 세그멘테이션
- 지금까지 소수의 세그멘트(즉, 코드, 스택, 힙)만을 지원하는 시스템에만 주로 초점을 맞추었는데, 이 세그멘테이션을 **대단위(coarse-grained)** 라고 생각 할 수 있음
  - 주소 공간을 비교적 큰 단위의 공간으로 분할하기 때문
- 일부 초기 시스템 (예, Multics)은 주소 공간을 작은 크기의 공간으로 잘게 나누는 것이 허용되었기 때문에, **소단위(ine-grained)** 세그멘테이션이라고 부름

<br>

- 많은 수의 세그멘트를 지원하기 위해서는 여러 세그멘트의 정보를 메모리에 저장할 수 있는 세그멘트 테이블 같은 하드웨어가 필요함
- 세그멘트 테이블을 이용하면 매우 많은 세그멘트를 손쉽게 생성하고 융통성 있게 세그멘트를 사용할 수 있음




<br>

#### 2.5. 운영체제의 지원
- 시스템이 각 주소 공간 구성 요소를 별도로 물리 메모리에 재배치하기 때문에 전체 주소 공간이 하나의 베이스-바운드 쌍을 가지는 간단한 방식에 비해 물리 메모리를 엄청나게 절약할 수 있음
- 구체적으로는 스택과 힙 사이의 사용하지 않는 공간에 물리 메모리를 할당할 필요가 없기 때문에 같은 크기의 물리 메모리에 더 많은 주소 공간을 탑재할 수 있음

<br>

- 세그멘테이션은 새로운 많은 문제를 제기함
- 해결해야 할 새로운 운영체제 문제
  - 처음 문제는 오래된 문제로 문맥 교환 시 운영체제는 어떤 일을 해야 하는가? 
    - 세그멘트 레지스터의 저장과 복원
    - 각 프로세스는 자신의 가상 주소 공간을 가지며, 운영체제는 프로세스가 다시 실행하기 전에 레지스터들을 올바르게 설정해야 함
  - 두 번째, 더욱 중요한 문제는 미사용 중인 물리 메모리 공간의 관리
    - 새로운 주소 공간이 생성되면 운영체제는 이 공간의 세그멘트를 위한 비어있는 물리 메모리 영역을 찾을 수 있어야 함
    - 물리 메모리는 프로세스가 탑재될 슬롯의 집합이라고 생각될 수 있었으며, 지금은 프로세스가 많은 세그멘트를 가질 수 있고 각 세그멘트는 크기가 다를 수 있음

<br>

- 일반적으로 생길 수 있는 문제는 물리 메모리가 빠르게 작은 크기의 빈 공간들로 채워진다는 것
- 이 작은 빈 공간들은 새로이 생겨나는 세그멘트에 할당하기도 힘들거니와 기존 세그멘트를 확장하는 데에도 도움이 되지 않음
- 이 문제를 **외부 단편화(external fragmentation)** 라고 부름
- 이 문제의 해결책 중 한 가지는 기존의 세그멘트를 정리하여 물리 메모리를 **압축(compact)** 하는 것
  - 예를 들어 운영체제는 현재 실행 중인 프로세스를 중단하고, 그들의 데이터를 하나의 연속된 공간에 복사하고, 세그멘트 레지스터가 새로운 물리 메모리 위치를 가리키게 하여, 자신이 작업할 큰 빈 공간을 확보할 수 있음
  - 이렇게 함으로써 운영체제는 새로운 할당 요청을 충족시킬 수 있음
  - 하지만 세그멘트 복사는 메모리에 부하가 큰 연산이고 일반적으로 상당량의 프로세서 시간을 사용하기 때문에 압축은 비용이 많이듬
- 간단한 방법은 빈 공간 리스트를 관리하는 알고리즘을 사용하는 것
  - 빈 공간 관리 알고리즘은 할당 가능한 메모리 영역들을 리스트 형태로 유지함
  - **최적 적합(best-it)**, **최악 적합(worst-it)**, **최초 적합(irst-it)** 및 **버디 알고리즘(buddy algorithm)** 과 같은 고전적인 알고리즘을 포함하여 말 그대로 수백 개의 방식이 존재함
  - 이 중에서 최적 적합은 빈 공간 리스트에서 요청된 크기와 가장 비슷한 크기의 공간을 할당함
- 알고리즘이 아무리 정교하게 동작한다고 해도 외부 단편화는 여전히 존재하며, 좋은 알고리즘은 외부 단편화를 가능한 줄이는 것이 목표







<br>
<br>

### 3. 빈 공간 관리
#### 3.1. 가정
- 힙의 빈 공간을 관리하는 데는 일반적인 링크드리스트가 사용됨
- 이 자료 구조는 영역 내의 모든 빈 청크에 대한 주소를 갖고 있음
- 물론, 이 자료 구조는 반드시 리스트일 필요는 없고 빈 공간들을 표현할 수 있는 자료 구조면 충분함




<br>

#### 3.2. 저수준 기법들
- **분할(splitting)** 과 **병합(coalescing)**
  - 메모리를 1바이트만 요청했다고 가정할때, 이 경우 할당기는 분할(splitting) 작업을 수행
    - 요청을 만족시킬 수 있는 빈 청크를 찾아 이를 둘로 분할하고, 첫 번째 청크는 호출자에게 반환되고 두 번째 청크는 리스트에 남게 됨
    - 요청이 특정 빈 청크의 크기보다 작은 경우 분할 기법을 사용
  - 분할에 당연히 동반되는 기법은 빈 공간의 병합(coalescing)
    - 메모리 청크를 반환할 때 해제되는 청크의 주소와 바로 인접한 빈 청크의 주소를 살펴본 뒤, 새로 해제된 빈 공간이 왼쪽의 빈 청크와 바로 인접해 있다면(혹은 양쪽으로) 그들을 하나의 더 큰 빈 청크로 병합함
    - 병합 기법을 사용하여 할당기가 커다란 빈 공간을 응용 프로그램에게 제공할 수 있다는 것을 더 보장할 수 있음


<br>
  
- 할당된 공간의 크기 파악
  - free(void *ptr) 인터페이스는 크기를 매개변수로 받지 않으며, 포인터가 인자로 전달되면 malloc 라이브러리는 해제되는 메모리 영역의 크기를 신속히 파악하여 그 공간을 빈 공간 리스트에 추가시킬 수 있다고 가정함
  - 이 작업을 위해 대부분의 할당기는 추가 정보를 **헤더(header)** 블럭에 저장함
  - 헤더 블럭은 메모리에 유지되며 보통 해제된 청크 바로 직전에 위치함

<br>
  
  - 헤더는 적어도 할당된 공간의 크기는 저장해야하며, 또한 해제 속도를 향상시키기 위한 추가의 포인터, 부가적인 무결성 검사를 제공하기 위한 매직 넘버, 및 기타 정보를 저장할 수 있음
  - 할당 영역의 크기와 매직 넘버를 저장하는 간단한 헤더 코드
    ```
      typedef struct _ _header_t {
        int size;
        int magic;
      } header_t;
    ```
  - 사용자가 free(ptr)을 호출하면 라이브러리는 헤더의 시작 위치를 파악하기 위해 간단한 포인터 연산을 함
    ```
      void free(void *ptr) {
        header_t *hptr = (void *)ptr − sizeof(header_t);
        ...
    ```
  - 헤더를 가리키는 포인터를 얻어 내면, 라이브러리는 매직 넘버가 기대하는 값과 일치하는지 비교하여 **안전성 검사(sanity check)** 를 실시함
    ```
      assert(hptr->magic == 1234567)
    ```
  - 그리고 새로 해제된 영역의 크기를 간단한 수학을 통해 계산함(즉, 헤더의 크기를 영역의 크기에 더함)
  - 주의할 점이 있는데 빈 영역의 크기는 헤더 크기 더하기 사용자에게 할당된 영역의 크기가 됨
  - 사용자가 N 바이트의 메모리 청크를 요청하면 라이브러리는 크기 N의 빈 청크를 찾는 것이 아니라 빈 청크의 크기 N 더하기 헤더의 크기인 청크를 탐색함


<br>

- 빈 공간 리스트 내장
  - 보통 새로운 노드를 위한 공간이 필요할 때 malloc()을 호출하지만, 불행하게도 메모리 할당 라이브러리 루틴에서는 이것이 불가능
  - 대신 빈 공간 내에 리스트를 구축해야 함
  - 빈 공간 리스트로 관리하기 위해서 먼저 리스트를 초기화하는 코드
    ```
      typedef struct _ _node_t {
        int size;
        struct _ _node_t *next;
      } node_t;
    ```
  - 힙을 초기화하고 힙에 빈 공간 리스트의 첫 번째 원소를 넣는 코드
  - 힙은 시스템 콜 mmap()을 호출하여 얻어진 영역에 구축된다고 가정
    ```
      // mmap()이 빈 공간의 청크에 대한 포인터를 반환
      node_t *head = mmap(NULL, 4096, PROT_READ|PROT_WRITE,
                            MAP_ANON|MAP_PRIVATE, −1, 0);
      head−>size = 4096 − sizeof(node_t);
      head−>next = NULL;
    ```  


<br>

- 힙의 확장
  - 힙 공간이 부족한 경우에 가장 쉬운 방법은 단순히 실패를 반환하는 것
  - 어떤 경우에는 이 방법이 유일한 대안이며, 따라서 NULL을 반환하는 것은 훌륭한 접근법
  - 대부분의 전통적인 할당기는 적은 크기의 힙으로 시작하여 모두 소진하면 운영체제로부터 더 많은 메모리를 요청함
  - 할당기는 힙을 확장하기 위하여 특정 시스템 콜 (예, 대부분의 Unix 시스템에서는 sbrk)을 호출함
  - 그런 후 확장된 영역에서 새로운 청크를 할당함
  - sbrk 요청을 수행하기 위해 운영체제는 빈 물리 페이지를 찾아 요청 프로세스의 주소 공간에 매핑한 후, 새로운 힙의 마지막 주소를 반환함
  - 이제부터 더 큰 힙을 사용할 수 있고 요청은 성공적으로 충족될 수 있음




<br>

#### 3.3. 기본 전략
- 빈 공간 할당을 위한 기본 전략
  - **최적 적합(Best Fit)**
    - 최적 적합 전략은 매우 간단함
    - 먼저 빈 공간 리스트를 검색하여 요청한 크기와 같거나 더 큰 빈 메모리 청크를 찾음
    - 그 후, 후보자 그룹 중에서 가장 작은 크기의 청크를 반환하며 이 청크는 최적 청크(최소 적합)라고 불림
    - 빈 공간 리스트를 한 번만 순회하면 반환할 정확한 블럭을 찾을 수 있음
    - 최적 적합의 배경은, 사용자가 요청한 크기에 가까운 블럭을 반환함으로써 최적 적합은 공간의 낭비를 줄이려고 노력함
    - 그러나 이에는 비용이 수반되며, 정교하지 않은 구현은 해당 빈 블럭을 찾기 위해 항상 전체를 검색해야 하기 때문에 엄청난 성능 저하를 초래함
  
<br>
    
  - **최악 적합(Worst Fit)**
    - 최악 적합은 최적 적합의 반대 방식으로, 가장 큰 빈 청크를 찾아 요청된 크기 만큼만 반환하고 남는 부분은 빈 공간 리스트에 계속 유지함
    - 최악 적합은 최적 적합 방식에서 발생할 수 있는 수많은 작은 청크 대신에 커다란 빈 청크를 남기려고 시도함
    - 그러나 다시 한 번 항상 빈 공간 전체를 탐색해야 하기 때문에 이 방법 역시 높은 비용을 지불해야 함
    - 설상가상으로 대부분의 연구에서 엄청난 단편화가 발생하면서 오버헤드도 여전히 크다는 것을 볼 수 있음
 
<br>
     
  - **최초 적합(First Fit)**
    - 최초 적합은 간단하게 요청보다 큰 첫 번째 블럭을 찾아서 요청만큼 반환함
    - 앞과같이 남은 빈 공간은 후속 요청을 위해 계속 유지됨
    - 최초 적합은 속도가 빠르다는 것이 장점으로, 원하는 블럭을 찾기 위해 항상 빈 공간 리스트 전체를 탐색할 필요가 없음
    - 그러나 때때로 리스트의 시작에 크기가 작은 객체가 많이 생길 수 있음
    - 따라서 할당기가 빈 공간 리스트의 순서를 관리하는 방법이 쟁점
      - 한 가지 방법은 주소-기반 정렬(address-based ordering)을 사용하는 것
      - 리스트를 주소로 정렬하여 병합을 쉽게 하고, 단편화로 감소시킴
 
<br>
 
  - **다음 적합(Next Fit)**
    - 다음 적합 알고리즘은 마지막으로 찾았던 원소를 가리키는 추가의 포인터를 유지함
    - 아이디어는 빈 공간 탐색을 리스트 전체에 더 균등하게 분산시키는 것
    - 그래서 리스트의 첫 부분에만 단편이 집중적으로 발생하는 것을 방지
    - 이러한 접근 방식은 전체 탐색을 하지 않기 때문에 최초 적합의 성능과 비슷함




<br>

#### 3.4. 다른 접근법
- 위에서 설명한 기본적인 접근 방식 외에도 메모리 할당을 향상시키기 위한 기술과 알고리즘이 제안되었음
- **개별 리스트**
  - 한 동안 유행했던 방법은 별도의 개별 리스트(segregated list)를 사용하는 것
  - 기본적인 아이디어는 간단하며, 특정 응용 프로그램이 한두 개 자주 요청하는 크기가 있다면 그 크기의 객체를 관리하기 위한 별도의 리스트를 유지하는 것
  - 다른 모든 요청은 더 일반적인 메모리 할당기에게 전달됨
  
  - 이 방법의 장점은 분명하며, 특정 크기의 요청을 위한 메모리 청크를 유지함으로써 단편화 가능성을 상당히 줄일 수 있음
  - 요청된 크기의 청크만이 존재하기 때문에 복잡한 리스트 검색이 필요하지 않으므로 할당과 해제 요청을 신속히 처리할 수 있음
  - 하지만 이 방법은 시스템에 새로운 문제를 야기함
    - 지정된 크기의 메모리 풀과 일반적인 풀에 얼마만큼의 메모리를 할당해야 하는가?
    - 특수목적 할당기인 **슬랩 할당기(slab allocator)** 는 이 문제를 더 나은 방법으로 해결함

  - 커널이 부팅될 때 커널 객체를 위한 여러 **객체 캐시(object cache)** 를 할당함
  - 커널 객체란 락, 파일 시스템 아이노드 등 자주 요청되는 자료 구조들을 일컫음
  - 객체 캐시는 지정된 크기의 객체들로 구성된 빈 공간 리스트이고 메모리 할당 및 해제 요청을 빠르게 서비스 하기 위해 사용됨
  - 아이노드들로 구성된 객체 캐시가 있고, 락 구조만을 담고있는 객체 캐시도 있음
  - 기존에 할당된 캐시 공간이 부족하면 상위 메모리 할당기에게 추가 **슬랩**을 요청함
    - 요청의 전체 크기는 페이지 크기의 정수배
  - 반대로, 슬랩 내 객체들에 대한 참조 횟수가 0이 되면 상위 메모리 할당기는 이 슬랩을 회수할 수 있음
    - VM 시스템이 더 많은 메모리를 필요할 때 실제 회수가 일어남

  - 슬랩 할당 방식은 빈 객체들을 사전에 초기화된 상태로 유지한다는 점에서 개별 리스트 방식보다 우수함
  - 반납된 객체들을 초기화된 상태로 리스트에 유지하여 슬랩 할당기는 객체당 잦은 초기화와 반납의 작업을 피할 수 있어서 오버헤드를 현저히 감소시킴

- **버디 할당**
  - 빈 공간의 합병은 할당기의 매우 중요한 기능이기 때문에 합병을 간단히 하는 방법들이 설계되었음
  - 하나의 좋은 예가 **이진 버디 할당기(binary buddy allocator)**
  - 빈 메모리는 처음에 개념적으로 크기 2^N인 하나의 큰 공간으로 생각되며, 메모리 요청이 발생하면 요청을 충족시키기에 충분한 공간이 발견될 때까지(그리고 더 분할하면 공간이 너무 작아져서 요청을 만족시킬 수 없을 때까지) 빈 공간을 2개로 계속 분할함
  - 이 시점에서 요청된 블럭이 사용자에게 반환됨
  - 이 방식은 2의 거듭제곱 크기 만큼의 블럭만 할당할 수 있기 때문에 내부 단편화로 고생할 수 있다는 점에 유의해야 함
  - 버디 할당의 아름다움은 블럭이 해제될때 인데, 같은 크기의 버디가 비어 있는지 확인하고 비어있다면 두 블럭을 병합하며 끝까지 계속 반복
  - 이 재귀 합병 과정은 트리를 따라 전체 빈 공간이 복원되거나 버디가 사용 중이라는 것이 밝혀질 때까지 계속 올라감
  - 버디 할당이 잘 작동하는 이유는 특정 블럭의 버디를 결정하는 것이 쉽다는 데 있음

- 기타 아이디어
- 앞에서 설명한 접근 방식들의 한 가지 문제점은 확장성이며, 빈 공간들의 개수가 늘어남에 따라 리스트 검색이 매우 느려질 수 있음
- 좀 더 정교한 할당기는 복잡한 자료 구조를 사용하여 이 비용을 줄임
- 단순함과 성능을 교환함
- 균형 이진 트리(balanced binary tree), 스플레이 트리(splay tree), 또는 부분 정렬 트리(partially ordered tree)가 좋은 예


