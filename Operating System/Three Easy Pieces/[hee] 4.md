### 1. 주소 변환의 원리
- **하드웨어-기반 주소 변환(hardware-based address translation)** 또는 짧게 **주소 변환(address translation)**
  - 이 기술은 제한적 직접 실행 방식에 부가적으로 사용되는 기능이라고 생각할 수 있으며, 주소 변환을 통해 하드웨어는 명령어 반입, 탑재, 저장 등의 **가상** 주소를 정보가 실제 존재하는 **물리** 주소로 변환함
  - 프로그램의 모든 메모리 참조를 실제 메모리 위치로 재지정하기 위하여 하드웨어가 주소를 변환함



<br>

#### 1.1. 사례
- 메모리에서 값을 탑재하고, 3을 증가시키고, 다시 메모리에 저장하는 짧은 코드
  ```c
    void func() {
      int x = 3000;
      x = x + 3; 
  ```

<br>

- 컴파일러는 이 코드를 어셈블리 코드로 변환하고 그 결과는 x86 어셈블리로 다음과 같을 것
  ```
    128 : movl 0x0(\%ebx) , \%eax ; 0+ebx를 eax에 저장
    132 : addl \$0x03, \%eax ; eax 레지스터에 3을 더함 
    135 : movl \%eax, 0x0(\%ebx) ; eax를 메모리에 다시 저장
  ```
- 이 명령어가 실행되면 프로세스의 관점에서 아래와 같은 메모리 접근이 일어남
  • 주소 128의 명령어를 반입
  • 이 명령어 실행 (주소 15KB에서 탑재)
  • 주소 132의 명령어를 반입
  • 이 명령어 실행 (메모리 참조 없음)
  • 주소 135의 명령어를 반입
  • 이 명령어 실행 (15KB에 저장)

<br>

- 프로그램 관점에서 주소 공간은 주소 0부터 시작하여 최대 16KB까지
- 프로그램이 생성하는 모든 메모리 참조는 이 범위 내에 있어야 함



<br>

#### 1.2. 동적 (하드웨어-기반) 재배치
- 하드웨어 기반 주소 변환을 이해하기 위해 첫 번째 실현 사례 설명
  - 1950년대 후반의 첫 번째 시분할 컴퓨터에서 **베이스와 바운드(base and bound)** 라는 간단한 아이디어가 채택되었음
  - 이 기술은 또한 **동적 재배치(dynamic relocation)** 라고 함
  - 각 CPU마다 2개의 하드웨어 레지스터가 필요함
  - 하나는 **베이스(base)** 레지스터라고 불리고, 다른 하나는 **바운드(bound)** 레지스터 혹은 **한계(limit)** 레지스터라고 불림
  - 이 베이스와 바운드 쌍은 우리가 원하는 위치에 주소 공간을 배치할 수 있게함
  - 배치와 동시에 프로세스가 오직 자신의 주소 공간에만 접근한다는 것을 보장함
  - 이 설정에서 각 프로그램은 주소 0에 탑재되는 것처럼 작성되고 컴파일되며, 프로그램 시작 시 운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정하고 베이스 레지스터를 그 주소로 지정함
  -  프로세스에 의해 생성되는 모든 주소가 아래와 같은 방법으로 프로세서에 의해 **변환** 됨
    ```
      physical address = virtual address + base
    ```
    - 프로세스가 생성하는 메모리 참조는 **가상 주소**이며, 하드웨어는 베이스 레지스터의 내용을 이 주소에 더하여 **물리 주소**를 생성함

<br>

  - 가상 주소에서 물리 주소로의 변환이 **주소 변환**이라고 부르는 기술
  - 이 주소의 재배치는 실행 시에 일어나고 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있기 때문에 **동적 재배치(dynamic relocation)** 라고도 불림

<br>

  - 바운드 레지스터는 보호를 지원하기 위해 존재함
  - 프로세서는 먼저 메모리 참조가 합법적인가를 확인하기 위해 가상 주소가 바운드 안에 있는지 확인함
  - 프로세스가 바운드보다 큰 가상주소 또는 음수인 가상 주소를 참조하면 CPU는 예외를 발생시키고 프로세스는 종료될 것임
  - 바운드의 요점은 프로세스가 생성한 모든 주소가 합법적이고 프로세스의 '범위'에 있다는 것을 확인하는 것

<br>

  - 베이스와 바운드 레지스터는 CPU 칩 상에 존재하는 하드웨어 구조임을 주의해야 하며(CPU당 1쌍), 주소 변환에 도움을 주는 프로세서의 일부를 **메모리 관리 장치(memory management unit, MMU)** 라고도 함

<br>

  - 바운드 레지스터는 두 가지 방식 중 하나로 정의될 수 있음
    - 첫 번째 방법은 앞에서 처럼 주소 공간의 크기를 저장하는 방식으로 하드웨어는 가상 주소를 베이스 레지스터에 더하기 전에 먼저 바운드 레지스터와 비교함
    - 두 번째 방식은 주소 공간의 마지막 물리 주소를 저장하는 방식으로 하드웨어는 먼저 베이스 레지스터를 더하고 그 결과가 바운드 안에 있는지 검사함
  - 두 방법 모두 논리적으로는 동일함
  


<br>

#### 1.3. 하드웨어 지원 : 요약
- 동적 재배치 : 하드웨어 요구사항
  ```
     하드웨어 요구사항                    노트
    =====================================================================================
     특권 모드                           사용자 모드 프로세스가 특권 연산을 실행하는 것을
                                         방지하기 위해 필요
    -------------------------------------------------------------------------------------
     베이스/바운드 레지스터              주소 변환과 범위 검사를 지원하기 위하여 CPU 당
                                         한 쌍의 레지스터가 필요
    -------------------------------------------------------------------------------------
     가상 주소를 변환하고 범위 안에      주소 변환과 범위 검사를 위한 회로. 매우 간단함
     있는지 검사하는 능력
    -------------------------------------------------------------------------------------
     베이스/바운드를 갱신하기 위한       프로그램 시작 전에 운영체제가 베이스와 바운드
     특권 명령어                         레지스터 값을 지정할 수 있어야 함
    -------------------------------------------------------------------------------------
     예외 핸들러 등록을 위한 특권        운영체제가 예외 처리 코드를 하드웨어에게 알려줄
     명령어                              수 있어야 함
    -------------------------------------------------------------------------------------
     예외 발생 기능                      프로세스가 특권 명령어 실행을 시도하거나 범위를
                                         벗어난 메모리의 접근을 시도할 때 예외를 
                                         발생시킬수 있어야 함
  ```



<br>

#### 1.4. 운영체제 이슈
- 동적 재배치 : 운영체제 책임
  ```
     운영체제 요구사항           노트
    ==============================================================================
     메모리 관리                 새 프로세스의 메모리 할당에 필요 
                                 종료 프로세스로부터 메모리 회수 
                                 빈 공간 리스트를 통한 일반적인 메모리 관리
    ------------------------------------------------------------------------------
     베이스/바운드 관리          문맥 교환 시 올바르게 베이스/바운드 설정
    ------------------------------------------------------------------------------
     예외 처리                   예외가 발생할 때 실행할 코드
                                 범법 프로세스를 종료하는 것이 가능성이 높은 처리
  ```



<br>

#### 1.5. 요약
- 제한된 실행 프로토콜 (동적 재배치)
  ```
     운영체제 @부트                           하드웨어
     (커널 모드)
    ------------------------------------------------------------------------------------------
     트랩 테이블을 초기화
                                              다음의 주소를 기억
                                                시스템 콜 핸들러
                                                타이머 핸들러
                                                불법적인 메모리 접근 핸들러
                                                불법적인 명령어 핸들러
     인터럽트 타이머 시작
                                              타이머 시작. X msec 후에 인터럽트
     프로세스 테이블 초기화
     빈 공간 리스트 초기화


     운영체제 @실행                             하드웨어                                   프로그램
     (커널 모드)                                                                           (사용자 모드)
    ---------------------------------------------------------------------------------------------------------------
     프로세스 A를 시작하기 위해 :
       프로세스 테이블의 항목 할당
       프로세스 메모리 할당
       베이스/바운드 레지스터 설정
       return-from-trap (A로)
                                                A의 레지스터 복원
                                                사용자 모드로 이동
                                                A의 (시작) PC로 분기
                                                                                          프로세스 A 실행
                                                                                          명령어 반입
                                                가상 주소 변환 및 반입 실행
                                                                                          명령어 실행
                                                명시적 탑재/저장이라면
                                                  주소가 범위 안 인지 확인
                                                  가상 주소 변환 및 탑재/저장 실행
                                                                                          ...
                                                타이머 인터럽트
                                                커널 모드로 이동
                                                인터럽트 핸들러로 분기
     트랩 처리
     switch() 루틴 호출
       A의 레지스터를 A의 proc-struct에
        저장 (베이스/바운드 포함)
       B의 레지스터를 B의 proc-struct에서
        복원 (베이스/바운드 포함)
     return-from-trap (B로)
                                                B의 레지스터 복원
                                                사용자 모드로 이동
                                                B의 PC로 분기
                                                                                          프로세스 B 실행
                                                                                            불법적인 탑재 실행
                                                바운드-밖 탑재
                                                커널 모드로 이동
                                                트랩 핸들러로 분기
     트랩 처리
       프로세스 B 종료시키기로 결정
       B의 메모리 회수
       프로세스 테이블의 B의 항목 해제
  ```






<br>
<br>

### 2. 세그멘테이션
- 스택과 힙 사이의 공간은 사용되지 않더라도 주소 공간을 물리 메모리에 재배치할 때 물리 메모리를 차지함
- 베이스와 바운드 레지스터 방식은 메모리 낭비가 심하며 또한, 주소 공간이 물리 메모리보다 큰 경우 실행이 매우 어려움
- 이런 측면에서 볼 때 베이스와 바운드 방식은 유연성이 없음


<br>

#### 2.1. 세그멘테이션 : 베이스/바운드(base/bound)의 일반화
- 이 문제를 해결하기 위한 아이디어가 바로 **세그멘테이션(segmentat-ion)**
- MMU 안에 오직 하나의 베이스와 바운드 쌍만 존재하는 것이 아니라 주소 공간의 논리적인 **세그멘트(segment)** 마다 베이스와 바운드 쌍이 존재함
- 세그멘트는 특정 길이를 가지는 연속적인 주소 공간이며, 세그멘테이션을 사용하면 운영체제는 각 세그멘트를 물리 메모리의 각기 다른 위치에 배치할 수 있고 사용되지 않는 가상 주소 공간이 물리 메모리를 차지하는 것을 방지할 수 있음
- **세그멘트 위반(segment violation)** 또는 **세그멘트 폴트(segment fault)** : 세그멘트 사용 시스템에서 불법적인 주소 접근 시 발생



<br>

#### 2.2. 스택
- 다른 세그멘트들과는 다르게 반대 방향으로 확장이 되며, 다른 방식의 변환이 필요
  - 간단한 하드웨어가 추가로 필요함
    - 베이스와 바운드 값뿐 아니라 하드웨어는 세그멘트가 어느 방향으로 확장하는지도 알아야 함
    - 하드웨어는 세그멘트가 반대 방향으로 늘어날 수 있다는 것을 알고 있기 때문에, 그런 가상 주소에 대해서는 다른 방식으로 변환함



<br>

#### 2.3. 공유 지원
- 세그멘테이션 기법이 발전함에 따라 시스템 설계자들은 간단한 하드웨어 지원으로 새로운 종류의 효율성을 성취할 수 있다는 것을 깨달음
- 구체적으로, 메모리를 절약하기 위해 때로는 주소 공간들 간에 특정 메모리 세그멘트를 공유하는 것이 유용함
- 특히, 코드 공유가 일반적이며, 현재 시스템에서도 광범위하게 사용 중
- 공유를 지원하기 위해, 하드웨어에 protection bit의 추가가 필요하며, 세그멘트마다 protection bit를 추가하여 세그멘트를 읽거나 쓸 수 있는지 혹은 세그멘트의 코드를 실행시킬 수 있는지를 나타냄

<br>

- 코드 세그멘트를 읽기 전용으로 설정하면 주소 공간의 독립성을 유지하면서도 여러 프로세스가 주소 공간의 일부를 공유할 수 있음
- 각 프로세스는 여전히 자신의 전용 메모리를 사용하고 있다고 생각하지만 운영체제는 이 변경이 불가능하도록 설정된 메모리 영역을 비밀리에 공유시켜 그러한 환상을 유지토록 함
- protection bit를 사용하면 앞서 언급한 하드웨어 알고리즘이 수정되어야 함
- 가상 주소가 범위 내에 있는지 확인하는 것 이외에 특정 액세스가 허용되는지를 확인해야 함
- 사용자 프로세스가 읽기 전용 페이지에 쓰기를 시도하는 경우 또는 실행 불가 페이지에서 실행하려고 하면 하드웨어는 예외를 발생시켜서 운영체제가 위반 프로세스를 처리할 수 있게 해야 함




<br>

#### 2.4. 소단위 대 대단위 세그멘테이션
- 지금까지 소수의 세그멘트(즉, 코드, 스택, 힙)만을 지원하는 시스템에만 주로 초점을 맞추었는데, 이 세그멘테이션을 **대단위(coarse-grained)** 라고 생각 할 수 있음
  - 주소 공간을 비교적 큰 단위의 공간으로 분할하기 때문
- 일부 초기 시스템 (예, Multics)은 주소 공간을 작은 크기의 공간으로 잘게 나누는 것이 허용되었기 때문에, **소단위(ine-grained)** 세그멘테이션이라고 부름

<br>

- 많은 수의 세그멘트를 지원하기 위해서는 여러 세그멘트의 정보를 메모리에 저장할 수 있는 세그멘트 테이블 같은 하드웨어가 필요함
- 세그멘트 테이블을 이용하면 매우 많은 세그멘트를 손쉽게 생성하고 융통성 있게 세그멘트를 사용할 수 있음




<br>

#### 2.5. 운영체제의 지원
- 시스템이 각 주소 공간 구성 요소를 별도로 물리 메모리에 재배치하기 때문에 전체 주소 공간이 하나의 베이스-바운드 쌍을 가지는 간단한 방식에 비해 물리 메모리를 엄청나게 절약할 수 있음
- 구체적으로는 스택과 힙 사이의 사용하지 않는 공간에 물리 메모리를 할당할 필요가 없기 때문에 같은 크기의 물리 메모리에 더 많은 주소 공간을 탑재할 수 있음

<br>

- 세그멘테이션은 새로운 많은 문제를 제기함
- 해결해야 할 새로운 운영체제 문제
  - 처음 문제는 오래된 문제로 문맥 교환 시 운영체제는 어떤 일을 해야 하는가? 
    - 세그멘트 레지스터의 저장과 복원
    - 각 프로세스는 자신의 가상 주소 공간을 가지며, 운영체제는 프로세스가 다시 실행하기 전에 레지스터들을 올바르게 설정해야 함
  - 두 번째, 더욱 중요한 문제는 미사용 중인 물리 메모리 공간의 관리
    - 새로운 주소 공간이 생성되면 운영체제는 이 공간의 세그멘트를 위한 비어있는 물리 메모리 영역을 찾을 수 있어야 함
    - 물리 메모리는 프로세스가 탑재될 슬롯의 집합이라고 생각될 수 있었으며, 지금은 프로세스가 많은 세그멘트를 가질 수 있고 각 세그멘트는 크기가 다를 수 있음

<br>

- 일반적으로 생길 수 있는 문제는 물리 메모리가 빠르게 작은 크기의 빈 공간들로 채워진다는 것
- 이 작은 빈 공간들은 새로이 생겨나는 세그멘트에 할당하기도 힘들거니와 기존 세그멘트를 확장하는 데에도 도움이 되지 않음
- 이 문제를 **외부 단편화(external fragmentation)** 라고 부름
- 이 문제의 해결책 중 한 가지는 기존의 세그멘트를 정리하여 물리 메모리를 **압축(compact)** 하는 것
  - 예를 들어 운영체제는 현재 실행 중인 프로세스를 중단하고, 그들의 데이터를 하나의 연속된 공간에 복사하고, 세그멘트 레지스터가 새로운 물리 메모리 위치를 가리키게 하여, 자신이 작업할 큰 빈 공간을 확보할 수 있음
  - 이렇게 함으로써 운영체제는 새로운 할당 요청을 충족시킬 수 있음
  - 하지만 세그멘트 복사는 메모리에 부하가 큰 연산이고 일반적으로 상당량의 프로세서 시간을 사용하기 때문에 압축은 비용이 많이듬
- 간단한 방법은 빈 공간 리스트를 관리하는 알고리즘을 사용하는 것
  - 빈 공간 관리 알고리즘은 할당 가능한 메모리 영역들을 리스트 형태로 유지함
  - **최적 적합(best-it)**, **최악 적합(worst-it)**, **최초 적합(irst-it)** 및 **버디 알고리즘(buddy algorithm)** 과 같은 고전적인 알고리즘을 포함하여 말 그대로 수백 개의 방식이 존재함
  - 이 중에서 최적 적합은 빈 공간 리스트에서 요청된 크기와 가장 비슷한 크기의 공간을 할당함
- 알고리즘이 아무리 정교하게 동작한다고 해도 외부 단편화는 여전히 존재하며, 좋은 알고리즘은 외부 단편화를 가능한 줄이는 것이 목표



































